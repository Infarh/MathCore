<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MathCore</name>
    </assembly>
    <members>
        <member name="T:MathCore.ActionList">
            <summary>Список действий <see cref="T:System.Action"/></summary>
        </member>
        <member name="M:MathCore.ActionList.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList"/></summary>
        </member>
        <member name="M:MathCore.ActionList.#ctor(System.Int32)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList"/></summary>
            <param name="Capacity">Ёмкость списка</param>
        </member>
        <member name="M:MathCore.ActionList.#ctor(System.Collections.Generic.IEnumerable{System.Action})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList"/></summary>
            <param name="ActionsEnumeration">Перечисление действий списка</param>
        </member>
        <member name="M:MathCore.ActionList.Invoke">
            <summary>Выполнение последовательности действий списка</summary>
        </member>
        <member name="T:MathCore.ActionList`1">
            <summary>Список действий <see cref="T:System.Action`1"/></summary>
            <typeparam name="T1">Тип 1 параметра действия</typeparam>
        </member>
        <member name="M:MathCore.ActionList`1.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`1"/></summary>
        </member>
        <member name="M:MathCore.ActionList`1.#ctor(System.Int32)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`1"/></summary>
            <param name="Capacity">Ёмкость списка</param>
        </member>
        <member name="M:MathCore.ActionList`1.#ctor(System.Collections.Generic.IEnumerable{System.Action{`0}})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`1"/></summary>
            <param name="ActionsEnumeration">Перечисление действий списка</param>
        </member>
        <member name="M:MathCore.ActionList`1.Invoke(`0)">
            <summary>Выполнение последовательности действий списка</summary>
        </member>
        <member name="T:MathCore.ActionList`2">
            <summary>Список действий <see cref="T:System.Action`2"/></summary>
            <typeparam name="T1">Тип 1 параметра действия</typeparam>
            <typeparam name="T2">Тип 2 параметра действия</typeparam>
        </member>
        <member name="M:MathCore.ActionList`2.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`2"/></summary>
        </member>
        <member name="M:MathCore.ActionList`2.#ctor(System.Int32)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`2"/></summary>
            <param name="Capacity">Ёмкость списка</param>
        </member>
        <member name="M:MathCore.ActionList`2.#ctor(System.Collections.Generic.IEnumerable{System.Action{`0,`1}})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`2"/></summary>
            <param name="ActionsEnumeration">Перечисление действий списка</param>
        </member>
        <member name="M:MathCore.ActionList`2.Invoke(`0,`1)">
            <summary>Выполнение последовательности действий списка</summary>
        </member>
        <member name="T:MathCore.ActionList`3">
            <summary>Список действий <see cref="T:System.Action`3"/></summary>
            <typeparam name="T1">Тип 1 параметра действия</typeparam>
            <typeparam name="T2">Тип 2 параметра действия</typeparam>
            <typeparam name="T3">Тип 3 параметра действия</typeparam>
        </member>
        <member name="M:MathCore.ActionList`3.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`3"/></summary>
        </member>
        <member name="M:MathCore.ActionList`3.#ctor(System.Int32)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`3"/></summary>
            <param name="Capacity">Ёмкость списка</param>
        </member>
        <member name="M:MathCore.ActionList`3.#ctor(System.Collections.Generic.IEnumerable{System.Action{`0,`1,`2}})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`3"/></summary>
            <param name="ActionsEnumeration">Перечисление действий списка</param>
        </member>
        <member name="M:MathCore.ActionList`3.Invoke(`0,`1,`2)">
            <summary>Выполнение последовательности действий списка</summary>
        </member>
        <member name="T:MathCore.ActionList`4">
            <summary>Список действий <see cref="T:System.Action`4"/></summary>
            <typeparam name="T1">Тип 1 параметра действия</typeparam>
            <typeparam name="T2">Тип 2 параметра действия</typeparam>
            <typeparam name="T3">Тип 3 параметра действия</typeparam>
            <typeparam name="T4">Тип 4 параметра действия</typeparam>
        </member>
        <member name="M:MathCore.ActionList`4.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`4"/></summary>
        </member>
        <member name="M:MathCore.ActionList`4.#ctor(System.Int32)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`4"/></summary>
            <param name="Capacity">Ёмкость списка</param>
        </member>
        <member name="M:MathCore.ActionList`4.#ctor(System.Collections.Generic.IEnumerable{System.Action{`0,`1,`2,`3}})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`4"/></summary>
            <param name="ActionsEnumeration">Перечисление действий списка</param>
        </member>
        <member name="M:MathCore.ActionList`4.Invoke(`0,`1,`2,`3)">
            <summary>Выполнение последовательности действий списка</summary>
        </member>
        <member name="T:MathCore.ActionList`5">
            <summary>Список действий <see cref="T:System.Action`5"/></summary>
            <typeparam name="T1">Тип 1 параметра действия</typeparam>
            <typeparam name="T2">Тип 2 параметра действия</typeparam>
            <typeparam name="T3">Тип 3 параметра действия</typeparam>
            <typeparam name="T4">Тип 4 параметра действия</typeparam>
            <typeparam name="T5">Тип 5 параметра действия</typeparam>
        </member>
        <member name="M:MathCore.ActionList`5.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`5"/></summary>
        </member>
        <member name="M:MathCore.ActionList`5.#ctor(System.Int32)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`5"/></summary>
            <param name="Capacity">Ёмкость списка</param>
        </member>
        <member name="M:MathCore.ActionList`5.#ctor(System.Collections.Generic.IEnumerable{System.Action{`0,`1,`2,`3,`4}})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`5"/></summary>
            <param name="ActionsEnumeration">Перечисление действий списка</param>
        </member>
        <member name="M:MathCore.ActionList`5.Invoke(`0,`1,`2,`3,`4)">
            <summary>Выполнение последовательности действий списка</summary>
        </member>
        <member name="T:MathCore.ActionList`6">
            <summary>Список действий <see cref="T:System.Action`6"/></summary>
            <typeparam name="T1">Тип 1 параметра действия</typeparam>
            <typeparam name="T2">Тип 2 параметра действия</typeparam>
            <typeparam name="T3">Тип 3 параметра действия</typeparam>
            <typeparam name="T4">Тип 4 параметра действия</typeparam>
            <typeparam name="T5">Тип 5 параметра действия</typeparam>
            <typeparam name="T6">Тип 6 параметра действия</typeparam>
        </member>
        <member name="M:MathCore.ActionList`6.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`6"/></summary>
        </member>
        <member name="M:MathCore.ActionList`6.#ctor(System.Int32)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`6"/></summary>
            <param name="Capacity">Ёмкость списка</param>
        </member>
        <member name="M:MathCore.ActionList`6.#ctor(System.Collections.Generic.IEnumerable{System.Action{`0,`1,`2,`3,`4,`5}})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`6"/></summary>
            <param name="ActionsEnumeration">Перечисление действий списка</param>
        </member>
        <member name="M:MathCore.ActionList`6.Invoke(`0,`1,`2,`3,`4,`5)">
            <summary>Выполнение последовательности действий списка</summary>
        </member>
        <member name="T:MathCore.ActionList`7">
            <summary>Список действий <see cref="T:System.Action`7"/></summary>
            <typeparam name="T1">Тип 1 параметра действия</typeparam>
            <typeparam name="T2">Тип 2 параметра действия</typeparam>
            <typeparam name="T3">Тип 3 параметра действия</typeparam>
            <typeparam name="T4">Тип 4 параметра действия</typeparam>
            <typeparam name="T5">Тип 5 параметра действия</typeparam>
            <typeparam name="T6">Тип 6 параметра действия</typeparam>
            <typeparam name="T7">Тип 7 параметра действия</typeparam>
        </member>
        <member name="M:MathCore.ActionList`7.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`7"/></summary>
        </member>
        <member name="M:MathCore.ActionList`7.#ctor(System.Int32)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`7"/></summary>
            <param name="Capacity">Ёмкость списка</param>
        </member>
        <member name="M:MathCore.ActionList`7.#ctor(System.Collections.Generic.IEnumerable{System.Action{`0,`1,`2,`3,`4,`5,`6}})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`7"/></summary>
            <param name="ActionsEnumeration">Перечисление действий списка</param>
        </member>
        <member name="M:MathCore.ActionList`7.Invoke(`0,`1,`2,`3,`4,`5,`6)">
            <summary>Выполнение последовательности действий списка</summary>
        </member>
        <member name="T:MathCore.AngleType">
            <summary>Тип значения угла</summary>
        </member>
        <member name="F:MathCore.AngleType.Rad">
            <summary>Радиан</summary>
        </member>
        <member name="F:MathCore.AngleType.Deg">
            <summary>Градус</summary>
        </member>
        <member name="T:MathCore.ArgumentsString">
            <summary>Аргументы командной строки</summary>
        </member>
        <member name="F:MathCore.ArgumentsString._Arguments">
            <summary>Строки значений аргументов</summary>
        </member>
        <member name="P:MathCore.ArgumentsString.Count">
            <summary>Число аргументов</summary>
        </member>
        <member name="P:MathCore.ArgumentsString.Item(System.Int32)">
            <summary>Получение аргумента по индексу</summary>
            <param name="index">Индекс аргумента</param>
            <returns>Значение аргумента по указанному индексу</returns>
        </member>
        <member name="M:MathCore.ArgumentsString.#ctor(System.String[])">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ArgumentsString"/></summary>
            <param name="Arguments">Массив значений аргументов</param>
        </member>
        <member name="M:MathCore.ArgumentsString.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ArgumentsString.op_Implicit(System.String[])~MathCore.ArgumentsString">
            <summary>Оператор неявного приведения типа массива строк к <see cref="T:MathCore.ArgumentsString"/></summary>
            <param name="Arguments">Массив строковых значений аргументов</param>
            <returns>Экземпляр <see cref="T:MathCore.ArgumentsString"/></returns>
        </member>
        <member name="M:MathCore.ArgumentsString.op_Implicit(MathCore.ArgumentsString)~System.String[]">
            <summary>Оператор неявного приведения <see cref="T:MathCore.ArgumentsString"/> к типу массива строк</summary>
            <param name="Arguments">Экземпляр <see cref="T:MathCore.ArgumentsString"/></param>
            <returns>Массив строковых значений аргументов</returns>
        </member>
        <member name="M:MathCore.ArgumentsString.op_Explicit(MathCore.ArgumentsString)~System.String">
            <summary>Оператор неявного приведения <see cref="T:MathCore.ArgumentsString"/> к строке</summary>
            <param name="Argument">Экземпляр <see cref="T:MathCore.ArgumentsString"/></param>
            <returns>Строковое представление <see cref="T:MathCore.ArgumentsString"/></returns>
        </member>
        <member name="T:MathCore.ArrayIndexer`1">
            <summary>Индексатор массива элементов</summary>
            <typeparam name="T">Тип элемента массива</typeparam>
        </member>
        <member name="F:MathCore.ArrayIndexer`1._Array">
            <summary>Индексируемый массив</summary>
        </member>
        <member name="F:MathCore.ArrayIndexer`1._Index">
            <summary>Индекс текущего элемента</summary>
        </member>
        <member name="P:MathCore.ArrayIndexer`1.Length">
            <summary>Длина массива</summary>
        </member>
        <member name="P:MathCore.ArrayIndexer`1.Index">
            <summary>Индекс текущего элемента</summary>
        </member>
        <member name="P:MathCore.ArrayIndexer`1.Value">
            <summary>Ссылка на текущий элемент массива</summary>
        </member>
        <member name="P:MathCore.ArrayIndexer`1.Item(System.Int32)">
            <summary>Элемент массива с указанным индексом</summary>
            <param name="index">Индекс элемента массива</param>
            <returns>Ссылка на элемент с указанным индексом</returns>
        </member>
        <member name="P:MathCore.ArrayIndexer`1.Array">
            <summary>Индексируемый массив</summary>
        </member>
        <member name="M:MathCore.ArrayIndexer`1.#ctor">
            <summary>Инициализация нового <see cref="T:MathCore.ArrayIndexer`1"/></summary>
        </member>
        <member name="M:MathCore.ArrayIndexer`1.#ctor(`0[],System.Int32)">
            <summary>Инициализация нового <see cref="T:MathCore.ArrayIndexer`1"/></summary>
            <param name="Array">Индексируемый массив</param>
            <param name="Index">Индекс текущего элемента</param>
        </member>
        <member name="M:MathCore.ArrayIndexer`1.op_Implicit(MathCore.ArrayIndexer{`0})~`0[]">
            <summary>Оператор неявного приведения типа <see cref="T:MathCore.ArrayIndexer`1"/> к <see cref="T:System.Array`1"/></summary>
            <param name="Indexer">Индексатор массива <see cref="T:MathCore.ArrayIndexer`1"/></param>
            <returns>Индексируемый массив элементов</returns>
        </member>
        <member name="T:MathCore.Attributes.ElementNameAttribute">
            <summary>Имя элемента</summary>
        </member>
        <member name="P:MathCore.Attributes.ElementNameAttribute.Name">
            <summary>Имя элемента</summary>
        </member>
        <member name="M:MathCore.Attributes.ElementNameAttribute.#ctor(System.String)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Attributes.ElementNameAttribute"/></summary>
            <param name="Name">Имя элемента</param>
        </member>
        <member name="M:MathCore.Attributes.ElementNameAttribute.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Attributes.ElementNameAttribute.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Attributes.ElementNameAttribute.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Attributes.ElementNameAttribute.op_Implicit(MathCore.Attributes.ElementNameAttribute)~System.String">
            <summary>Оператор неявного приведения типа <see cref="T:MathCore.Attributes.ElementNameAttribute"/> к <see cref="T:System.String"/></summary>
            <param name="A">Атрибут имени</param>
        </member>
        <member name="T:MathCore.BigInteger">
            <summary> Целочисленная арифметика с большими числами  </summary>
        </member>
        <member name="F:MathCore.BigInteger.MaxLength">
            <summary>Максимальная длина числа в байтах х8</summary>
        </member>
        <member name="F:MathCore.BigInteger.PrimesBelow2000">
            <summary>Простые числа до 2000</summary>
        </member>
        <member name="F:MathCore.BigInteger._Data">
            <summary>Байты числа</summary>
        </member>
        <member name="F:MathCore.BigInteger._DataLength">
            <summary>Число символов числа</summary>
        </member>
        <member name="P:MathCore.BigInteger.DataLength">
            <summary>Число символов числа</summary>
        </member>
        <member name="M:MathCore.BigInteger.#ctor">
            <summary>Инициализация нового пустого <see cref="T:MathCore.BigInteger"/> = 0</summary>
        </member>
        <member name="M:MathCore.BigInteger.#ctor(System.Int64)">
            <summary>Инициализация нового пустого <see cref="T:MathCore.BigInteger"/> = 0</summary>
            <param name="Value">Исходное значение числа</param>
        </member>
        <member name="M:MathCore.BigInteger.#ctor(System.UInt64)">
            <summary>Инициализация нового пустого <see cref="T:MathCore.BigInteger"/> = 0</summary>
            <param name="Value">Исходное значение числа</param>
        </member>
        <member name="M:MathCore.BigInteger.#ctor(MathCore.BigInteger)">
            <summary>Инициализация нового пустого <see cref="T:MathCore.BigInteger"/> = 0</summary>
            <param name="Value">Исходное значение числа</param>
        </member>
        <member name="M:MathCore.BigInteger.#ctor(System.String,System.Int32)">
            <summary>Инициализация нового пустого <see cref="T:MathCore.BigInteger"/> = 0</summary>
            <param name="StringValue">Строковая форма записи <see cref="T:MathCore.BigInteger"/></param>
            <param name="Base">Основание системы счисления</param>
            <exception cref="T:System.ArithmeticException">Если очередной символ в строке больше, либо равен <paramref name="Base"/></exception>
            <exception cref="T:System.OverflowException">При переполнении разрядной сетки</exception>
        </member>
        <member name="M:MathCore.BigInteger.#ctor(System.Byte[])">
            <summary>Инициализация нового пустого <see cref="T:MathCore.BigInteger"/> = 0</summary>
            <param name="Data">Байты данных <see cref="T:MathCore.BigInteger"/></param>
            <exception cref="T:System.OverflowException">При переполнении разрядной сетки</exception>
        </member>
        <member name="M:MathCore.BigInteger.op_Multiply(MathCore.BigInteger,MathCore.BigInteger)">
            <summary>Overloading of multiplication operator</summary>
            <exception cref="T:System.ArithmeticException">Multiplication overflow</exception>
        </member>
        <member name="M:MathCore.BigInteger.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.BigInteger.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.BigInteger.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.BigInteger.ToHexString">
            <summary>Представление <see cref="T:MathCore.BigInteger"/> в шестнадцатеричной системе счисления</summary>
            <returns>Строка шестнадцатеричного представления числа <see cref="T:MathCore.BigInteger"/></returns>
        </member>
        <member name="M:MathCore.BigInteger.BarrettReduction(MathCore.BigInteger,MathCore.BigInteger,MathCore.BigInteger)">
            <summary>Быстрое вычисление сокращения числа по модулю с использованием редукции Барретта</summary>
            <returns></returns>
            <remarks>
            Требуется <paramref name="x"/> &lt; b^(2k), где b база.
            В этом случае база соответствует 2^32 (uint).
            </remarks>
        </member>
        <member name="M:MathCore.BigInteger.Gcd(MathCore.BigInteger)">
            <summary>Наибольший общий делитель</summary>
        </member>
        <member name="M:MathCore.BigInteger.GenRandomBits(System.Int32,System.Random)">
            <summary>Случайный набор бит указанной длины <paramref name="bits"/></summary>
            <param name="bits">Требуемое число бит</param>
            <param name="rand">Генератор случайных чисел</param>
            <exception cref="T:System.ArithmeticException">Число бит &gt; <see cref="F:MathCore.BigInteger.MaxLength"/> = (70)x(8x8) = 4'480 </exception>
        </member>
        <member name="P:MathCore.BigInteger.BitCount">
            <summary>Число бит (номер последнего значащего бита)</summary>
        </member>
        <member name="M:MathCore.BigInteger.IntValue">
            <summary>Последние 4 байта значения числа <see cref="T:MathCore.BigInteger"/></summary>
        </member>
        <member name="M:MathCore.BigInteger.LongValue">
            <summary>Последние 8 байт значения числа <see cref="T:MathCore.BigInteger"/></summary>
        </member>
        <member name="T:MathCore.CommandProcessor.Argument">
            <summary>Аргумент команды</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.Argument.Name">
            <summary>Имя аргумента</summary>
        </member>
        <member name="F:MathCore.CommandProcessor.Argument._Values">
            <summary>Значения аргумента</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.Argument.Values">
            <summary>Значения аргумента</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.Argument.Value">
            <summary>Значение аргумента</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.Argument.Count">
            <summary>Количество значений аргумента</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.Argument.Item(System.Int32)">
            <summary>Доступ к значениям аргумента по номеру</summary>
            <param name="i">Номер значения</param>
            <returns>Значение аргумента с указанным номером</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.Argument.#ctor(System.String,System.Char)">
            <summary>Аргумент команды</summary>
            <param name="ArgStr">Строковое описание аргумента</param>
            <param name="ValueSplitter">Разделитель имени аргумента и значения</param>
        </member>
        <member name="M:MathCore.CommandProcessor.Argument.ValueAs``1">
            <summary>Представление значения в указанном типе</summary>
            <typeparam name="T">Требуемый тип значения аргумента</typeparam>
            <returns>Значение аргумента указанного типа</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.Argument.TryGetValueAs``1(``0@)">
            <summary>Попытаться получить значение аргумента команды в указанном типе <typeparamref name="T"/></summary>
            <param name="value">Приведённое к типу <typeparamref name="T"/> значение аргумента</param>
            <typeparam name="T">Требуемый тип значения аргумента</typeparam>
            <returns>Исключение, возникшее в процессе преобразования строки значения аргумента к типу <typeparamref name="T"/></returns>
        </member>
        <member name="M:MathCore.CommandProcessor.Argument.TryGetValueAs``1(``0@,System.Exception@)">
            <summary>Попытаться получить значение аргумента команды в указанном типе <typeparamref name="T"/></summary>
            <param name="value">Приведённое к типу <typeparamref name="T"/> значение аргумента</param>
            <param name="Error">Исключение, возникшее в процессе преобразования строки значения аргумента к типу <typeparamref name="T"/></param>
            <typeparam name="T">Требуемый тип значения аргумента</typeparam>
            <returns>Истина, если преобразование выполнено успешно</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.Argument.ToString">
            <summary>Преобразование в строку</summary>
            <returns>Строковое представление аргумента</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.Argument.Equals(MathCore.CommandProcessor.Argument)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.CommandProcessor.Argument.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.CommandProcessor.Argument.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.CommandProcessor.Argument.op_Equality(MathCore.CommandProcessor.Argument,MathCore.CommandProcessor.Argument)">
            <summary>Оператор, проверяющий равенство между двумя экземплярами <see cref="T:MathCore.CommandProcessor.Argument"/></summary>
            <returns>Истина, если все поля экземпляров равны между собой</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.Argument.op_Inequality(MathCore.CommandProcessor.Argument,MathCore.CommandProcessor.Argument)">
            <summary>Оператор, проверяющий неравенство между двумя экземплярами <see cref="T:MathCore.CommandProcessor.Argument"/></summary>
            <returns>Истина, если хотя бы одно поле у экземпляров отличается</returns>
        </member>
        <member name="T:MathCore.CommandProcessor.Command">
            <summary>Команда</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.Command.Name">
            <summary>Имя команды</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.Command.Parameter">
            <summary>Параметр команды</summary>
        </member>
        <member name="F:MathCore.CommandProcessor.Command._Argument">
            <summary>Массив аргументов команды</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.Command.Argument">
            <summary>Массив аргументов команды</summary>
        </member>
        <member name="M:MathCore.CommandProcessor.Command.#ctor(System.String,System.Char,System.Char,System.Char)">
            <summary>Команда</summary>
            <param name="CommandStr">Строковое представление команды</param>
            <param name="ParameterSplitter">Разделитель имени и параметра команды</param>
            <param name="ArgSplitter">Разделитель аргументов команды</param>
            <param name="ValueSplitter">Разделитель имени аргумента и его значения</param>
        </member>
        <member name="M:MathCore.CommandProcessor.Command.ToString">
            <summary>Преобразование в строку</summary>
            <returns>Строковое представление команды</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.Command.Equals(MathCore.CommandProcessor.Command)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.CommandProcessor.Command.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.CommandProcessor.Command.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.CommandProcessor.Command.op_Equality(MathCore.CommandProcessor.Command,MathCore.CommandProcessor.Command)">
            <summary>Оператор, проверяющий равенство между двумя экземплярами <see cref="T:MathCore.CommandProcessor.Command"/></summary>
            <returns>Истина, если все поля экземпляров равны между собой</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.Command.op_Inequality(MathCore.CommandProcessor.Command,MathCore.CommandProcessor.Command)">
            <summary>Оператор, проверяющий неравенство между двумя экземплярами <see cref="T:MathCore.CommandProcessor.Command"/></summary>
            <returns>Истина, если хотя бы одно поле у экземпляров отличается</returns>
        </member>
        <member name="T:MathCore.CommandProcessor.CommandArgHandlersList">
            <summary>Список обработчиков команды</summary>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandArgHandlersList.op_Addition(MathCore.CommandProcessor.CommandArgHandlersList,System.Action{MathCore.CommandProcessor.Command,System.Int32,MathCore.CommandProcessor.Command[],MathCore.CommandProcessor.Argument})">
            <summary>Оператор добавления команды к списку</summary>
            <param name="list">Список обработчиков команды</param>
            <param name="handler">Добавляемый обработчик команды</param>
            <returns>Список с добавленным обработчиком команды</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandArgHandlersList.op_Subtraction(MathCore.CommandProcessor.CommandArgHandlersList,System.Action{MathCore.CommandProcessor.Command,System.Int32,MathCore.CommandProcessor.Command[],MathCore.CommandProcessor.Argument})">
            <summary>Оператор удаления команды к списку</summary>
            <param name="list">Список обработчиков команды</param>
            <param name="handler">Удаляемый обработчик команды</param>
            <returns>Список с удалённым обработчиком команды</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandArgHandlersList.ToString">
            <inheritdoc />
        </member>
        <member name="T:MathCore.CommandProcessor.CommandEventArgs">
            <summary>Аргумент события обработки команды</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.CommandEventArgs.Command">
            <summary>Обрабатываемая команда</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.CommandEventArgs.Commands">
            <summary>Перечень команд сессии</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.CommandEventArgs.Index">
            <summary>Индекс команды в перечне команд сессии</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.CommandEventArgs.Handled">
            <summary>Признак того, что команда обработана</summary>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandEventArgs.#ctor(MathCore.CommandProcessor.Command,System.Int32,System.Collections.Generic.IReadOnlyList{MathCore.CommandProcessor.Command})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.CommandProcessor.CommandEventArgs"/></summary>
            <param name="Command">Обрабатываемая команда</param>
            <param name="Index">Индекс команды в перечне команд сессии</param>
            <param name="Commands">Перечень команд сессии</param>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandEventArgs.ToString">
            <summary>Строковое представление</summary>
            <returns>Строковое представление</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandEventArgs.SetHandled">
            <summary>Установка признака того, что команда была обработана</summary>
        </member>
        <member name="T:MathCore.CommandProcessor.CommandHandlersList">
            <summary>Список обработчиков команды</summary>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandHandlersList.op_Addition(MathCore.CommandProcessor.CommandHandlersList,System.Action{MathCore.CommandProcessor.Command,System.Int32,System.Collections.Generic.IReadOnlyList{MathCore.CommandProcessor.Command}})">
            <summary>Оператор добавления команды к списку</summary>
            <param name="list">Список обработчиков команды</param>
            <param name="Handler">Добавляемый обработчик команды</param>
            <returns>Список с добавленным обработчиком команды</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandHandlersList.op_Addition(MathCore.CommandProcessor.CommandHandlersList,System.Action{MathCore.CommandProcessor.Command})">
            <summary>Оператор добавления обработчика команды в список обработчиков</summary>
            <param name="list">Список действий обработчиков команды</param>
            <param name="Handler">Добавляемый в список обработчик</param>
            <returns>Исходный список с добавленным в него новым обработчиком команды</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandHandlersList.op_Addition(MathCore.CommandProcessor.CommandHandlersList,System.Action{MathCore.CommandProcessor.Command,System.Int32})">
            <summary>Оператор добавления позиционного обработчика команды в список обработчиков</summary>
            <param name="list">Список действий обработчиков команды</param>
            <param name="Handler">Добавляемый в список обработчик, поддерживающий параметр индекса</param>
            <returns>Исходный список с добавленным в него новым обработчиком команды</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandHandlersList.op_Addition(MathCore.CommandProcessor.CommandHandlersList,System.Action)">
            <summary>Оператор добавления безпараметрического обработчика команды в список обработчиков</summary>
            <param name="list">Список действий обработчиков команды</param>
            <param name="Handler">Добавляемый в список обработчик без параметров</param>
            <returns>Исходный список с добавленным в него новым обработчиком команды</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandHandlersList.op_Subtraction(MathCore.CommandProcessor.CommandHandlersList,System.Action{MathCore.CommandProcessor.Command,System.Int32,System.Collections.Generic.IReadOnlyList{MathCore.CommandProcessor.Command}})">
            <summary>Оператор удаления команды из списка обработчиков</summary>
            <param name="list">Список обработчиков команды</param>
            <param name="Handler">Удаляемый обработчик команды</param>
            <returns>Список с удалённым обработчиком команды</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandHandlersList.op_Subtraction(MathCore.CommandProcessor.CommandHandlersList,System.Action{MathCore.CommandProcessor.Command})">
            <summary>Оператор удаления обработчика команды из списка обработчиков</summary>
            <param name="list">Список обработчиков команды</param>
            <param name="Handler">Удаляемый обработчик команды</param>
            <returns>Список с удалённым обработчиком команды</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandHandlersList.op_Subtraction(MathCore.CommandProcessor.CommandHandlersList,System.Action{MathCore.CommandProcessor.Command,System.Int32})">
            <summary>Оператор удаления обработчика команды с индексатором из списка обработчиков</summary>
            <param name="list">Список обработчиков команды</param>
            <param name="Handler">Удаляемый обработчик команды с индексатором</param>
            <returns>Список с удалённым обработчиком команды</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandHandlersList.op_Subtraction(MathCore.CommandProcessor.CommandHandlersList,System.Action)">
            <summary>Оператор удаления обработчика команды из списка обработчиков</summary>
            <param name="list">Список обработчиков команды</param>
            <param name="Handler">Удаляемый обработчик команды</param>
            <returns>Список с удалённым обработчиком команды</returns>
        </member>
        <member name="F:MathCore.CommandProcessor.CommandHandlersList._CommandHandlers">
            <summary>Словарь обработчиков команд (ключ - имя команды, значение - список обработчиков)</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.CommandHandlersList.Item(System.String)">
            <summary>Обращение к списку обработчиков команды по её имени (индексатор)</summary>
            <param name="CommandName">Имя команды</param>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandHandlersList.IsRegisteredCommand(System.String)">
            <summary>Зарегистрирована ли команда в процессоре?</summary>
            <param name="CommandName">Имя команды</param>
            <returns>Истина, если в процессоре существует обработчик команды с указанным именем</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandHandlersList.ToString">
            <inheritdoc />
        </member>
        <member name="T:MathCore.CommandProcessor.CommandLineProcessor">
            <summary>Командный процессор</summary>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandLineProcessor.ParseConsole(System.String,System.Action{MathCore.CommandProcessor.CommandLineProcessor},System.IO.TextWriter,System.IO.TextReader)">
            <summary>Разобрать команды консоли управления</summary>
            <param name="Prompt">Формат запроса</param>
            <param name="Initializer">Метод инициализации команд</param>
            <param name="ConsoleWriter">Вывод в консоль (если не указано, то используется <see cref="T:System.Console"/>.<see cref="P:System.Console.Out"/>)</param>
            <param name="ConsoleReader">Ввод с консоли (если не указано, то используется <see cref="T:System.Console"/>.<see cref="P:System.Console.In"/>)</param>
            <returns>Сформированное перечисление команд запроса</returns>
        </member>
        <member name="E:MathCore.CommandProcessor.CommandLineProcessor.CommandProcess">
            <summary>Событие обработки команды</summary>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandLineProcessor.OnCommandProcess(MathCore.CommandProcessor.CommandEventArgs)">
            <summary>Обработка команды</summary>
            <param name="Arg">Аргумент, содержащий сведения о команде</param>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandLineProcessor.OnCommandProcess(MathCore.CommandProcessor.Command,System.Int32,MathCore.CommandProcessor.Command[])">
            <summary>Обработка команды</summary>
            <param name="command">Обрабатываемая команда</param>
            <param name="index">Индекс команды в массиве команд сессии</param>
            <param name="commands">Массив команд сессии</param>
        </member>
        <member name="E:MathCore.CommandProcessor.CommandLineProcessor.UnhandledCommand">
            <summary>Событие появления необработанной команды</summary>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandLineProcessor.OnUnhandledCommand(MathCore.CommandProcessor.CommandEventArgs)">
            <summary>Генерация события обнаружения необработанной команды</summary>
            <param name="Arg">Аргумент события, содержащий сведения о команде</param>
        </member>
        <member name="F:MathCore.CommandProcessor.CommandLineProcessor._CommandHandlers">
            <summary>Словарь списков обработчиков команд</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.CommandLineProcessor.Commands">
            <summary>Команды, обрабатываемые процессором</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.CommandLineProcessor.CommandSplitter">
            <summary>Разделитель команд в строке</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.CommandLineProcessor.CommandParameterSplitter">
            <summary>Разделитель имени команды и её параметра</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.CommandLineProcessor.ArgSplitter">
            <summary>Разделитель аргументов команды</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.CommandLineProcessor.ValueSplitter">
            <summary>Разделитель имени аргумента и его значения</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.CommandLineProcessor.Item(System.String)">
            <summary>Доступ к списку обработчиков команды по её имени</summary>
            <param name="CommandName">Имя команды</param>
            <returns>Список обработчиков команды</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandLineProcessor.#ctor(System.Char,System.Char,System.Char,System.Char)">
            <summary>Командный процессор</summary>
            <param name="CommandSplitter">Разделитель команд в строке</param>
            <param name="CommandParameterSplitter">Разделитель имени команды и её параметра</param>
            <param name="ArgSplitter">Разделитель аргументов</param>
            <param name="ValueSplitter">Разделитель имени аргумента и его значения</param>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandLineProcessor.Process(System.String[])">
            <summary>Обработать команду</summary>
            <param name="CommandLine">Командная строка</param>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandLineProcessor.AddCommandHandler(System.String,System.Action{MathCore.CommandProcessor.Command,System.Int32,System.Collections.Generic.IReadOnlyList{MathCore.CommandProcessor.Command}})">
            <summary>Добавить обработчик команды</summary>
            <param name="CommandName">Имя команды</param>
            <param name="CommandHandler">Добавляемый обработчик команды</param>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandLineProcessor.RemoveCommandHandler(System.String,System.Action{MathCore.CommandProcessor.Command,System.Int32,System.Collections.Generic.IReadOnlyList{MathCore.CommandProcessor.Command}})">
            <summary>Удалить обработчик команды</summary>
            <param name="CommandName">Имя команды</param>
            <param name="CommandHandler">Удаляемый обработчик команды</param>
            <returns>Истина, если удалось обработчик команды удалить</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandLineProcessor.ClearCommandHandlers(System.String)">
            <summary>Очистить список обработчиков команды</summary>
            <param name="CommandName">Имя команды</param>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandLineProcessor.ClearCommandHandlers">
            <summary>Очистить все обработчики команд</summary>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandLineProcessor.GetRegisteredCommands">
            <summary>Получить перечисление имён команд с зарегистрированными обработчиками</summary>
            <returns>Перечисление имён команд, имеющих свои обработчики</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandLineProcessor.IsRegisteredCommand(System.String)">
            <summary>Проверка - имеет ли команда обработчики</summary>
            <param name="CommandName">Проверяемая команда</param>
            <returns>Истина, если указаны обработчики команды</returns>
        </member>
        <member name="T:MathCore.CommandStringArguments">
            <summary>Аргументы командной строки</summary>
        </member>
        <member name="F:MathCore.CommandStringArguments._Arguments">
            <summary>Массив аргументов командной строки</summary>
        </member>
        <member name="P:MathCore.CommandStringArguments.Count">
            <summary>Количество аргументов командной строки</summary>
        </member>
        <member name="P:MathCore.CommandStringArguments.Item(System.Int32)">
            <summary>Аргумент командной строки с указанным индексом</summary>
            <param name="i">Индекс аргумента</param>
            <returns>Значение аргумента с указанным индексом</returns>
        </member>
        <member name="M:MathCore.CommandStringArguments.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.CommandStringArguments"/></summary>
            <param name="Args">Перечисление значений аргументов командной строки</param>
        </member>
        <member name="M:MathCore.CommandStringArguments.GetEnumerator">
            <summary>Возвращает перечислитель, выполняющий перебор элементов в коллекции аргументов командной строки</summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.IEnumerator`1"/>, 
            который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:MathCore.CommandStringArguments.System#Collections#IEnumerable#GetEnumerator">
            <summary>Возвращает перечислитель, который осуществляет перебор элементов коллекции.</summary>
            <returns>
            Объект <see cref="T:System.Collections.IEnumerator"/>, 
            который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:MathCore.Complex">
            <summary>Комплексное число</summary>
        </member>
        <member name="M:MathCore.Complex.ClearString(System.String@)">
            <summary>Метод убирает все парные символы скобок в начале и конце строки</summary>
            <param name="str">Очищаемая строка</param>
        </member>
        <member name="M:MathCore.Complex.Parse(System.String)">
            <summary>Разобрать строку в комплексное число</summary>
            <param name="str">Разбираемая строка</param>
            <returns>Комплексное число, получаемое в результате разбора строки</returns>
            <exception cref="T:System.ArgumentNullException">В случае если передана пустая ссылка на строку</exception>
            <exception cref="T:System.FormatException">В случае ошибочной строки</exception>
        </member>
        <member name="M:MathCore.Complex.TryParse(System.String,MathCore.Complex@)">
            <summary>Попытаться разобрать строку и преобразовать её в комплексное число</summary>
            <param name="str">Разбираемая строка</param>
            <param name="z">Число, получаемое в результате разбора строки</param>
            <returns>Истина, если операция разбора строки выполнена успешно</returns>
        </member>
        <member name="F:MathCore.Complex.Epsilon">
            <summary>Точность вычисления тригонометрических функций 3e-16 </summary>
            <remarks>Определено приближённо</remarks>
        </member>
        <member name="M:MathCore.Complex.Ln(System.Double)">
            <summary>Логарифм комплексного аргумента</summary>
            <param name="Im">Комплексный аргумент</param>
            <returns>Значение логарифма</returns>
        </member>
        <member name="M:MathCore.Complex.Ln(MathCore.Complex@)">
            <summary>Натуральный логогриф комплексного числа</summary>
            <param name="z">Комплексное число</param>
            <returns>Натуральный логарифм</returns>
        </member>
        <member name="M:MathCore.Complex.Log(System.Double,System.Double)">
            <summary>Логогриф мнимого числа по действительному основанию</summary>
            <param name="Im">Мнимое число</param>
            <param name="b">Действительное основание логарифма</param>
            <returns>Логарифм мнимого числа по действительному основанию</returns>
        </member>
        <member name="M:MathCore.Complex.Log(MathCore.Complex@,System.Double)">
            <summary>Логарифм комплексного числа по действительному аргументу</summary>
            <param name="z">Комплексное число</param>
            <param name="b">Действительное основание логарифма</param>
            <returns>Логарифм комплексного числа по действительному основанию</returns>
        </member>
        <member name="M:MathCore.Complex.Exp(System.Double)">
            <summary>Экспоненциальная форма числа Z = e^j*Arg</summary>
            <param name="Arg">Аргумент</param>
            <returns>Комплексное число в экспоненциальной форме записи</returns>
        </member>
        <member name="M:MathCore.Complex.Exp(System.Double,System.Double)">
            <summary>Экспоненциальная форма числа Z = Abs * e^j*Arg</summary>
            <param name="Abs">Модуль числа</param>
            <param name="Arg">Аргумент числа</param>
            <returns>Комплексное число в экспоненциальной форме</returns>
        </member>
        <member name="M:MathCore.Complex.Exp(MathCore.Complex@)">
            <summary>Экспонента с комплексным показателем Z = e^(re + j*im) = e^re * [cos(im) + j*sin(im)]</summary>
            <param name="z">Комплексный показатель степени экспоненты</param>
            <returns>Результат вычисления комплексной экспоненты</returns>
        </member>
        <member name="M:MathCore.Complex.Mod(System.Double,System.Double)">
            <summary>Алгебраическая форма записи комплексного числа</summary>
            <param name="Re">Действительная часть числа</param>
            <param name="Im">Мнимая часть числа</param>
            <returns>Комплексное число в алгебраической форме записи</returns>
        </member>
        <member name="M:MathCore.Complex.Mod(System.Double,MathCore.Complex@)">
            <summary>Алгебраическая форма записи комплексного числа</summary>
            <param name="Re">Действительная часть числа</param>
            <param name="Im">Мнимая часть числа</param>
            <returns>Комплексное число в алгебраической форме записи</returns>
        </member>
        <member name="M:MathCore.Complex.Mod(MathCore.Complex@,MathCore.Complex@)">
            <summary>Алгебраическая форма записи комплексного числа</summary>
            <param name="Re">Действительная часть числа</param>
            <param name="Im">Мнимая часть числа</param>
            <returns>Комплексное число в алгебраической форме записи</returns>
        </member>
        <member name="M:MathCore.Complex.Mod(MathCore.Complex@,System.Double)">
            <summary>Алгебраическая форма записи комплексного числа</summary>
            <param name="Re">Действительная часть числа</param>
            <param name="Im">Мнимая часть числа</param>
            <returns>Комплексное число в алгебраической форме записи</returns>
        </member>
        <member name="F:MathCore.Complex.Real">
            <summary>Действительное "комплексное" число</summary>
        </member>
        <member name="F:MathCore.Complex.NaN">
            <summary>Не-число</summary>
        </member>
        <member name="F:MathCore.Complex.i">
            <summary>Мнимая единица</summary>
        </member>
        <member name="M:MathCore.Complex.CreateArray(System.Double[],System.Double[])">
            <summary>Создать массив комплексных чисел</summary>
            <param name="Re">Массив действительных чисел</param>
            <param name="Im">Массив мнимых чисел</param>
            <returns>Массив комплексных чисел</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="Re"/> or <paramref name="Im"/> is <see langword="null"/></exception>
            <exception cref="T:System.InvalidOperationException">Длины массивов не совпадают</exception>
        </member>
        <member name="F:MathCore.Complex._Re">
            <summary>Действительная часть</summary>
        </member>
        <member name="F:MathCore.Complex._Im">
            <summary>Мнимая часть</summary>
        </member>
        <member name="P:MathCore.Complex.Expression">
            <summary>Преобразование комплексного числа в выражение</summary>
        </member>
        <member name="P:MathCore.Complex.Re">
            <summary>Действительная часть</summary>
        </member>
        <member name="P:MathCore.Complex.Im">
            <summary>Мнимая часть</summary>
        </member>
        <member name="P:MathCore.Complex.Power">
            <summary>X * X^* = Re(X)^2 + Im(X)^2</summary>
        </member>
        <member name="P:MathCore.Complex.Abs">
            <summary>Модуль</summary>
        </member>
        <member name="P:MathCore.Complex.Arg">
            <summary>Аргумент</summary>
        </member>
        <member name="P:MathCore.Complex.ComplexConjugate">
            <summary>Комплексно сопряжённое число</summary>
        </member>
        <member name="P:MathCore.Complex.Reciprocal">
            <summary>Обратное значение 1/Z</summary>
        </member>
        <member name="M:MathCore.Complex.#ctor(System.Double,System.Double)">
            <summary>Комплексное число</summary>
            <param name="Re">Действительная часть</param>
            <param name="Im">Мнимая часть</param>
        </member>
        <member name="M:MathCore.Complex.ToString_Exponent">
            <summary>Представление комплексного числа в текстовой экспоненциальной форме</summary>
            <returns>Текстовое экспоненциальное представление комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.ToString_Exponent_pi">
            <summary>Представление комплексного числа в текстовой экспоненциальной форме с нормировкой аргумента к значению pi</summary>
            <returns>Текстовое экспоненциальное представление комплексного числа с нормировкой аргумента к значению pi</returns>
        </member>
        <member name="M:MathCore.Complex.ToString_Exponent_Deg">
            <summary>Представление комплексного числа в текстовой экспоненциальной форме с нормировкой аргумента в градусах</summary>
            <returns>Текстовое экспоненциальное представление комплексного числа с нормировкой аргумента в градусах</returns>
        </member>
        <member name="M:MathCore.Complex.ToString">
            <summary>Строковый эквивалент</summary>
        </member>
        <member name="M:MathCore.Complex.ToString(System.String)">
            <summary>Преобразование в строковый формат</summary>
            <param name="Format">Формат преобразования</param>
            <returns>Строковое представление</returns>
        </member>
        <member name="M:MathCore.Complex.ToString(System.String,System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Complex.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Complex.Clone">
            <summary>Получение клона</summary>
            <returns>Клон числа</returns>
        </member>
        <member name="M:MathCore.Complex.System#ICloneable#Clone">
            <summary>Получение клона</summary>
            <returns>Клон числа</returns>
        </member>
        <member name="M:MathCore.Complex.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Complex.Equals(MathCore.Complex)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.System#IEquatable{MathCore#Complex}#Equals(MathCore.Complex)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.Equals(System.Double)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.System#IEquatable{System#Double}#Equals(System.Double)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.Equals(System.Int16)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.System#IEquatable{System#Int16}#Equals(System.Int16)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.Equals(System.UInt16)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.System#IEquatable{System#UInt16}#Equals(System.UInt16)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.Equals(System.Byte)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.System#IEquatable{System#Byte}#Equals(System.Byte)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.Equals(System.SByte)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.System#IEquatable{System#SByte}#Equals(System.SByte)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.Equals(System.Single)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.System#IEquatable{System#Single}#Equals(System.Single)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.Equals(System.Int32)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.System#IEquatable{System#Int32}#Equals(System.Int32)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.Equals(System.UInt32)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.System#IEquatable{System#UInt32}#Equals(System.UInt32)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.Equals(System.Int64)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.System#IEquatable{System#Int64}#Equals(System.Int64)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.Equals(System.UInt64)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.System#IEquatable{System#UInt64}#Equals(System.UInt64)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.System#IEquatable{(System#DoubleRe,System#DoubleIm)}#Equals(System.ValueTuple{System.Double,System.Double})">
            <summary>Проверка на идентичность</summary>
            <param name="other">Кортеж двух вещественных чисел</param>
            <returns>Истина, если действительная и мнимая части идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.Rotate(System.Double)">
            <summary>Поворот вектора комплексного числа на угол</summary>
            <param name="w">Угол поворота вектора в комплексной плоскости</param>
            <returns>Комплексное число, повёрнутое на угол</returns>
        </member>
        <member name="M:MathCore.Complex.Round(System.Int32)">
            <summary>Округление числа</summary>
            <param name="DigitsCount">Число разрядов</param>
            <returns>Округлённое число</returns>
        </member>
        <member name="M:MathCore.Complex.Sqrt">
            <summary>Вычисление квадратного корня числа</summary>
            <returns>Квадратный корень числа</returns>
        </member>
        <member name="M:MathCore.Complex.Sqrt(MathCore.Complex@)">
            <summary>Вычисление корня комплексной степени</summary>
            <param name="z">Комплексная степень корня</param>
            <returns>Комплексный результат вычисления корня комплексной степени от комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.Sqrt(System.Double)">
            <summary>Вычисление корня действительной степени</summary>
            <param name="x">Действительная степень корня</param>
            <returns>Комплексный результат вычисления корня действительной степени от комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.Deconstruct(System.Double@,System.Double@)">
            <summary>Деконструктор комплексного числа</summary>
            <param name="re">Действительная часть</param>
            <param name="im">Мнимая часть</param>
        </member>
        <member name="M:MathCore.Complex.op_UnaryNegation(MathCore.Complex@)">
            <summary>Унарный оператор разности. Возвращает число -Re-jIm</summary>
            <param name="z">Комплексное число</param>
            <returns>Возвращает -Re-jIm</returns>
        </member>
        <member name="M:MathCore.Complex.op_UnaryPlus(MathCore.Complex@)">
            <summary>Унарный оператор суммы. Возвращает число Re+jIm</summary>
            <param name="z">Комплексное число</param>
            <returns>Возвращает Re+jIm</returns>
        </member>
        <member name="M:MathCore.Complex.op_LogicalNot(MathCore.Complex@)">
            <summary>Оператор комплексного сопряжения</summary>
            <param name="z">Комплексное число</param>
            <returns>Возвращает Re-jIm</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(MathCore.Complex@,MathCore.Complex@)">
            <summary>Оператор сложения</summary>
            <param name="X">Первое слагаемое</param>
            <param name="Y">Второе слагаемое</param>
            <returns>Сумма комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(MathCore.Complex@,MathCore.Complex@)">
            <summary>Оператор разности комплексных чисел</summary>
            <param name="X">Уменьшаемое комплексное число</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Разность комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(System.Double,MathCore.Complex@)">
            <summary>Оператор сложения</summary>
            <param name="X">Первое слагаемое</param>
            <param name="Y">Второе слагаемое</param>
            <returns>Сумма комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(System.Int32,MathCore.Complex@)">
            <summary>Оператор суммы целого и комплексного числа</summary>
            <param name="X">Целое число</param>
            <param name="Y">Комплексное число</param>
            <returns>X+Re{Y}+jIm{Y}</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(System.Single,MathCore.Complex@)">
            <summary>Оператор суммы вещественного числа одинарной точности и комплексного числа</summary>
            <param name="X">Вещественное число одинарной точности число</param>
            <param name="Y">Комплексное число</param>
            <returns>X+Re{Y}+jIm{Y}</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(System.Double,MathCore.Complex@)">
            <summary>Оператор разности комплексных чисел</summary>
            <param name="X">Уменьшаемое комплексное число</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Разность комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(System.Int32,MathCore.Complex@)">
            <summary>Оператор разности целого и комплексного числа</summary>
            <param name="X">Целое число</param>
            <param name="Y">Комплексное число</param>
            <returns>X-Re{Y}-jIm{Y}</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(System.Single,MathCore.Complex@)">
            <summary>Оператор разности вещественного числа одинарной точности и комплексного числа</summary>
            <param name="X">Вещественное число одинарной точности число</param>
            <param name="Y">Комплексное число</param>
            <returns>X-Re{Y}-jIm{Y}</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(MathCore.Complex@,System.Double)">
            <summary>Оператор сложения</summary>
            <param name="X">Первое слагаемое</param>
            <param name="Y">Второе слагаемое</param>
            <returns>Сумма комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(MathCore.Complex@,System.Int32)">
            <summary>Оператор суммы комплексного числа и целого числа</summary>
            <param name="X">Комплексное число</param>
            <param name="Y">Целое число</param>
            <returns>Re{X}+Y+jIm{X}</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(MathCore.Complex@,System.Single)">
            <summary>Оператор суммы комплексного числа и вещественного числа одинарной точности</summary>
            <param name="X">Комплексное число</param>
            <param name="Y">Вещественное число одинарной точности</param>
            <returns>Re{X}+Y+jIm{X}</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(MathCore.Complex@,System.Double)">
            <summary>Оператор разности комплексных чисел</summary>
            <param name="X">Уменьшаемое комплексное число</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Разность комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(MathCore.Complex@,System.Int32)">
            <summary>Оператор разности комплексного числа и целого числа</summary>
            <param name="X">Комплексное число</param>
            <param name="Y">Целое число</param>
            <returns>Re{X}-Y+jIm{X}</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(MathCore.Complex@,System.Single)">
            <summary>Оператор разности комплексного числа и вещественного числа одинарной точности</summary>
            <param name="X">Комплексное число</param>
            <param name="Y">Вещественное число одинарной точности</param>
            <returns>Re{X}-Y+jIm{X}</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(MathCore.Complex@,System.Double)">
            <summary>Оператор умножения комплексного числа на вещественное</summary>
            <param name="X">Комплексное число</param>
            <param name="Y">Вещественное число</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(MathCore.Complex@,System.Int32)">
            <summary>Оператор умножения комплексного числа на целое</summary>
            <param name="X">Комплексное число</param>
            <param name="Y">Целое число</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(MathCore.Complex@,System.Single)">
            <summary>Оператор умножения комплексного числа на вещественное одинарной точности</summary>
            <param name="X">Комплексное число</param>
            <param name="Y">Вещественное число одинарной точности</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(MathCore.Complex@,System.Double)">
            <summary>Оператор деления комплексного числа на вещественное</summary>
            <param name="X">Комплексное делимое число</param>
            <param name="Y">Вещественный делитель</param>
            <returns>Комплексное частное</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(MathCore.Complex@,System.Int32)">
            <summary>Оператор деления комплексного числа на целое</summary>
            <param name="X">Комплексное делимое число</param>
            <param name="Y">Целый делитель</param>
            <returns>Комплексное частное</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(MathCore.Complex@,System.Single)">
            <summary>Оператор деления комплексного числа на вещественное одинарной точности</summary>
            <param name="X">Комплексное делимое число</param>
            <param name="Y">Вещественный делитель одинарной точности</param>
            <returns>Комплексное частное</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(System.Double,MathCore.Complex@)">
            <summary>Оператор произведения вещественного и комплексного числа</summary>
            <param name="X">Вещественное число</param>
            <param name="Y">Комплексное число</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(System.Int32,MathCore.Complex@)">
            <summary>Оператор произведения целого и комплексного числа</summary>
            <param name="X">Целое число</param>
            <param name="Y">Комплексное число</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(System.Single,MathCore.Complex@)">
            <summary>Оператор произведения вещественного числа одинарной точности и комплексного числа</summary>
            <param name="X">Вещественное число одинарной точности</param>
            <param name="Y">Комплексное число</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(System.Double,MathCore.Complex@)">
            <summary>Оператор деления вещественного и комплексного числа</summary>
            <param name="X">Вещественное делимое число</param>
            <param name="Y">Комплексный делитель</param>
            <returns>Комплексное частное</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(System.Int32,MathCore.Complex@)">
            <summary>Оператор деления целого и комплексного числа</summary>
            <param name="X">Целого делимое число</param>
            <param name="Y">Комплексный делитель</param>
            <returns>Комплексное частное</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(System.Single,MathCore.Complex@)">
            <summary>Оператор деления вещественного числа одинарной точности и комплексного числа</summary>
            <param name="X">Вещественное делимое число одинарной точности</param>
            <param name="Y">Комплексный делитель</param>
            <returns>Комплексное частное</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(MathCore.Complex@,MathCore.Complex@)">
            <summary>Оператор произведения двух комплексных чисел</summary>
            <param name="X">Первый множитель</param>
            <param name="Y">Второй множитель</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(MathCore.Complex@,MathCore.Complex@)">
            <summary>Оператор деления двух комплексных чисел</summary>
            <param name="X">Делимое комплексное число</param>
            <param name="Y">Делитель комплексного числа</param>
            <returns>Частное двух комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_ExclusiveOr(MathCore.Complex@,System.Double)">
            <summary>Возведение комплексного числа в вещественную степень по формуле Муавра</summary>
            <param name="Z">Возводимое в степень комплексное число Z^X</param>
            <param name="X">Вещественный показатель степени Z^X</param>
            <returns>Z^X</returns>       
        </member>
        <member name="M:MathCore.Complex.op_ExclusiveOr(MathCore.Complex@,System.Single)">
            <summary>Возведение комплексного числа в вещественную степень одинарной точности по формуле Муавра</summary>
            <param name="Z">Возводимое в степень комплексное число Z^X</param>
            <param name="X">Вещественный показатель степени одинарной точности Z^X</param>
            <returns>Z^X</returns> 
        </member>
        <member name="M:MathCore.Complex.op_ExclusiveOr(MathCore.Complex@,System.Int32)">
            <summary>Возведение комплексного числа в целую степень по формуле Муавра</summary>
            <param name="Z">Возводимое в степень комплексное число Z^X</param>
            <param name="X">Целый показатель степени Z^X</param>
            <returns>Z^X</returns> 
        </member>
        <member name="M:MathCore.Complex.op_ExclusiveOr(System.Double,MathCore.Complex@)">
            <summary>Оператор возведения вещественного числа в комплексную степень</summary>
            <param name="X">Вещественное число</param>
            <param name="Z">Комплексная степень</param>
            <returns>Комплексный результат возведения вещественного числа в комплексную степень</returns>
        </member>
        <member name="M:MathCore.Complex.op_ExclusiveOr(System.Single,MathCore.Complex@)">
            <summary>Оператор возведения вещественного числа одинарной точности в комплексную степень</summary>
            <param name="X">Вещественное число одинарной точности</param>
            <param name="Z">Комплексная степень</param>
            <returns>Комплексный результат возведения вещественного числа одинарной точности в комплексную степень</returns>
        </member>
        <member name="M:MathCore.Complex.op_ExclusiveOr(System.Int32,MathCore.Complex@)">
            <summary>Оператор возведения целого числа в комплексную степень</summary>
            <param name="X">Целое число</param>
            <param name="Z">Комплексная степень</param>
            <returns>Комплексный результат возведения целого числа в комплексную степень</returns>
        </member>
        <member name="M:MathCore.Complex.op_ExclusiveOr(MathCore.Complex@,MathCore.Complex@)">
            <summary>Оператор возведения комплексного числа в комплексную степень</summary>
            <param name="X">Комплексное основание экспоненты</param>
            <param name="Y">Комплексный показатель степени</param>
            <returns>Комплексный результат возведения комплексного числа в комплексную степень</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(System.Int32[]@,MathCore.Complex@)">
            <summary>Оператор, прибавляющий комплексное число к массиву целых чисел</summary>
            <param name="X">Массив целых чисел</param>
            <param name="Y">Прибавляемое комплексное число</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементной суммы целых чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(System.Single[]@,MathCore.Complex@)">
            <summary>Оператор, прибавляющий комплексное число к массиву действительных чисел одинарной точности</summary>
            <param name="X">Массив действительных чисел одинарной точности</param>
            <param name="Y">Прибавляемое комплексное число</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементной суммы вещественных чисел одинарной точности исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(System.Double[]@,MathCore.Complex@)">
            <summary>Оператор, прибавляющий комплексное число к массиву действительных чисел</summary>
            <param name="X">Массив действительных чисел</param>
            <param name="Y">Прибавляемое комплексное число</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементной суммы вещественных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(System.Int32[]@,MathCore.Complex@)">
            <summary>Оператор, вычитающий комплексное число из массива целых чисел</summary>
            <param name="X">Массив целых чисел</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементной разности целых чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(System.Single[]@,MathCore.Complex@)">
            <summary>Оператор, вычитающий комплексное число из массива вещественных чисел одинарной точности</summary>
            <param name="X">Массив действительных чисел</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементной разности вещественных чисел одинарной точности исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(System.Double[]@,MathCore.Complex@)">
            <summary>Оператор, вычитающий комплексное число из массива вещественных чисел</summary>
            <param name="X">Массив действительных чисел</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементной разности вещественных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(System.Int32[]@,MathCore.Complex@)">
            <summary>Оператор, умножающий комплексное число на массив целых чисел</summary>
            <param name="X">Массив целых чисел</param>
            <param name="Y">Комплексный множитель</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементного произведения целых чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(System.Single[]@,MathCore.Complex@)">
            <summary>Оператор, умножающий комплексное число на массив вещественных чисел одинарной точности</summary>
            <param name="X">Массив вещественных чисел одинарной точности</param>
            <param name="Y">Комплексный множитель</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементного произведения вещественных чисел одинарной точности исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(System.Double[]@,MathCore.Complex@)">
            <summary>Оператор, умножающий комплексное число на массив вещественных чисел</summary>
            <param name="X">Массив вещественных чисел</param>
            <param name="Y">Комплексный множитель</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементного произведения вещественных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(System.Int32[]@,MathCore.Complex@)">
            <summary>Оператор поэлементного деления массива целых чисел на комплексное число</summary>
            <param name="X">Массив целых чисел</param>
            <param name="Y">Комплексный делитель</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементного деления целых чисел исходного массива на указанное комплексное число</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(System.Single[]@,MathCore.Complex@)">
            <summary>Оператор поэлементного деления массива вещественных чисел одинарной точности на комплексное число</summary>
            <param name="X">Массив вещественных чисел одинарной точности</param>
            <param name="Y">Комплексный делитель</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементного деления вещественных чисел одинарной точности исходного массива на указанное комплексное число</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(System.Double[]@,MathCore.Complex@)">
            <summary>Оператор поэлементного деления массива вещественных чисел на комплексное число</summary>
            <param name="X">Массив вещественных чисел</param>
            <param name="Y">Комплексный делитель</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементного деления вещественных чисел исходного массива на указанное комплексное число</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(MathCore.Complex[]@,MathCore.Complex@)">
            <summary>Оператор поэлементной суммы массива комплексных чисел и комплексного числа</summary>
            <param name="X">Массив комплексных чисел</param>
            <param name="Y">Прибавляемое комплексное число</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементной суммы комплексных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(MathCore.Complex[]@,MathCore.Complex@)">
            <summary>Оператор поэлементной разности массива комплексных чисел и комплексного числа</summary>
            <param name="X">Массив комплексных чисел</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементной разности комплексных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(MathCore.Complex[]@,MathCore.Complex@)">
            <summary>Оператор поэлементного произведения массива комплексных чисел и комплексного числа</summary>
            <param name="X">Массив комплексных чисел</param>
            <param name="Y">Комплексных множитель</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементного произведения комплексных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(MathCore.Complex[]@,MathCore.Complex@)">
            <summary>Оператор поэлементного частного массива комплексных чисел и комплексного числа</summary>
            <param name="X">Массив комплексных чисел</param>
            <param name="Y">Комплексных делитель</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементного частного комплексных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(MathCore.Complex@,MathCore.Complex@)">
            <summary>Оператор сравнения двух комплексных чисел (равенства)</summary>
            <returns>Истина, если числа равны между собой</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(MathCore.Complex@,MathCore.Complex@)">
            <summary>Оператор сравнения двух комплексных чисел (неравенства)</summary>
            <returns>Истина, если числа не равны</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(MathCore.Complex@,System.Single)">
            <summary>Оператор равенства комплексного числа вещественному числу одинарной точности</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое вещественное число одинарной точности</param>
            <returns>Истина, если реальная часть <paramref name="X"/> равна <paramref name="Y"/>, а мнимая часть равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(MathCore.Complex@,System.Single)">
            <summary>Оператор неравенства комплексного числа вещественному числу одинарной точности</summary>
            <param name="X">Сравниваемое комплексное число одинарной точности</param>
            <param name="Y">Сравниваемое вещественное число</param>
            <returns>Истина, если реальная часть <paramref name="X"/> не равна <paramref name="Y"/>, либо мнимая часть не равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(MathCore.Complex@,System.Double)">
            <summary>Оператор равенства комплексного числа вещественному числу</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое вещественное число</param>
            <returns>Истина, если реальная часть <paramref name="X"/> равна <paramref name="Y"/>, а мнимая часть равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(MathCore.Complex@,System.Double)">
            <summary>Оператор неравенства комплексного числа вещественному числу</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое вещественное число</param>
            <returns>Истина, если реальная часть <paramref name="X"/> не равна <paramref name="Y"/>, либо мнимая часть не равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(MathCore.Complex@,System.SByte)">
            <summary>Оператор равенства комплексного числа целому числу (1 байт со знаком)</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число (1 байт со знаком)</param>
            <returns>Истина, если реальная часть <paramref name="X"/> равна <paramref name="Y"/>, а мнимая часть равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(MathCore.Complex@,System.SByte)">
            <summary>Оператор неравенства комплексного числа целому числу (1 байт со знаком)</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число (1 байт со знаком)</param>
            <returns>Истина, если реальная часть <paramref name="X"/> не равна <paramref name="Y"/>, либо мнимая часть не равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(MathCore.Complex@,System.Byte)">
            <summary>Оператор равенства комплексного числа целому числу (1 байт без знака)</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число (1 байт без знака)</param>
            <returns>Истина, если реальная часть <paramref name="X"/> равна <paramref name="Y"/>, а мнимая часть равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(MathCore.Complex@,System.Byte)">
            <summary>Оператор неравенства комплексного числа целому числу (1 байт без знака)</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число (1 байт без знака)</param>
            <returns>Истина, если реальная часть <paramref name="X"/> не равна <paramref name="Y"/>, либо мнимая часть не равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(MathCore.Complex@,System.Int16)">
            <summary>Оператор равенства комплексного числа целому числу (2 байта со знаком)</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число (2 байта со знаком)</param>
            <returns>Истина, если реальная часть <paramref name="X"/> равна <paramref name="Y"/>, а мнимая часть равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(MathCore.Complex@,System.Int16)">
            <summary>Оператор неравенства комплексного числа целому числу (2 байта со знаком)</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число (2 байта со знаком)</param>
            <returns>Истина, если реальная часть <paramref name="X"/> не равна <paramref name="Y"/>, либо мнимая часть не равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(MathCore.Complex@,System.UInt16)">
            <summary>Оператор равенства комплексного числа целому числу (2 байта без знака)</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число (2 байта без знака)</param>
            <returns>Истина, если реальная часть <paramref name="X"/> равна <paramref name="Y"/>, а мнимая часть равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(MathCore.Complex@,System.UInt16)">
            <summary>Оператор неравенства комплексного числа целому числу (2 байта без знака)</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число (2 байта без знака)</param>
            <returns>Истина, если реальная часть <paramref name="X"/> не равна <paramref name="Y"/>, либо мнимая часть не равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(MathCore.Complex@,System.Int32)">
            <summary>Оператор равенства комплексного числа целому числу</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число</param>
            <returns>Истина, если реальная часть <paramref name="X"/> равна <paramref name="Y"/>, а мнимая часть равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(MathCore.Complex@,System.Int32)">
            <summary>Оператор неравенства комплексного числа целому числу</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число</param>
            <returns>Истина, если реальная часть <paramref name="X"/> не равна <paramref name="Y"/>, либо мнимая часть не равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(MathCore.Complex@,System.UInt32)">
            <summary>Оператор равенства комплексного числа целому числу без знака</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число без знака</param>
            <returns>Истина, если реальная часть <paramref name="X"/> равна <paramref name="Y"/>, а мнимая часть равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(MathCore.Complex@,System.UInt32)">
            <summary>Оператор неравенства комплексного числа целому числу без знака</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число без знака</param>
            <returns>Истина, если реальная часть <paramref name="X"/> не равна <paramref name="Y"/>, либо мнимая часть не равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(MathCore.Complex@,System.Int64)">
            <summary>Оператор неравенства комплексного числа целому числу (8 байт со знаком)</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число (8 байт со знаком)</param>
            <returns>Истина, если реальная часть <paramref name="X"/> не равна <paramref name="Y"/>, либо мнимая часть не равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(MathCore.Complex@,System.Int64)">
            <summary>Оператор равенства комплексного числа целому числу (8 байт со знаком)</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число (8 байт со знаком)</param>
            <returns>Истина, если реальная часть <paramref name="X"/> равна <paramref name="Y"/>, а мнимая часть равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(MathCore.Complex@,System.UInt64)">
            <summary>Оператор неравенства комплексного числа целому числу (8 байт без знака)</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число (8 байт без знака)</param>
            <returns>Истина, если реальная часть <paramref name="X"/> не равна <paramref name="Y"/>, либо мнимая часть не равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(MathCore.Complex@,System.UInt64)">
            <summary>Оператор равенства комплексного числа целому числу (8 байт без знака)</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число (8 байт без знака)</param>
            <returns>Истина, если реальная часть <paramref name="X"/> равна <paramref name="Y"/>, а мнимая часть равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Explicit(MathCore.Complex@)~System.Double">
            <summary>Оператор неявного приведения к дробному типу чисел с двойной точностью</summary>
            <param name="Z">Приводимое комплексное число</param>
            <returns>Модуль комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Implicit(System.Double@)~MathCore.Complex">
            <summary>Оператор неявного приведения дробного числа двойной точности к комплексному виду</summary>
            <param name="X">Вещественное число двойной точности</param>
            <returns>Комплексное число</returns>
        </member>
        <member name="M:MathCore.Complex.op_Implicit(System.Int32@)~MathCore.Complex">
            <summary>Оператор неявного приведения целого числа к комплексному виду</summary>
            <param name="X">Целое число</param>
            <returns>Комплексное число</returns>
        </member>
        <member name="M:MathCore.Complex.op_Implicit(System.ValueTuple{System.Double,System.Double})~MathCore.Complex">
            <summary>Оператор неявного приведения кортежа, состоящего из двух вещественных чисел в комплексное число</summary>
            <param name="Z">Кортеж из двух вещественных чисел - действительной и мнимой части</param>
            <returns>Комплексное число</returns>
        </member>
        <member name="M:MathCore.Complex.op_Implicit(MathCore.Complex)~System.ValueTuple{System.Double,System.Double}">
            <summary>Оператор неявного приведения комплексного числа в кортеж, состоящий из двух вещественных чисел</summary>
            <param name="Z">Комплексное число</param>
            <returns>Кортеж из двух вещественных чисел - действительной и мнимой части</returns>
        </member>
        <member name="T:MathCore.Complex.Trigonometry">
            <summary>Тригонометрические функции комплексного переменного</summary>
        </member>
        <member name="M:MathCore.Complex.Trigonometry.Sin(MathCore.Complex@)">
            <summary>Синус</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Синус комплексного аргумента</returns>
        </member>
        <member name="M:MathCore.Complex.Trigonometry.Cos(MathCore.Complex@)">
            <summary>Косинус</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Косинус комплексного аргумента</returns>
        </member>
        <member name="M:MathCore.Complex.Trigonometry.Tg(MathCore.Complex@)">
            <summary>Тангенс</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Тангенс комплексного аргумента</returns>
        </member>
        <member name="M:MathCore.Complex.Trigonometry.Ctg(MathCore.Complex@)">
            <summary>Котангенс</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Котангенс комплексного аргумента</returns>
        </member>
        <member name="M:MathCore.Complex.Trigonometry.Asin(MathCore.Complex@)">
            <summary>Арксинус комплексного переменного</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Арксинус комплексного аргумента</returns>
        </member>
        <member name="M:MathCore.Complex.Trigonometry.Acos(MathCore.Complex@)">
            <summary>Арккосинус комплексного переменного</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Арккосинус комплексного аргумента</returns>
        </member>
        <member name="M:MathCore.Complex.Trigonometry.Atan(MathCore.Complex@)">
            <summary>Арктангенс комплексного переменного</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Арктангенс комплексного аргумента</returns>
        </member>
        <member name="M:MathCore.Complex.Trigonometry.Arctg(MathCore.Complex@)">
            <summary>Арккатангенс комплексного переменного</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Арккатангенс комплексного аргумента</returns>
        </member>
        <member name="T:MathCore.Complex.Trigonometry.Hyperbolic">
            <summary>Гиперболические функции</summary>
        </member>
        <member name="M:MathCore.Complex.Trigonometry.Hyperbolic.Sh(MathCore.Complex@)">
            <summary>Гиперболический синус</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Гиперболический синус комплексного аргумента</returns>
        </member>
        <member name="M:MathCore.Complex.Trigonometry.Hyperbolic.Ch(MathCore.Complex@)">
            <summary>Гиперболический косинус</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Гиперболический косинус комплексного аргумента</returns>
        </member>
        <member name="M:MathCore.Complex.Trigonometry.Hyperbolic.Tgh(MathCore.Complex@)">
            <summary>Гиперболический тангенс</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Гиперболический тангенс комплексного аргумента</returns>
        </member>
        <member name="M:MathCore.Complex.Trigonometry.Hyperbolic.Ctgh(MathCore.Complex@)">
            <summary>Гиперболический котангенс</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Гиперболический котангенс комплексного аргумента</returns>
        </member>
        <member name="T:MathCore.ComplexExtensions">
            <summary>Методы-расширения комплексных чисел</summary>
        </member>
        <member name="M:MathCore.ComplexExtensions.ToRe(MathCore.Complex[])">
            <summary>Преобразование массива комплексных чисел в массив действительных</summary>
            <param name="ZZ">Массив комплексных чисел</param>
            <returns>Массив действительных чисел</returns>
        </member>
        <member name="M:MathCore.ComplexExtensions.ToIm(MathCore.Complex[])">
            <summary>Массив комплексных чисел в массив значений мнимых чисел</summary>
            <param name="ZZ">Массив комплексных чисел</param>
            <returns>Массив значений комплексных мнимых чисел</returns>
        </member>
        <member name="M:MathCore.ComplexExtensions.ToAbs(MathCore.Complex[])">
            <summary>Массив комплексных чисел в массив модулей</summary>
            <param name="ZZ">Массив комплексных чисел</param>
            <returns>Массив модулей комплексных чисел</returns>
        </member>
        <member name="M:MathCore.ComplexExtensions.ToArg(MathCore.Complex[])">
            <summary>Массив комплексных чисел в массив аргументов</summary>
            <param name="ZZ">Массив комплексных чисел</param>
            <returns>Массив аргументов комплексных чисел</returns>
        </member>
        <member name="M:MathCore.ComplexExtensions.ToArgDeg(MathCore.Complex[])">
            <summary>Преобразование массива комплексных чисел в массив значений аргумента каждого из них в градусах</summary>
            <param name="ZZ">Массив комплексных чисел</param>
            <returns>Массив аргументов в градусах</returns>
        </member>
        <member name="M:MathCore.ComplexExtensions.ToReImArray(MathCore.Complex[])">
            <summary>
            Массив комплексных чисел в двумерный массив действительных и мнимых частей, где
            Re = V[i,0] Im = V[i,1]
            </summary>
            <param name="ZZ">Массив комплексных чисел</param>
            <returns>Двумерный массив вещественных и мнимых частей</returns>
        </member>
        <member name="M:MathCore.ComplexExtensions.ToReImTuple(MathCore.Complex[])">
            <summary>Массив комплексных чисел в массив кортежей действительных и мнимых частей</summary>
            <param name="ZZ">Массив комплексных чисел</param>
            <returns>Массив кортежей вещественных и мнимых частей</returns>
        </member>
        <member name="M:MathCore.ComplexExtensions.ToAbsArgArray(MathCore.Complex[])">
            <summary>
            Массив комплексных чисел в двумерный массив модулей и аргументов частей, где
            Abs = V[i,0] Arg = V[i,1]
            </summary>
            <param name="ZZ">Массив комплексных чисел</param>
            <returns>Двумерный массив модулей и аргументов</returns>
        </member>
        <member name="M:MathCore.ComplexExtensions.ToAbsArgTuple(MathCore.Complex[])">
            <summary>Массив комплексных чисел в массив кортежей модулей и аргументов</summary>
            <param name="ZZ">Массив комплексных чисел</param>
            <returns>Массив кортежей модулей и аргументов</returns>
        </member>
        <member name="M:MathCore.ComplexExtensions.ToComplex(System.Double[])">
            <summary>Преобразовать массив действительных в массив комплексных чисел</summary>
            <param name="Re">Массив действительных чисел</param>
            <returns>Массив комплексных чисел</returns>
        </member>
        <member name="M:MathCore.ComplexExtensions.ToComplex(System.Double[0:,0:])">
            <summary>Преобразовать двумерный массив действительных в массив комплексных чисел</summary>
            <param name="Values">Двумерный массив действительных чисел, где Re = V[i,0], Im = V[i,1]</param>
            <returns>Массив комплексных чисел</returns>
        </member>
        <member name="M:MathCore.ComplexExtensions.GetAbs(MathCore.Complex[])">
            <summary>Преобразование в массив модулей</summary>
            <param name="ZZ">Массив комплексных чисел</param>
            <returns>Массив модулей комплексных чисел</returns>
        </member>
        <member name="T:MathCore.ComplexConverter">
            <summary>Конвертер комплексных чисел</summary>
        </member>
        <member name="M:MathCore.ComplexConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ComplexConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ComplexConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ComplexConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Consts">
            <summary>Константы</summary>
        </member>
        <member name="F:MathCore.Consts.Percent">
            <summary>% = 0.01</summary>
        </member>
        <member name="F:MathCore.Consts.e">
            <summary>e = 2.7182818284590452353602874713527</summary>
        </member>
        <member name="F:MathCore.Consts.pi00625">
            <summary>π/16 (90°/8 = 11.25°)</summary>
        </member>
        <member name="F:MathCore.Consts.pi0125">
            <summary>π/8 (90/4° = 22.5°)</summary>
        </member>
        <member name="F:MathCore.Consts.pi025">
            <summary>π/4 (90°/2 = 45°)</summary>
        </member>
        <member name="F:MathCore.Consts.pi05">
            <summary>π/2 (90°)</summary>
        </member>
        <member name="F:MathCore.Consts.pi05neg">
            <summary>-π/2 (-90°)</summary>
        </member>
        <member name="F:MathCore.Consts.pi">
            <summary>π = 3.1415926535897932384626433832795028841971693993751</summary>
        </member>
        <member name="F:MathCore.Consts.pi_neg">
            <summary>-π = -3.1415926535897932384626433832795028841971693993751</summary>
        </member>
        <member name="F:MathCore.Consts.pi2">
            <summary>2·π (360°)</summary>
        </member>
        <member name="F:MathCore.Consts.pi2neg">
            <summary>-2·π (-360°)</summary>
        </member>
        <member name="F:MathCore.Consts.pi3_2">
            <summary>3·π/2</summary>
        </member>
        <member name="F:MathCore.Consts.LnPi">
            <summary>Ln_e(pi)</summary>
        </member>
        <member name="F:MathCore.Consts.Ln2Pi">
            <summary>Ln_e(2pi)</summary>
        </member>
        <member name="F:MathCore.Consts.Ln2Sqrt_e_div_pi">
            <summary>ln(2√(e/π))</summary>
        </member>
        <member name="F:MathCore.Consts.ToRad">
            <summary>π/180</summary>
        </member>
        <member name="F:MathCore.Consts.ToDeg">
            <summary>180/π</summary>
        </member>
        <member name="F:MathCore.Consts.pi_name">
            <summary>'π'</summary>
        </member>
        <member name="F:MathCore.Consts.deg_name">
            <summary>'°'</summary>
        </member>
        <member name="F:MathCore.Consts.sqrt_e">
            <summary>√e</summary>
        </member>
        <member name="F:MathCore.Consts.sqrt_pi">
            <summary>√π</summary>
        </member>
        <member name="F:MathCore.Consts.sqrt_pi2">
            <summary>√(2·π)</summary>
        </member>
        <member name="F:MathCore.Consts.sqrt_pi05">
            <summary>√(π/2)</summary>
        </member>
        <member name="F:MathCore.Consts.sqrt_2">
            <summary>√2 = 1.4142135623730950488016887242096980785696718753769</summary>
        </member>
        <member name="F:MathCore.Consts.sqrt_2_inv">
            <summary>1 / √2 = 0.707...</summary>
        </member>
        <member name="F:MathCore.Consts.sqrt_3">
            <summary>√3 = 1.7320508075688772935274463415058723669428052538104</summary>
        </member>
        <member name="F:MathCore.Consts.sqrt_5">
            <summary>√5 = 2.236067...</summary>
        </member>
        <member name="F:MathCore.Consts.sqrt_5_inv">
            <summary>1 / √5 = 0.4472135954999579...</summary>
        </member>
        <member name="F:MathCore.Consts.GoldenRatio">
            <summary>Золотое сечение = (√5 + 1)/2</summary>
        </member>
        <member name="F:MathCore.Consts.GoldenRatio_Inv">
            <summary>Величина, обратная золотому сечению = (√5 - 1)/2</summary>
        </member>
        <member name="T:MathCore.Consts.Geometry">
            <summary>Геометрические константы</summary>
        </member>
        <member name="F:MathCore.Consts.Geometry.ToDeg">
            <summary>Константа преобразования радиан в градусы = 180/π</summary>
        </member>
        <member name="F:MathCore.Consts.Geometry.ToRad">
            <summary>Константа преобразования градусов в радианы = π/180</summary>
        </member>
        <member name="F:MathCore.Consts.Geometry.Pi">
            <summary>Системная константа π = 3.1415926535897932384626433832</summary>
        </member>
        <member name="M:MathCore.Consts.Geometry.ConvertToDeg(System.Double)">
            <summary>Преобразовать значение из радиан в градусы</summary>
            <param name="RadValue">Значение в радианах</param>
            <returns>Значение в градусах</returns>
        </member>
        <member name="M:MathCore.Consts.Geometry.ConvertToRad(System.Double)">
            <summary>Преобразовать значение из градусов в радианы</summary>
            <param name="DegValue">Значение в градусах</param>
            <returns>Значение в радианах</returns>
        </member>
        <member name="F:MathCore.Consts.SpeedOfLight">
            <summary>Скорость света 300`000`000 м/с = 3e8 м/с</summary>
        </member>
        <member name="F:MathCore.Consts.SpeedOfLightInVacuum">
            <summary>Скорость света в вакууме 299`792`458 м/с</summary>
        </member>
        <member name="F:MathCore.Consts.GravitationConstant">
            <summary>Гравитационная постоянная 6.67384(80)×10^−11 m^3·кг^−1·с^−2</summary>
        </member>
        <member name="F:MathCore.Consts.PlanckConstant">
            <summary>Постоянная Планка 6.626 069 57(29) ×10^−34 Жд·с</summary>
        </member>
        <member name="F:MathCore.Consts.PlanckConstant_Reduced">
            <summary>Приведённая постоянная Планка 1.054 571 628(53) ×10^−34 Жд·с</summary>
        </member>
        <member name="F:MathCore.Consts.Planck_Temperature">
            <summary>Температура Планка √(h_bar * c^5/G)/k K</summary>
        </member>
        <member name="F:MathCore.Consts.Planck_Length">
            <summary>Длина Планка h_bar/(m_p*c) м</summary>
        </member>
        <member name="F:MathCore.Consts.Planck_Time">
            <summary>Время Планка lp/c с</summary>
        </member>
        <member name="T:MathCore.Consts.Electrodynamic">
            <summary>Электродинамические константы</summary>
        </member>
        <member name="F:MathCore.Consts.Electrodynamic.Epsilon0">
            <summary>Электрическая постоянная 1/(Mu0 · c^2) = 8,854187817620… ×10^−12 Ф·м^−1</summary>
        </member>
        <member name="F:MathCore.Consts.Electrodynamic.Mu0">
            <summary>Магнитная постоянная 4·π ×10^-7 = 1.2566370614E-6 Гн/м</summary>
        </member>
        <member name="F:MathCore.Consts.Electrodynamic.Impedance">
            <summary>Упрощённое сопротивление среды (вакуума) = √(Mu0/Epsilon0) = 377 Ом</summary>
        </member>
        <member name="F:MathCore.Consts.Electrodynamic.Impedance0">
            <summary>Сопротивление среды (вакуума) = √(Mu0/Epsilon0) = 376.730313461771 Ом</summary>
        </member>
        <member name="M:MathCore.Consts.Electrodynamic.ToWaveLength(System.Double)">
            <summary>Преобразовать значение частоты в длину волны</summary>
            <param name="Frequency">Значение частоты в Гц</param>
            <returns>Длина волны в метрах</returns>
        </member>
        <member name="M:MathCore.Consts.Electrodynamic.ToWaveLength(System.Double,System.Double)">
            <summary>Преобразовать значение частоты в длину волны с учётом диэлектрической проницаемости среды</summary>
            <param name="Frequency">Значение частоты в Гц</param>
            <param name="Epsilon">Значение относительной диэлектрической проницаемости среды</param>
            <returns>Значение длины волны в среде в метрах</returns>
        </member>
        <member name="M:MathCore.Consts.Electrodynamic.ToWaveLength(System.Double,System.Double,System.Double)">
            <summary>Преобразовать значение частоты в длину волны с учётом диэлектрической и магнитной проницаемости среды</summary>
            <param name="Frequency">Значение частоты в Гц</param>
            <param name="Epsilon">Значение относительной диэлектрической проницаемости среды</param>
            <param name="Mu">Значение магнитной проницаемости среды</param>
            <returns>Значение длины волны в среде в метрах</returns>
        </member>
        <member name="M:MathCore.Consts.Electrodynamic.ToFrequency(System.Double)">
            <summary>Преобразование длины волны в метрах в частоту в Гц</summary>
            <param name="WaveLength">Значение длины волны в метрах</param>
            <returns>Значение частоты в Гц</returns>
        </member>
        <member name="M:MathCore.Consts.Electrodynamic.ToFrequency(System.Double,System.Double)">
            <summary>Преобразование длины волны в среде в метрах в частоту в Гц</summary>
            <param name="WaveLength">Значение длины волны в среде в метрах</param>
            <param name="Epsilon">Значение относительной диэлектрической проницаемости среды</param>
            <returns>Значение частоты в Гц</returns>
        </member>
        <member name="M:MathCore.Consts.Electrodynamic.ToFrequency(System.Double,System.Double,System.Double)">
            <summary>Преобразование длины волны в среде в метрах в частоту в Гц</summary>
            <param name="WaveLength">Значение длины волны в среде в метрах</param>
            <param name="Epsilon">Значение относительной диэлектрической проницаемости среды</param>
            <param name="Mu">Значение магнитной проницаемости среды</param>
            <returns>Значение частоты в Гц</returns>
        </member>
        <member name="F:MathCore.Consts.BigPrime_int">
            <summary>0x3ffeffff = 1073676287</summary>
        </member>
        <member name="F:MathCore.Consts.BigPrime_long">
            <summary>0x3fffffefffffff = 18014398241046527</summary>
        </member>
        <member name="T:MathCore.Consts.DataLength">
            <summary>Размеры данных</summary>
        </member>
        <member name="T:MathCore.Consts.DataLength.Bytes">
            <summary>Размеры данных в байтах</summary>
        </member>
        <member name="F:MathCore.Consts.DataLength.Bytes.B">
            <summary>1 Байт</summary>
        </member>
        <member name="F:MathCore.Consts.DataLength.Bytes.kB">
            <summary>1 килобайт в байтах</summary>
        </member>
        <member name="F:MathCore.Consts.DataLength.Bytes.MB">
            <summary>1 мегабайт в байтах</summary>
        </member>
        <member name="F:MathCore.Consts.DataLength.Bytes.GB">
            <summary>1 гигабайт в байтах</summary>
        </member>
        <member name="F:MathCore.Consts.DataLength.Bytes.TB">
            <summary>1 терабайт в байтах</summary>
        </member>
        <member name="M:MathCore.Consts.DataLength.Bytes.GetDataNames">
            <summary>Получить имена значений количества байт с приставками "B", "kB", "MB", "GB", "TB"</summary>
            <returns>"B", "kB", "MB", "GB", "TB"</returns>
        </member>
        <member name="M:MathCore.Consts.DataLength.Bytes.GetDataNamesRu">
            <summary>Получить русскоязычные имена значений количества байт с приставками "Б", "кБ", "МБ", "ГБ", "ТБ"</summary>
            <returns>"Б", "кБ", "МБ", "ГБ", "ТБ"</returns>
        </member>
        <member name="F:MathCore.Consts.ElementaryCharge">
            <summary>Элементарный заряд e = 1,602 176 565(35)·10^−19 Кл</summary>
        </member>
        <member name="F:MathCore.Consts.BoltzmannConstant">
            <summary>Постоянная Больцмана k = 1,380 6488(13)·10^−23 Дж/К</summary>
        </member>
        <member name="F:MathCore.Consts.AvogadroConstant">
            <summary>Число Авогадро Na = 6,022 141 29(27)·10^23 1/моль</summary>
        </member>
        <member name="F:MathCore.Consts.FaradayConstant">
            <summary>Постоянная Фарадея F = e * Na = 96485,33(83) Кл/моль</summary>
        </member>
        <member name="M:MathCore.DataGenericSources.DataHost.Dispose">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Data.DataLength">
            <summary>Структура для отображения размера данных в Байтах, кБ, МБ, ГБ, ТБ ...</summary>
        </member>
        <member name="F:MathCore.Data.DataLength.__Threshold">
            <summary>Порог перехода между множителями Log(1024 * 0.7, __Base = 1024) - 70%</summary>
        </member>
        <member name="F:MathCore.Data.DataLength.__Units">
            <summary>Множители единиц измерения</summary>
        </member>
        <member name="P:MathCore.Data.DataLength.Units">
            <summary>Множители единиц измерения</summary>
        </member>
        <member name="M:MathCore.Data.DataLength.Value(System.UInt64,System.Double,System.String@,System.Int32@)">
            <summary>Преобразовать значение в представление размера с множителем</summary>
            <param name="value">Преобразуемое значение</param>
            <param name="Base">Основание</param>
            <param name="unit">Имя множителя единицы измерения</param>
            <param name="index">Индекс множителя</param>
            <returns>Значение X в представлении value = Base^index</returns>
        </member>
        <member name="M:MathCore.Data.DataLength.Value(System.Double,System.Double,System.String@,System.Int32@)">
            <summary>Преобразовать значение в представление размера с множителем</summary>
            <param name="value">Преобразуемое значение</param>
            <param name="Base">Основание</param>
            <param name="unit">Имя множителя единицы измерения</param>
            <param name="index">Индекс множителя</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Если значение <paramref name="value"/> меньше 0</exception>
            <returns>Значение X в представлении value = Base^index</returns>
        </member>
        <member name="F:MathCore.Data.DataLength._Length">
            <summary>Исходное значение размера</summary>
        </member>
        <member name="F:MathCore.Data.DataLength._Base">
            <summary>Основание системы счисления для выделения множителя (1024 б, либо 1000 для физических значений)</summary>
        </member>
        <member name="F:MathCore.Data.DataLength._FormattedLength">
            <summary>Количественный размер данных с множителем</summary>
        </member>
        <member name="F:MathCore.Data.DataLength._Unit">
            <summary>Множитель размера данных</summary>
        </member>
        <member name="P:MathCore.Data.DataLength.Length">
            <summary>Исходное значение размера</summary>
        </member>
        <member name="P:MathCore.Data.DataLength.Base">
            <summary>Основание системы счисления для выделения множителя (1024 б, либо 1000 для физических значений)</summary>
        </member>
        <member name="P:MathCore.Data.DataLength.FormattedLength">
            <summary>Количественный размер данных с множителем</summary>
        </member>
        <member name="P:MathCore.Data.DataLength.Unit">
            <summary>Множитель размера данных</summary>
        </member>
        <member name="M:MathCore.Data.DataLength.#ctor(System.Double,System.Double)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Data.DataLength"/></summary>
            <param name="Length">Количественный размер данных</param>
            <param name="Base">Основание системы счисления (на пример 1024 = 1кб, либо 1000 для физических значений)</param>
        </member>
        <member name="M:MathCore.Data.DataLength.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Data.DataLength.ToString(System.String)">
            <summary>Представление значения в строковом виде с форматированием числовых данных</summary>
            <param name="format">Строка формата числовых значений</param>
            <returns>Строковое представление с форматированием</returns>
        </member>
        <member name="M:MathCore.Data.DataLength.ToString(System.String,System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Data.DataLength.Equals(MathCore.Data.DataLength)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Data.DataLength.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Data.DataLength.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Data.DataLength.op_Equality(MathCore.Data.DataLength,MathCore.Data.DataLength)">
            <summary>Оператор определения равенства между двумя экземплярами <see cref="T:MathCore.Data.DataLength"/></summary>
            <returns>Истина, если все поля экземпляров совпадают</returns>
        </member>
        <member name="M:MathCore.Data.DataLength.op_Inequality(MathCore.Data.DataLength,MathCore.Data.DataLength)">
            <summary>Оператор определения неравенства между двумя экземплярами <see cref="T:MathCore.Data.DataLength"/></summary>
            <returns>Истина, если хотя бы одно поле экземпляров отличается</returns>
        </member>
        <member name="T:MathCore.Data.PropertyLink`2">
            <summary>Связь между свойствами</summary>
            <typeparam name="TSource">Тип объекта-источника данных</typeparam>
            <typeparam name="TDestination">Тип объекта-приёмника данных</typeparam>
        </member>
        <member name="F:MathCore.Data.PropertyLink`2._Source">
            <summary>Источник данных</summary>
        </member>
        <member name="F:MathCore.Data.PropertyLink`2._Destination">
            <summary>Приёмник данных</summary>
        </member>
        <member name="F:MathCore.Data.PropertyLink`2._SourcePropertyDescriptor">
            <summary>Дескриптор свойства источника данных</summary>
        </member>
        <member name="F:MathCore.Data.PropertyLink`2._DestinationPropertyDescriptor">
            <summary>Дескриптор свойства приёмника данных</summary>
        </member>
        <member name="P:MathCore.Data.PropertyLink`2.Source">
            <summary>Источник данных</summary>
        </member>
        <member name="P:MathCore.Data.PropertyLink`2.Destination">
            <summary>Приёмник данных</summary>
        </member>
        <member name="P:MathCore.Data.PropertyLink`2.SourceProperty">
            <summary>Дескриптор свойства источника данных</summary>
        </member>
        <member name="P:MathCore.Data.PropertyLink`2.DestinationProperty">
            <summary>Дескриптор свойства приёмника данных</summary>
        </member>
        <member name="P:MathCore.Data.PropertyLink`2.SourceType">
            <summary>Источник данных</summary>
        </member>
        <member name="P:MathCore.Data.PropertyLink`2.DestinationType">
            <summary>Приёмник данных</summary>
        </member>
        <member name="P:MathCore.Data.PropertyLink`2.SourcePropertyType">
            <summary>Тип свойства источника данных</summary>
        </member>
        <member name="P:MathCore.Data.PropertyLink`2.DestinationPropertyType">
            <summary>Тип свойства приёмника данных</summary>
        </member>
        <member name="P:MathCore.Data.PropertyLink`2.Enable">
            <summary>Активатор связи</summary>
        </member>
        <member name="M:MathCore.Data.PropertyLink`2.#ctor(`0,System.String,`1,System.String,System.Boolean)">
            <summary>Новая связь между свойством источника и приёмника данных</summary>
            <param name="Source">Источник данных</param>
            <param name="SourcePropertyName">Имя свойства источника данных</param>
            <param name="Destination">Приёмник данных</param>
            <param name="DestinationPropertyName">Имя свойства приёмника данных</param>
            <param name="Enable">Признак активности связи (по умолчанию = true)</param>
        </member>
        <member name="M:MathCore.Data.PropertyLink`2.SourcePropertyChanged(System.Object,System.EventArgs)">
            <summary>Обработчик события изменения свойства источника данных</summary>
            <param name="sender">Источник события</param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="T:MathCore.DifferentialEquations.Numerical.ArgumentFunction">
            <summary>Функция определения аргумента</summary>
            <param name="t">Параметр</param>
            <returns>Вектор аргумента уравнения</returns>
        </member>
        <member name="T:MathCore.DifferentialEquations.Numerical.DifferentialEquationsSystem">
            <summary> Система дифференциальных уравнений</summary>
            <param name="X">Аргумент</param>
            <param name="Y">Значения функции</param>
            <returns>Значения производных</returns>
        </member>
        <member name="M:MathCore.DifferentialEquations.Numerical.EquationSystemMethods.SystemResultItem`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.DifferentialEquations.Numerical.EquationSystemMethods.SystemResultItem`1.Equals(MathCore.DifferentialEquations.Numerical.EquationSystemMethods.SystemResultItem{`0})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.DifferentialEquations.Numerical.EquationSystemMethods.SystemResultItem`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.DifferentialEquations.Numerical.EquationSystemMethods.SystemResultItem`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:MathCore.DifferentialEquations.Numerical.Euler">
            <summary>Метод Рунге-Кутты</summary>
        </member>
        <member name="P:MathCore.DifferentialEquations.Numerical.Euler.N">
            <summary>Размерность системы</summary>
        </member>
        <member name="P:MathCore.DifferentialEquations.Numerical.Euler.Y">
            <summary>Искомые решения</summary>
        </member>
        <member name="P:MathCore.DifferentialEquations.Numerical.Euler.t">
            <summary>Текущее время</summary>
        </member>
        <member name="M:MathCore.DifferentialEquations.Numerical.Euler.#ctor(System.Int32,MathCore.DifferentialEquations.Numerical.DifferentialEquationsSystem,MathCore.DifferentialEquations.Numerical.ArgumentFunction)">
            <summary>Метод Рунге-Кутты</summary>
            <param name="N">Размерность</param>
            <param name="System">Решаемая система</param>
            <param name="X">Производящая функция аргумента</param>
        </member>
        <member name="M:MathCore.DifferentialEquations.Numerical.Euler.Initialize(System.Double,System.Double[])">
            <summary>Начальные условия</summary>
            <param name="t0">Начальное время</param>
            <param name="Y0">Начальные условия</param>
        </member>
        <member name="M:MathCore.DifferentialEquations.Numerical.Euler.NextStep(System.Double)">
            <summary>Расчёт решения</summary>
            <param name="dt">Шаг</param>
        </member>
        <member name="T:MathCore.DifferentialEquations.Numerical.RungeKutta">
            <summary>Метод Рунге-Кутты</summary>
        </member>
        <member name="P:MathCore.DifferentialEquations.Numerical.RungeKutta.N">
            <summary>Размерность системы</summary>
        </member>
        <member name="P:MathCore.DifferentialEquations.Numerical.RungeKutta.Y">
            <summary>Искомые решения</summary>
        </member>
        <member name="P:MathCore.DifferentialEquations.Numerical.RungeKutta.t">
            <summary>Текущее время</summary>
        </member>
        <member name="M:MathCore.DifferentialEquations.Numerical.RungeKutta.#ctor(System.Int32,MathCore.DifferentialEquations.Numerical.DifferentialEquationsSystem,MathCore.DifferentialEquations.Numerical.ArgumentFunction)">
            <summary>Метод Рунге-Кутты</summary>
            <param name="N">Размерность</param>
            <param name="System">Решаемая система</param>
            <param name="X">Производящая функция аргумента</param>
        </member>
        <member name="M:MathCore.DifferentialEquations.Numerical.RungeKutta.Initialize(System.Double,System.Double[])">
            <summary>Начальные условия</summary>
            <param name="t0">Начальное время</param>
            <param name="Y0">Начальные условия</param>
        </member>
        <member name="M:MathCore.DifferentialEquations.Numerical.RungeKutta.NextStep(System.Double)">
            <summary>Расчёт решения</summary>
            <param name="dt">Шаг</param>
        </member>
        <member name="T:MathCore.DisposableGroup`1">
            <summary>Группа объектов, поддерживающих интерфейс <see cref="T:System.IDisposable">освобождения ресурсов</see></summary>
            <typeparam name="T">Тип объектов, поддерживающих интерфейс <see cref="T:System.IDisposable"/></typeparam>
        </member>
        <member name="F:MathCore.DisposableGroup`1._Items">
            <summary>Массив содержащихся объектов интерфейса <see cref="T:System.IDisposable"/></summary>
        </member>
        <member name="P:MathCore.DisposableGroup`1.Count">
            <summary>Число элементов группы</summary>
        </member>
        <member name="P:MathCore.DisposableGroup`1.Items">
            <summary>Массив элементов группы</summary>
        </member>
        <member name="P:MathCore.DisposableGroup`1.MathCore#IIndexableRead{System#Int32,T}#Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:MathCore.DisposableGroup`1.Item(System.Int32)">
            <summary>Элемент группы</summary>
            <param name="i">Номер элемента группы</param>
            <returns>Элемент группы с номером <paramref name="i"/></returns>
        </member>
        <member name="M:MathCore.DisposableGroup`1.#ctor(`0[])">
            <summary>Группа <typeparamref name="T"/> интерфейса <see cref="T:System.IDisposable"/></summary>
            <param name="item"><typeparamref name="T"/> интерфейса <see cref="T:System.IDisposable"/></param>
        </member>
        <member name="M:MathCore.DisposableGroup`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>Группа <typeparamref name="T"/> интерфейса <see cref="T:System.IDisposable"/></summary>
            <param name="items">Перечисление <typeparamref name="T"/> интерфейса <see cref="T:System.IDisposable"/></param>
        </member>
        <member name="M:MathCore.DisposableGroup`1.Dispose">
            <inheritdoc />
        </member>
        <member name="F:MathCore.DisposableGroup`1._Disposed">
            <summary>Объект уничтожен</summary>
        </member>
        <member name="M:MathCore.DisposableGroup`1.Dispose(System.Boolean)">
            <summary>Освободить ресурсы группы</summary>
            <param name="disposing">Признак того, что требуется освобождение управляемых ресурсов</param>
        </member>
        <member name="M:MathCore.DisposableGroup`1.GetEnumerator">
            <summary>Получить перечислитель элементов группы</summary>
            <returns>Перечислитель элементов группы</returns>
        </member>
        <member name="M:MathCore.DisposableGroup`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Возвращает перечислитель, который осуществляет перебор элементов коллекции.</summary>
            <returns>
            Объект <see cref="T:System.Collections.IEnumerator"/>, который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:MathCore.Evaluations.AdditionEvaluation`1">
            <summary>Вычисление суммы двух вычислений</summary>
            <typeparam name="T">Тип значения вычисления</typeparam>
        </member>
        <member name="M:MathCore.Evaluations.AdditionEvaluation`1.#ctor">
            <summary>Инициализация нового вычисления суммы двух вычислений</summary>
        </member>
        <member name="M:MathCore.Evaluations.AdditionEvaluation`1.#ctor(MathCore.Evaluations.Evaluation{`0},MathCore.Evaluations.Evaluation{`0})">
            <summary>Инициализация нового вычисления суммы двух вычислений</summary>
            <param name="a">Вычисление первого слагаемого</param>
            <param name="b">Вычисление второго слагаемого</param>
        </member>
        <member name="T:MathCore.Evaluations.BinaryFunctionOperationEvaluation`1">
            <summary>Вычисление бинарной операции между двумя вычислениями</summary>
            <typeparam name="T">Тип значения вычисления</typeparam>
        </member>
        <member name="P:MathCore.Evaluations.BinaryFunctionOperationEvaluation`1.A">
            <summary>Первый операнд вычисления</summary>
        </member>
        <member name="P:MathCore.Evaluations.BinaryFunctionOperationEvaluation`1.B">
            <summary>Второй операнд вычисления</summary>
        </member>
        <member name="P:MathCore.Evaluations.BinaryFunctionOperationEvaluation`1.Operation">
            <summary>Метод вычисления значения вычисления</summary>
        </member>
        <member name="M:MathCore.Evaluations.BinaryFunctionOperationEvaluation`1.#ctor">
            <summary>Инициализация нового бинарного вычисления</summary>
        </member>
        <member name="M:MathCore.Evaluations.BinaryFunctionOperationEvaluation`1.#ctor(System.Func{`0,`0,`0})">
            <summary>Инициализация нового бинарного вычисления</summary>
            <param name="Operation">Метод вычисления результата вычисления на основе результатов вычисления значений операндов</param>
        </member>
        <member name="M:MathCore.Evaluations.BinaryFunctionOperationEvaluation`1.#ctor(System.Func{`0,`0,`0},MathCore.Evaluations.Evaluation{`0},MathCore.Evaluations.Evaluation{`0})">
            <summary>Инициализация нового бинарного вычисления</summary>
            <param name="Operation">Метод вычисления результата вычисления на основе результатов вычисления значений операндов</param>
            <param name="A">Первый операнд вычисления</param>
            <param name="B">Второй операнд вычисления</param>
        </member>
        <member name="M:MathCore.Evaluations.BinaryFunctionOperationEvaluation`1.GetValue">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Evaluations.BinaryFunctionOperationEvaluation`1.GetExpression">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Evaluations.BinaryFunctionOperatorEvaluation`1">
            <summary>Вычисление функционального бинарного оператора между двумя вычислениями</summary>
            <typeparam name="T">Тип значения вычисления</typeparam>
        </member>
        <member name="M:MathCore.Evaluations.BinaryFunctionOperatorEvaluation`1.GetOperatorFunction(System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.BinaryExpression})">
            <summary>Метод получения функции, рассчитывающей значение оператора для двух известных значений вычислений</summary>
            <param name="OP">Функция, преобразующая два выражения в бинарный оператор, позволяющий рассчитать значение операции между двумя значениями операндов</param>
            <returns>Метод вычисления значения оператора на основе значений двух его операндов</returns>
        </member>
        <member name="F:MathCore.Evaluations.BinaryFunctionOperatorEvaluation`1._Operator">
            <summary>Функция объединения двух выражений в бинарный оператор расчёта значения</summary>
        </member>
        <member name="M:MathCore.Evaluations.BinaryFunctionOperatorEvaluation`1.#ctor(System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.BinaryExpression})">
            <summary>Инициализация нового функционального бинарного оператора вычисления</summary>
            <param name="Operator">Функция, определяющая как объединить два выражения операндов в бинарный оператор</param>
        </member>
        <member name="M:MathCore.Evaluations.BinaryFunctionOperatorEvaluation`1.#ctor(System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.BinaryExpression},MathCore.Evaluations.Evaluation{`0},MathCore.Evaluations.Evaluation{`0})">
            <summary>Инициализация нового функционального бинарного оператора на основе функции генерации бинарного оператора и двух вычислений операндов</summary>
            <param name="Operator">Функция, определяющая как объединить два выражения операндов в бинарный оператор</param>
            <param name="a">Вычисление первого операнда</param>
            <param name="b">Вычисление второго операнда</param>
        </member>
        <member name="M:MathCore.Evaluations.BinaryFunctionOperatorEvaluation`1.GetExpression">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Evaluations.ConvertEvaluation`2">
            <summary>Вычисление преобразования типов</summary>
            <typeparam name="TInput">Тип входного значения</typeparam>
            <typeparam name="TOutput">Тип выходного значения</typeparam>
        </member>
        <member name="P:MathCore.Evaluations.ConvertEvaluation`2.InputEvaluation">
            <summary>Вычисление входного значения</summary>
        </member>
        <member name="P:MathCore.Evaluations.ConvertEvaluation`2.Converter">
            <summary>Функция-преобразователь типов входного в выходное значение</summary>
        </member>
        <member name="M:MathCore.Evaluations.ConvertEvaluation`2.#ctor">
            <summary>Инициализация нового вычисления преобразования типов</summary>
        </member>
        <member name="M:MathCore.Evaluations.ConvertEvaluation`2.#ctor(System.Func{`0,`1})">
            <summary>Инициализация нового вычисления преобразования типов</summary>
            <param name="Converter">Метод преобразования входного значения в выходное</param>
        </member>
        <member name="M:MathCore.Evaluations.ConvertEvaluation`2.#ctor(MathCore.Evaluations.Evaluation{`0},System.Func{`0,`1})">
            <summary>Инициализация нового вычисления преобразования типов</summary>
            <param name="InputEvaluation">Вычисление входного значения</param>
            <param name="Converter">Метод преобразования входного значения в выходное</param>
        </member>
        <member name="M:MathCore.Evaluations.ConvertEvaluation`2.GetValue">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Evaluations.ConvertEvaluation`2.GetExpression">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Evaluations.DivideEvaluation`1">
            <summary>Вычисление деления двух вычислений</summary>
            <typeparam name="T">Тип значения вычисления</typeparam>
        </member>
        <member name="M:MathCore.Evaluations.DivideEvaluation`1.#ctor">
            <summary>Инициализация нового вычисления деления</summary>
        </member>
        <member name="M:MathCore.Evaluations.DivideEvaluation`1.#ctor(MathCore.Evaluations.Evaluation{`0},MathCore.Evaluations.Evaluation{`0})">
            <summary>Инициализация нового вычисления деления</summary>
            <param name="a">Вычисление делимого</param>
            <param name="b">Вычисление делителя</param>
        </member>
        <member name="T:MathCore.Evaluations.Evaluation">
            <summary>Вычисление</summary>
        </member>
        <member name="M:MathCore.Evaluations.Evaluation.GetExpression">
            <summary>Получить выражение вычисления</summary>
            <returns>Возвращает выражение, соответствующее данному вычислению</returns>
        </member>
        <member name="M:MathCore.Evaluations.Evaluation.op_Implicit(MathCore.Evaluations.Evaluation)~System.Linq.Expressions.Expression">
            <summary>Оператор неявного преобразования вычисления в выражение</summary>
            <param name="Evaluation">Преобразуемое вычисление</param>
        </member>
        <member name="T:MathCore.Evaluations.Evaluation`1">
            <summary>Вычисление с результатом типа <typeparamref name="T"/></summary>
            <typeparam name="T">Тип результата вычисления</typeparam>
        </member>
        <member name="M:MathCore.Evaluations.Evaluation`1.GetValue">
            <summary>Получить значение</summary>
            <returns></returns>
        </member>
        <member name="M:MathCore.Evaluations.Evaluation`1.GetExpression">
            <summary>Получить выражение вычисления</summary>
            <returns>Выражение, определяющие вычисление</returns>
        </member>
        <member name="M:MathCore.Evaluations.Evaluation`1.op_Implicit(MathCore.Evaluations.Evaluation{`0})~`0">
            <summary>Оператор неявного преобразования вычисления в выражение</summary>
            <param name="Evaluation">Преобразуемое вычисление</param>
        </member>
        <member name="M:MathCore.Evaluations.Evaluation`1.op_Addition(MathCore.Evaluations.Evaluation{`0},MathCore.Evaluations.Evaluation{`0})">
            <summary>Оператор сложения двух вычислений</summary>
            <param name="x">Первое слагаемое</param>
            <param name="y">Второе слагаемое</param>
            <returns>Вычисление суммы двух вычислений</returns>
        </member>
        <member name="M:MathCore.Evaluations.Evaluation`1.op_Subtraction(MathCore.Evaluations.Evaluation{`0},MathCore.Evaluations.Evaluation{`0})">
            <summary>Вычисление разности двух вычислений</summary>
            <param name="x">Уменьшаемое</param>
            <param name="y">Вычитаемое</param>
            <returns>Вычисление разности двух вычислений</returns>
        </member>
        <member name="M:MathCore.Evaluations.Evaluation`1.op_UnaryNegation(MathCore.Evaluations.Evaluation{`0})">
            <summary>Оператор получения отрицательного значения на основе вычисления</summary>
            <param name="x">Вычисление значения оператора</param>
            <returns>Оператор получения отрицательного значения</returns>
        </member>
        <member name="M:MathCore.Evaluations.Evaluation`1.op_Multiply(MathCore.Evaluations.Evaluation{`0},MathCore.Evaluations.Evaluation{`0})">
            <summary>Вычисление произведения двух вычислений</summary>
            <param name="x">Первый сомножитель</param>
            <param name="y">Второй сомножитель</param>
            <returns>Вычисление произведения двух вычислений</returns>
        </member>
        <member name="M:MathCore.Evaluations.Evaluation`1.op_Division(MathCore.Evaluations.Evaluation{`0},MathCore.Evaluations.Evaluation{`0})">
            <summary>Вычисление частного двух вычислений</summary>
            <param name="x">Делимое</param>
            <param name="y">Делитель</param>
            <returns>Вычисление частного двух вычислений</returns>
        </member>
        <member name="T:MathCore.Evaluations.FieldValueEvaluation`2">
            <summary>Вычисление значения поля объекта</summary>
            <typeparam name="TObject">Тип объекта, поле которого надо получить</typeparam>
            <typeparam name="TValue">Тип значения поля</typeparam>
        </member>
        <member name="M:MathCore.Evaluations.FieldValueEvaluation`2.#ctor(System.String)">
            <summary>Инициализация нового вычисления значения поля объекта</summary>
            <param name="PropertyName">Имя поля</param>
        </member>
        <member name="M:MathCore.Evaluations.FieldValueEvaluation`2.#ctor(MathCore.Evaluations.Evaluation{`0},System.String)">
            <summary>Инициализация нового вычисления поля объекта</summary>
            <param name="obj">Вычисление объекта, поле которого надо получить</param>
            <param name="FieldName">Имя поля объекта</param>
        </member>
        <member name="T:MathCore.Evaluations.FunctionEvaluation`1">
            <summary>Вычисление функции без переменных</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:MathCore.Evaluations.FunctionEvaluation`1.Function">
            <summary>Вычисляемая функция</summary>
        </member>
        <member name="M:MathCore.Evaluations.FunctionEvaluation`1.#ctor">
            <summary>Инициализация нового вычисления функции</summary>
        </member>
        <member name="M:MathCore.Evaluations.FunctionEvaluation`1.#ctor(System.Func{`0})">
            <summary>Инициализация нового вычисления функции</summary>
            <param name="Function">Вычисляемая функция</param>
        </member>
        <member name="M:MathCore.Evaluations.FunctionEvaluation`1.GetValue">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Evaluations.FunctionEvaluation`1.GetExpression">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Evaluations.FunctionEvaluation`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Evaluations.FunctionEvaluation`1.op_Implicit(System.Func{`0})~MathCore.Evaluations.FunctionEvaluation{`0}">
            <summary>Оператор неявного преобразования типа функции к типу вычисления функции</summary>
            <param name="Function">Оборачиваемая функция</param>
        </member>
        <member name="T:MathCore.Evaluations.MultiplyEvaluation`1">
            <summary>Вычисление произведения двух вычислений</summary>
            <typeparam name="T">Тип значения вычисления</typeparam>
        </member>
        <member name="M:MathCore.Evaluations.MultiplyEvaluation`1.#ctor">
            <summary>Инициализация нового вычисления произведения</summary>
        </member>
        <member name="M:MathCore.Evaluations.MultiplyEvaluation`1.#ctor(MathCore.Evaluations.Evaluation{`0},MathCore.Evaluations.Evaluation{`0})">
            <summary>Инициализация нового вычисления произведения</summary>
            <param name="a">Вычисление первого сомножителя</param>
            <param name="b">Вычисление второго сомножителя</param>
        </member>
        <member name="T:MathCore.Evaluations.NamedFunctionEvaluation`1">
            <summary>Именованное вычисление функции</summary>
            <typeparam name="T">Тип значения функции</typeparam>
        </member>
        <member name="P:MathCore.Evaluations.NamedFunctionEvaluation`1.Name">
            <summary>Имя функции</summary>
        </member>
        <member name="M:MathCore.Evaluations.NamedFunctionEvaluation`1.#ctor">
            <summary>Инициализация нового вычисления значения функции</summary>
        </member>
        <member name="M:MathCore.Evaluations.NamedFunctionEvaluation`1.#ctor(System.Func{`0})">
            <summary>Инициализация нового вычисления значения функции</summary>
            <param name="Function">Вычисляемая функция</param>
        </member>
        <member name="M:MathCore.Evaluations.NamedFunctionEvaluation`1.#ctor(System.Func{`0},System.String)">
            <summary>Инициализация нового вычисления значения функции</summary>
            <param name="Function">Вычисляемая функция</param>
            <param name="Name">Имя функции</param>
        </member>
        <member name="M:MathCore.Evaluations.NamedFunctionEvaluation`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Evaluations.NamedValueEvaluation`1">
            <summary>Именованное вычисление конкретного значения</summary>
            <typeparam name="T">Тип возвращаемого значения</typeparam>
        </member>
        <member name="P:MathCore.Evaluations.NamedValueEvaluation`1.Name">
            <summary>Имя вычисления</summary>
        </member>
        <member name="P:MathCore.Evaluations.NamedValueEvaluation`1.IsParameter">
            <summary>Признак того, что данное вычисление является именованным параметром</summary>
        </member>
        <member name="M:MathCore.Evaluations.NamedValueEvaluation`1.#ctor">
            <summary>Инициализация нового именованного вычисления конкретного значения</summary>
        </member>
        <member name="M:MathCore.Evaluations.NamedValueEvaluation`1.#ctor(`0)">
            <summary>Инициализация нового именованного вычисления конкретного значения</summary>
            <param name="value">Возвращаемое значение</param>
        </member>
        <member name="M:MathCore.Evaluations.NamedValueEvaluation`1.#ctor(`0,System.String)">
            <summary>Инициализация нового именованного вычисления конкретного значения</summary>
            <param name="value">Возвращаемое значение</param>
            <param name="name">Имя вычисления</param>
        </member>
        <member name="M:MathCore.Evaluations.NamedValueEvaluation`1.GetExpression">
            <summary>Если вычисление является параметром, то возвращается выражение параметра, иначе возвращается вычисление значения</summary>
            <returns>Выражение, соответствующее данному вычислению</returns>
        </member>
        <member name="M:MathCore.Evaluations.NamedValueEvaluation`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Evaluations.NegateOperatorEvaluation`1">
            <summary>Вычисление отрицания значения</summary>
            <typeparam name="T">Тип значения параметра</typeparam>
        </member>
        <member name="M:MathCore.Evaluations.NegateOperatorEvaluation`1.#ctor">
            <summary>Инициализация нового вычисления отрицания</summary>
        </member>
        <member name="M:MathCore.Evaluations.NegateOperatorEvaluation`1.#ctor(MathCore.Evaluations.Evaluation{`0})">
            <summary>Инициализация нового вычисления отрицания</summary>
            <param name="value">Вычисление значения операнда</param>
        </member>
        <member name="T:MathCore.Evaluations.PropertyValueEvaluation`2">
            <summary>Вычисление значения свойства объекта</summary>
            <typeparam name="TObject">Тип объекта, свойство которого надо получить</typeparam>
            <typeparam name="TValue">Тип значения свойства</typeparam>
        </member>
        <member name="M:MathCore.Evaluations.PropertyValueEvaluation`2.#ctor(System.String)">
            <summary>Инициализация нового вычисления значения свойства объекта</summary>
            <param name="PropertyName">Имя свойства</param>
        </member>
        <member name="M:MathCore.Evaluations.PropertyValueEvaluation`2.#ctor(MathCore.Evaluations.Evaluation{`0},System.String)">
            <summary>Инициализация нового вычисления свойства объекта</summary>
            <param name="obj">Вычисление объекта, свойство которого надо получить</param>
            <param name="PropertyName">Имя свойства объекта</param>
        </member>
        <member name="T:MathCore.Evaluations.SubtractEvaluation`1">
            <summary>Вычисление разности двух вычислений</summary>
            <typeparam name="T">Тип значения вычисления</typeparam>
        </member>
        <member name="M:MathCore.Evaluations.SubtractEvaluation`1.#ctor">
            <summary>Инициализация нового вычисления разности</summary>
        </member>
        <member name="M:MathCore.Evaluations.SubtractEvaluation`1.#ctor(MathCore.Evaluations.Evaluation{`0},MathCore.Evaluations.Evaluation{`0})">
            <summary>Инициализация нового вычисления разности</summary>
            <param name="a">Вычисление первого сомножителя</param>
            <param name="b">Вычисление второго сомножителя</param>
        </member>
        <member name="T:MathCore.Evaluations.UnaryOperatorEvaluation`2">
            <summary>Вычисление операции с одним операндом</summary>
            <typeparam name="TObject">Тип значения операнда</typeparam>
            <typeparam name="TValue">Тип значения вычисления</typeparam>
        </member>
        <member name="M:MathCore.Evaluations.UnaryOperatorEvaluation`2.GetOperation(System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression})">
            <summary>Метод, генерирующий функция преобразования значения операнда в значение вычисления</summary>
            <param name="OP">Функция преобразования выражения, вычисляющего значение операнда, в выражение, определяющее значение вычисления</param>
            <returns></returns>
        </member>
        <member name="F:MathCore.Evaluations.UnaryOperatorEvaluation`2._Operator">
            <summary>Функция преобразования выражения операнда в выражение вычисления над этим операндом</summary>
        </member>
        <member name="M:MathCore.Evaluations.UnaryOperatorEvaluation`2.#ctor(System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression})">
            <summary>Инициализация нового унарного вычисления</summary>
            <param name="Operator">Оператор преобразования выражения операнда в выражение вычисления</param>
        </member>
        <member name="M:MathCore.Evaluations.UnaryOperatorEvaluation`2.#ctor(System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression},MathCore.Evaluations.Evaluation{`0})">
            <summary>Инициализация нового унарного вычисления</summary>
            <param name="Operator">Оператор преобразования выражения операнда в выражение вычисления</param>
            <param name="value">Вычисление операнда</param>
        </member>
        <member name="M:MathCore.Evaluations.UnaryOperatorEvaluation`2.GetExpression">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Evaluations.ValueEvaluation`1">
            <summary>Вычисление конкретного значения</summary>
            <typeparam name="T">Тип возвращаемого значения</typeparam>
        </member>
        <member name="P:MathCore.Evaluations.ValueEvaluation`1.Value">
            <summary>Возвращаемое значение</summary>
        </member>
        <member name="M:MathCore.Evaluations.ValueEvaluation`1.#ctor">
            <summary>Инициализация нового вычисления конкретного значения</summary>
        </member>
        <member name="M:MathCore.Evaluations.ValueEvaluation`1.#ctor(`0)">
            <summary>Инициализация нового вычисления конкретного значения</summary>
            <param name="value">Возвращаемое значение</param>
        </member>
        <member name="M:MathCore.Evaluations.ValueEvaluation`1.GetValue">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Evaluations.ValueEvaluation`1.GetExpression">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Evaluations.ValueEvaluation`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Evaluations.ValueEvaluation`1.op_Implicit(`0)~MathCore.Evaluations.ValueEvaluation{`0}">
            <summary>Оператор неявного преобразования типа значения в тип вычисления этого значения</summary>
            <param name="Value">Оборачиваемое значение</param>
        </member>
        <member name="M:MathCore.Extensions.Expressions.ExpressionExtensions.Substitute(System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.LambdaExpression)">
            <exception cref="T:System.FormatException">Количество аргументов подстановки не равно 1, или во входном выражении отсутствие подставляемый параметр</exception>
        </member>
        <member name="T:MathCore.Extensions.ProcessExtensions">
            <summary>Методы-расширения для процессов</summary>
        </member>
        <member name="M:MathCore.Extensions.ProcessExtensions.WaitAsync(System.Diagnostics.Process)">
            <summary>Ожидание завершения процесса</summary>
            <param name="process">Процесс, завершение которого требуется дождаться</param>
            <returns>Задача, результат которой является кодом завершения процесса</returns>
        </member>
        <member name="M:MathCore.Extensions.ProcessExtensions.GetMotherProcess(System.Diagnostics.Process)">
            <summary>Получить родительский процесс</summary>
            <param name="process">Дочерний процесс</param>
            <returns>Родительский процесс</returns>
        </member>
        <member name="M:MathCore.Extensions.String.WordWrap.isSogl(System.Char)">
            <summary>Проверяет, является ли символ согласным</summary>
            <param name="c"></param><returns></returns>
        </member>
        <member name="M:MathCore.Extensions.String.WordWrap.isGlas(System.Char)">
            <summary>Проверяет, является ли символ гласным</summary>
            <param name="c"></param><returns></returns>
        </member>
        <member name="M:MathCore.Extensions.String.WordWrap.isSpecSign(System.Char)">
            <summary>Проверяет, является ли символ специальным (в данном контексте - разделителем)</summary>
            <param name="c"></param><returns></returns>
        </member>
        <member name="M:MathCore.Extensions.String.WordWrap.GetSymbType(System.Char)">
            <summary>Возвращает тип символа: согласный, гласный, разделитель, не определён</summary>
            <param name="c"></param><returns></returns>
        </member>
        <member name="M:MathCore.Extensions.String.WordWrap.isSlogMore(MathCore.Extensions.String.WordWrap.SymbType[],System.Int32)">
            <summary>Определяет, можно ли сделать перенос в массиве "с" в промежутке от start до len</summary>
            <param name="c"></param><param name="Start"></param><returns></returns>
            <remarks>
            Как я понимаю используется вместе с предыдущей функцией, т.е. сперва с помощью GetSymbType получить 
            из слова массив SymbType и дальше с помощью данной функции проверить, можно ли в нем сделать перенос
            </remarks>
        </member>
        <member name="M:MathCore.Extensions.String.WordWrap.SetHyph(System.String,System.Int32)">
            <summary>Фактически, она и проделывает всю работу</summary>
            <param name="pc">Входной массив символов</param>
            <param name="MaxSize">Максимальный размер</param>
            <returns>Строка с расставленными знаками переноса</returns>
        </member>
        <member name="M:MathCore.Extensions.String.WordWrap.Red_GlasMore(System.String,System.Int32)">
            <summary>
            На вход функции подается указатель на строку и позиция символа, с которого начинается чтение. 
            Дальше функция проверяет, есть ли в данной строке гласная буква
            </summary>
            <param name="p"></param>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="M:MathCore.Extensions.String.WordWrap.Red_SlogMore(System.String,System.Int32)">
            <summary>
            Аналогично предыдущей функции, но для согласных
            </summary>
            <param name="p"></param>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="M:MathCore.Extensions.String.WordWrap.MayBeHyph(System.String,System.Int32)">
            <summary>
            На вход подается указатель на строку и позиция, с которого начинается чтение. 
            Функция проверяет, можно ли сделать в данной строке перенос
            </summary>
            <param name="p"></param>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="M:MathCore.Extensions.String.WordWrap.SetHyphString(System.String)">
            <summary>На вход ей подается просто некая строка, дальше она ее обрабатывает и возвращает строку с переносами</summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="T:MathCore.IFactory`1">
            <summary>Фабрика объектов</summary>
            <typeparam name="T">Тип объектов, порождаемых фабрикой</typeparam>
        </member>
        <member name="M:MathCore.IFactory`1.Create">
            <summary>Создать новый объект</summary>
            <returns>Новый объект типа <typeparamref name="T"/></returns>
        </member>
        <member name="T:MathCore.IFactory`2">
            <summary>Фабрика объектов</summary>
            <typeparam name="T">Тип объектов, порождаемых фабрикой</typeparam>
            <typeparam name="TParameter">Тип параметра процесса создания нового объекта</typeparam>
        </member>
        <member name="M:MathCore.IFactory`2.Create(`1)">
            <summary>Создать новый объект</summary>
            <param name="Parameter">Параметр процесса создания объекта</param>
            <returns>Новый объект типа <typeparamref name="T"/></returns>
        </member>
        <member name="T:MathCore.Factory`1">
            <summary>Генератор объектов типа <typeparamref name="T"/></summary>
            <typeparam name="T">Тип генерируемых объектов</typeparam>
        </member>
        <member name="E:MathCore.Factory`1.System#ComponentModel#INotifyPropertyChanged#PropertyChanged">
            <summary>Событие возникает при генерации новой строки</summary>
        </member>
        <member name="M:MathCore.Factory`1.OnPropertyChanged(System.ComponentModel.PropertyChangedEventArgs)">
            <summary>Генерация события уведомления об изменении значения свойства</summary>
            <param name="e">Аргумент события, указывающий имя изменившегося свойства</param>
        </member>
        <member name="F:MathCore.Factory`1._FactoryMethod">
            <summary>Метод генерации объектов</summary>
        </member>
        <member name="F:MathCore.Factory`1._RaiseLastChangedEvents">
            <summary>Генерировать события изменения свойств</summary>
        </member>
        <member name="P:MathCore.Factory`1.Last">
            <summary>Последний сгенерированный объект</summary>
        </member>
        <member name="P:MathCore.Factory`1.FactoryMethod">
            <summary>Метод генерации объектов типа <typeparamref name="T"/></summary>
        </member>
        <member name="M:MathCore.Factory`1.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Factory`1"/></summary>
        </member>
        <member name="M:MathCore.Factory`1.#ctor(System.Func{`0})">
            <summary>Новый генератор объектов типа <typeparamref name="T"/></summary>
            <param name="CreateMethod">Метод генерации объектов типа <typeparamref name="T"/></param>
        </member>
        <member name="M:MathCore.Factory`1.Create">
            <summary>Создать новый объект</summary>
            <returns>Новый объект типа <typeparamref name="T"/></returns>
        </member>
        <member name="M:MathCore.Factory`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Fraction">
            <summary>Дробь</summary>
        </member>
        <member name="M:MathCore.Fraction.GCD(System.Int32,System.Int32)">
            <summary>Наибольшее общее кратное двух чисел</summary>
        </member>
        <member name="M:MathCore.Fraction.Simplify(System.Int32@,System.Int32@)">
            <summary>Упрощение дроби</summary>
            <param name="Numerator">Числитель</param>
            <param name="Denominator">Знаменатель</param>
            <returns>Истина, если дробь можно упростить</returns>
        </member>
        <member name="F:MathCore.Fraction._Numerator">
            <summary>Числитель</summary>
        </member>
        <member name="F:MathCore.Fraction._Denominator">
            <summary>Знаменатель</summary>
        </member>
        <member name="P:MathCore.Fraction.Numerator">
            <summary>Числитель</summary>
        </member>
        <member name="P:MathCore.Fraction.Denominator">
            <summary>Знаменатель</summary>
        </member>
        <member name="P:MathCore.Fraction.DecimalValue">
            <summary>Десятичное значение дроби</summary>
        </member>
        <member name="M:MathCore.Fraction.#ctor(System.Int32,System.Int32)">
            <summary>Новая дробь</summary>
            <param name="Nominator">Числитель</param>
            <param name="Denominator">Знаменатель</param>
        </member>
        <member name="M:MathCore.Fraction.GetSimplified">
            <summary>Получить упрощённую дробь</summary>
            <returns>Упрощённая дробь</returns>
        </member>
        <member name="M:MathCore.Fraction.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Fraction.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Fraction.Equals(MathCore.Fraction)">
            <summary>Проверка на эквивалентность дроби</summary>
            <param name="other">Проверяемая дробь</param>
            <returns>Истина, если дроби идентичные</returns>
        </member>
        <member name="M:MathCore.Fraction.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Functions.FunctionsExtensions">
            <summary>Класс методов-расширений для функций</summary>
        </member>
        <member name="T:MathCore.Functions.FunctionsExtensions.FuncValue">
            <summary>Структура значения функции {Аргумент - значение}</summary>
        </member>
        <member name="F:MathCore.Functions.FunctionsExtensions.FuncValue.Argument">
            <summary>Аргумент функции</summary>
        </member>
        <member name="F:MathCore.Functions.FunctionsExtensions.FuncValue.Value">
            <summary>Значение функции</summary>
        </member>
        <member name="M:MathCore.Functions.FunctionsExtensions.FuncValue.#ctor(System.Double,System.Double)">
            <summary>Инициализация новой пары аргумент-значение функции</summary>
            <param name="arg">Аргумент функции</param>
            <param name="value">Значение функции</param>
        </member>
        <member name="T:MathCore.Functions.FunctionsExtensions.FuncMinMaxValue">
            <summary>Структура, содержащая максимальное и минимальное значение функции</summary>
        </member>
        <member name="F:MathCore.Functions.FunctionsExtensions.FuncMinMaxValue.Min">
            <summary>Минимальное значение функции</summary>
        </member>
        <member name="F:MathCore.Functions.FunctionsExtensions.FuncMinMaxValue.Max">
            <summary>Максимальное значение функции</summary>
        </member>
        <member name="M:MathCore.Functions.FunctionsExtensions.FuncMinMaxValue.#ctor(MathCore.Functions.FunctionsExtensions.FuncValue,MathCore.Functions.FunctionsExtensions.FuncValue)">
            <summary>Инициализация нового максимального и минимального значения функции</summary>
            <param name="min">Минимум функции</param>
            <param name="max">Максимум функции</param>
        </member>
        <member name="M:MathCore.Functions.FunctionsExtensions.GetValues(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Получить массив значений функции в указанном интервале с указанным шагом</summary>
            <param name="f">Функция, массив значений которой требуется получить</param>
            <param name="x1">Начало интервала</param>
            <param name="x2">Конец интервала</param>
            <param name="dx">Шаг сетки дискретизации</param>
            <returns>Массив значений функции</returns>
        </member>
        <member name="M:MathCore.Functions.FunctionsExtensions.GetMinMax(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Определить минимум и максимум на интервале</summary>
            <param name="f">Функция, минимум и максимум которой требуется определить</param>
            <param name="x1">Начало интервала</param>
            <param name="x2">Конец интервала</param>
            <param name="dx">Шаг сетки разбиения</param>
            <returns>Структура, содержащая минимум и максимум функции</returns>
        </member>
        <member name="M:MathCore.Functions.FunctionsExtensions.GetMinValue(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Определить минимум функции</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала</param>
            <param name="x2">Конец интервала</param>
            <param name="dx">Шаг</param>
            <returns>Минимум функции</returns>
        </member>
        <member name="M:MathCore.Functions.FunctionsExtensions.GetMaxValue(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Определить максимум функции</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала</param>
            <param name="x2">Конец интервала</param>
            <param name="dx">Шаг</param>
            <returns>Максимум функции</returns>
        </member>
        <member name="M:MathCore.Functions.PSO.Swarm1D.Minimize(System.Func{System.Double,System.Double},MathCore.Interval,System.Int32,System.Double@,System.Double@)">
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="T:MathCore.Functions.PSO.Swarm2D">
            <summary>Рой двумерных частиц</summary>
        </member>
        <member name="F:MathCore.Functions.PSO.Swarm2D.w">
            <summary>Вес инерции</summary>
        </member>
        <member name="F:MathCore.Functions.PSO.Swarm2D.c1">
            <summary>Коэффициент локального веса</summary>
        </member>
        <member name="F:MathCore.Functions.PSO.Swarm2D.c2">
            <summary>Коэффициент глобального веса</summary>
        </member>
        <member name="T:MathCore.Functions.PSO.Swarm2D.Particle2D">
            <summary>Частица</summary>
        </member>
        <member name="F:MathCore.Functions.PSO.Swarm2D._ParticleCount">
            <summary>Размер роя</summary>
        </member>
        <member name="T:MathCore.GCWatcher">
            <summary>Наблюдатель за сборщиком мусора</summary>
        </member>
        <member name="E:MathCore.GCWatcher.__Approaches">
            <summary>Событие запуска процесса сборки мусора</summary>
        </member>
        <member name="E:MathCore.GCWatcher.Approaches">
            <summary>Событие запуска процесса сборки мусора</summary>
        </member>
        <member name="E:MathCore.GCWatcher.__Complete">
            <summary>Событие завершения процесса сборки мусора</summary>
        </member>
        <member name="E:MathCore.GCWatcher.Complete">
            <summary>Событие завершения процесса сборки мусора</summary>
        </member>
        <member name="M:MathCore.GCWatcher.OnApproaches">
            <summary>Генерация события начала сборки мусора</summary>
        </member>
        <member name="M:MathCore.GCWatcher.OnComplete">
            <summary>Генерация события окончания сборки мусора</summary>
        </member>
        <member name="F:MathCore.GCWatcher.__GcWatcher">
            <summary>Объект-наблюдатель за сборщиком мусора</summary>
        </member>
        <member name="F:MathCore.GCWatcher.__SyncRoot">
            <summary>Объект синхронизации потоков управления наблюдателем</summary>
        </member>
        <member name="F:MathCore.GCWatcher._WatcherThread">
            <summary>Поток наблюдения с сборщиком мусора</summary>
        </member>
        <member name="F:MathCore.GCWatcher.__Enabled">
            <summary>Признак активности наблюдателя</summary>
        </member>
        <member name="M:MathCore.GCWatcher.#ctor">
            <summary>Скрытая инициализация объекта-наблюдателя</summary>
        </member>
        <member name="M:MathCore.GCWatcher.Start">
            <summary>Запуск процесса наблюдения</summary>
        </member>
        <member name="M:MathCore.GCWatcher.Stop">
            <summary>Остановка процесса наблюдения</summary>
        </member>
        <member name="M:MathCore.GCWatcher.Watch">
            <summary>Процесс наблюдения</summary>
        </member>
        <member name="T:MathCore.Geolocation.GPS">
            <summary>Класс сервисных функций работы с координатами</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.MeridianLength">
            <summary>Длина окружности меридиана (в метрах)</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.Meridian1DegreeLength">
            <summary>Длина дуги меридиана в 1 градус (в метрах)</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.Meridian1MinuteLength">
            <summary>Длина дуги меридиана в 1 минуту (в метрах)</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.Meridian1SecondLength">
            <summary>Длина дуги меридиана в 1 секунду (в метрах)</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.Meridian1RadianLength">
            <summary>Длина дуги меридиана в 1 радиан (в метрах)</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.ParallelEquatorLength">
            <summary>Длина окружности параллели на экваторе (в метрах)</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.ParallelEquator1DegreeLength">
            <summary>Длина дуги параллели на экваторе в 1 градус (в метрах)</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.ParallelEquator1MinuteLength">
            <summary>Длина дуги параллели на экваторе в 1 минуту (в метрах)</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.ParallelEquator1SecondLength">
            <summary>Длина дуги параллели на экваторе в 1 секунду (в метрах)</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.ParallelEquator1RadianLength">
            <summary>Длина дуги параллели на экваторе в 1 радиан (в метрах)</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.EarthRadius">
            <summary>Радиус Земли в метрах</summary>
        </member>
        <member name="M:MathCore.Geolocation.GPS.LengthBetween(System.Double,System.Double,System.Double,System.Double)">
            <summary>Вычисление расстояния между двумя точками на поверхности земли, заданными своими координатами</summary>
            <param name="latitude1">Широта первой точки в градусах</param>
            <param name="longitude1">Долгота первой точки в градусах</param>
            <param name="latitude2">Широта второй точки в градусах</param>
            <param name="longitude2">Долгота второй точки в градусах</param>
            <returns>Длина дуги на поверхности Земли, начинающейся в первой точке и заканчивающейся во второй точке</returns>
        </member>
        <member name="M:MathCore.Geolocation.GPS.EquirectangularApproximation_LengthBetween(System.Double,System.Double,System.Double,System.Double)">
            <summary>Вычисление расстояния между двумя точками на поверхности земли (в равнопромежуточной проекции), заданными своими координатами</summary>
            <param name="latitude1">Широта первой точки в градусах</param>
            <param name="longitude1">Долгота первой точки в градусах</param>
            <param name="latitude2">Широта второй точки в градусах</param>
            <param name="longitude2">Долгота второй точки в градусах</param>
            <returns>Расстояние между двумя точками</returns>
            <remarks>Алгоритм требуем меньше вычислительных ресурсов, но даёт большую погрешность</remarks>
        </member>
        <member name="M:MathCore.Geolocation.GPS.Heading(System.Double,System.Double,System.Double,System.Double)">
            <summary>Определение курса по координатам начальной и конечной точки</summary>
            <param name="latitude1">Широта первой исходной точки</param>
            <param name="longitude1">Долгота первой исходной точки</param>
            <param name="latitude2">Широта второй исходной точки</param>
            <param name="longitude2">Долгота второй исходной точки</param>
            <returns>Курс в градусах</returns>
        </member>
        <member name="M:MathCore.Geolocation.GPS.HalfWayPoint(System.Double,System.Double,System.Double,System.Double)">
            <summary>Определение точки на середине отрезка, заданного двумя точками</summary>
            <param name="latitude1">Широта первой исходной точки</param>
            <param name="longitude1">Долгота первой исходной точки</param>
            <param name="latitude2">Широта второй исходной точки</param>
            <param name="longitude2">Долгота второй исходной точки</param>
            <returns>Точка в середине отрезка</returns>
        </member>
        <member name="M:MathCore.Geolocation.GPS.DestinationPoint(System.Double,System.Double,System.Double,System.Double)">
            <summary>Определение точки места назначения по исходной точке, курсу и расстоянию</summary>
            <param name="latitude">Широта исходной точки</param>
            <param name="longitude">Долгота исходной точки</param>
            <param name="heading">Курс на точку назначения</param>
            <param name="distance">Пройденная дистанция в метрах</param>
            <returns>Точка назначения</returns>
        </member>
        <member name="M:MathCore.Geolocation.GPS.DestinationPoint(System.Double,System.Double,System.Double,System.Double,System.Double@)">
            <summary>Определение точки места назначения по исходной точке, курсу и расстоянию</summary>
            <param name="latitude">Широта исходной точки</param>
            <param name="longitude">Долгота исходной точки</param>
            <param name="heading">Курс на точку назначения</param>
            <param name="distance">Пройденная дистанция в метрах</param>
            <param name="final_heading">Курс из точки назначения на исходную точку</param>
            <returns>Точка назначения</returns>
        </member>
        <member name="M:MathCore.Geolocation.GPS.Intersection(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Определение точки пресечения двух курсов, каждый из которых задан исходной точкой</summary>
            <param name="latitude1">Широта первой исходной точки</param>
            <param name="longitude1">Долгота первой исходной точки</param>
            <param name="heading1">Курс из первой исходной точки</param>
            <param name="latitude2">Широта второй исходной точки</param>
            <param name="longitude2">Долгота второй исходной точки</param>
            <param name="heading2">Курс второй исходной точки</param>
            <returns>Точка пересечения двух курсов</returns>
        </member>
        <member name="T:MathCore.Graphs.GraphEx">
            <summary>Методы-расширения, позволяющие рассматривать любой объект как граф</summary>
        </member>
        <member name="M:MathCore.Graphs.GraphEx.AsGraphNode``2(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}},System.Func{``0,``0,``1},System.Boolean)">
            <summary>Преобразование к типу вершины графа</summary>
            <typeparam name="TValue">Тап значения вершины</typeparam>
            <typeparam name="TWeight">Тип веса связи</typeparam>
            <param name="value">Значение вершины</param>
            <param name="GetChilds">Метод выделения дочерних узлов</param>
            <param name="GetWeight">Метод определения веса связи между узлами</param>
            <param name="Buffered">Буферизация узлов и связей</param>
            <returns>Узел графа</returns>
            <example>
            <code>
            var M = new[,]
                   { /* 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14*/
            /*  0 */   {0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /*  1 */   {1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /*  2 */   {1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},
            /*  3 */   {0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0},
            /*  4 */   {0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0},
            /*  5 */   {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0},
            /*  6 */   {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1},
            /*  7 */   {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /*  8 */   {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /*  9 */   {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /* 10 */   {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /* 11 */   {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /* 12 */   {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /* 13 */   {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
            /* 14 */   {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
                   };
            var node = new { M, i = 0 };
            var root = node.AsGraphNode(r => Enumerable.Range(0, r.M.GetLength(1)).Select(i => new { M, i }),
                         (from, to) => from.M[to.i, from.i]);
            var tree = root.AsGraphNode(root => root.Links.Where(link => link.Weight == 1)
                                                          .Select(link => link.Node),
                                        (from, to) => to.Value.i - from.Value.i);
            var rout = tree.GetWaveRoute();
            
            </code>
            </example>
        </member>
        <member name="M:MathCore.Graphs.GraphEx.AsGraphNode``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}},System.Boolean)">
            <summary>Преобразование к виду графа</summary>
            <typeparam name="TValue">Тип преобразуемого объекта</typeparam>
            <param name="value">Преобразуемый объект</param>
            <param name="GetChilds">Метод извлечения дочерних узлов из каждого узла графа</param>
            <param name="Buffered">Флаг необходимости проведения буферизации</param>
            <returns>Узел графа</returns>
        </member>
        <member name="M:MathCore.Graphs.GraphEx.BypassInDepth``2(MathCore.Graphs.IGraphNode{``0,``1})">
            <summary>Метод перебора вершин графа путём обхода "в глубину". Обход на основе стека дочерних узлов.</summary>
            <typeparam name="TValue">Тип узлов графа</typeparam>
            <typeparam name="TWeight">Тип связи узлов графа</typeparam>
            <param name="Node">Начальный узел графа</param>
            <returns>Последовательность узлов графа</returns>
        </member>
        <member name="M:MathCore.Graphs.GraphEx.BypassInDepth``1(MathCore.Graphs.IGraphNode{``0})">
            <summary>Метод перебора вершин графа путём обхода "в глубину". Обход на основе стека дочерних узлов.</summary>
            <typeparam name="TValue">Тип узлов графа</typeparam>
            <param name="Node">Начальный узел графа</param>
            <returns>Последовательность узлов графа</returns>
        </member>
        <member name="M:MathCore.Graphs.GraphEx.BypassInWidth``2(MathCore.Graphs.IGraphNode{``0,``1})">
            <summary>Метод перебора вершин графа путём обхода "в ширину". Обход на основе очереди дочерних узлов.</summary>
            <typeparam name="TValue">Тип узлов графа</typeparam>
            <typeparam name="TWeight">Тип связи узлов графа</typeparam>
            <param name="Node">Начальный узел графа</param>
            <returns>Последовательность узлов графа</returns>
        </member>
        <member name="M:MathCore.Graphs.GraphEx.BypassInWidth``1(MathCore.Graphs.IGraphNode{``0},System.Boolean)">
            <summary>Метод перебора вершин графа путём обхода "в ширину". Обход на основе очереди дочерних узлов.</summary>
            <typeparam name="TValue">Тип узлов графа</typeparam>
            <param name="Node">Начальный узел графа</param>
            <param name="TakeRoot">Перечислять корень дерева?</param>
            <returns>Последовательность узлов графа</returns>
        </member>
        <member name="M:MathCore.Graphs.GraphEx.BypassInWidth``1(MathCore.Graphs.IGraphNode{``0},System.Func{MathCore.Graphs.IGraphNode{``0},System.Int32},System.Boolean)">
            <summary>Метод перебора вершин графа путём обхода "в ширину". Обход на основе очереди дочерних узлов с указанием функции хеширования.</summary>
            <typeparam name="TValue">Тип узлов графа</typeparam>
            <param name="Node">Начальный узел графа</param>
            <param name="hash">Функция хеширования элементов</param>
            <param name="TakeRoot">Перечислять корень дерева?</param>
            <returns>Последовательность узлов графа</returns>
        </member>
        <member name="M:MathCore.Graphs.GraphEx.FindRouteInDepth``2(MathCore.Graphs.IGraphNode{``0,``1},System.Predicate{``0})">
            <summary>Метод поиска пути в графе путём обхода вершин "в глубину"</summary>
            <typeparam name="TValue">Тип вершины графа</typeparam>
            <typeparam name="TWeight">Тип связи вершин графа</typeparam>
            <param name="RootNode">Начальный элемент поиска пути</param>
            <param name="FindPredicate">Метод определения окончания поиска, как успешного</param>
            <returns>Маршрут в графе</returns>
        </member>
        <member name="M:MathCore.Graphs.GraphEx.GetWaveRoute``2(MathCore.Graphs.IGraphNode{``0,``1})">
            <summary>Метод поиска всех путей из указанной вершины до всех доступных вершин графа методом фронта волны</summary>
            <typeparam name="TValue">Тип вершины графа</typeparam>
            <typeparam name="TWeight">Тип связи вершин графа</typeparam>
            <param name="Root">Начальный элемент поиска пути</param>
            <returns>Массив найденных путей</returns>
        </member>
        <member name="M:MathCore.Graphs.GraphRoute`2.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Graphs.GraphRoute`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Graphs.GraphRoute`2.ToString">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Graphs.IGraphLink`2">
            <summary>Связь узла</summary>
            <typeparam name="TValue">Тип значения узла</typeparam>
            <typeparam name="TWeight">Тип нагрузки на связь</typeparam>
        </member>
        <member name="P:MathCore.Graphs.IGraphLink`2.Node">
            <summary>Связанный узел</summary>
        </member>
        <member name="P:MathCore.Graphs.IGraphLink`2.Weight">
            <summary>Нагрузка на связь</summary>
        </member>
        <member name="T:MathCore.Graphs.IGraphNode`2">
            <summary>Узел графа</summary>
            <typeparam name="TValue">Тип значения узла</typeparam>
            <typeparam name="TWeight">Тип нагрузки на связь</typeparam>
        </member>
        <member name="P:MathCore.Graphs.IGraphNode`2.Links">
            <summary>Связи узла</summary>
        </member>
        <member name="P:MathCore.Graphs.IGraphNode`2.Value">
            <summary>Значение узла</summary>
        </member>
        <member name="P:MathCore.Graphs.IGraphNode`1.Childs">
            <summary>Связи узла</summary>
        </member>
        <member name="P:MathCore.Graphs.IGraphNode`1.Value">
            <summary>Значение узла</summary>
        </member>
        <member name="P:MathCore.Graphs.LambdaGraphNode`2.Links">
            <inheritdoc />
        </member>
        <member name="P:MathCore.Graphs.LambdaGraphNode`1.Childs">
            <summary>Связи узла</summary>
        </member>
        <member name="P:MathCore.Graphs.LambdaGraphNode`1.Value">
            <summary>Значение узла</summary>
        </member>
        <member name="M:MathCore.Graphs.LambdaGraphNode`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Graphs.LambdaGraphNode`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Graphs.LambdaGraphNode`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Graphs.LambdaGraphNode`1.Equals(MathCore.Graphs.LambdaGraphNode{`0})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Graphs.LambdaGraphNode`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Graphs.LambdaGraphNode`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Graphs.TreeListNode`1.IndexOf(MathCore.Graphs.TreeListNode{`0})">
            <summary>
            Определяет индекс заданного элемента коллекции <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <returns>
            Индекс <paramref name="item"/> если он найден в списке; в противном случае его значение равно -1.
            </returns>
            <param name="item">Объект, который требуется найти в <see cref="T:System.Collections.Generic.IList`1"/>.</param>
        </member>
        <member name="M:MathCore.Graphs.TreeListNode`1.IndexOf(`0)">
            <summary>Определяет индекс заданного элемента коллекции <see cref="T:System.Collections.Generic.IList`1"/>.</summary>
            <returns>Индекс <paramref name="item"/> если он найден в списке; в противном случае его значение равно -1.</returns>
            <param name="item">Объект, который требуется найти в <see cref="T:System.Collections.Generic.IList`1"/>.</param>
        </member>
        <member name="M:MathCore.Graphs.TreeListNode`1.Insert(System.Int32,MathCore.Graphs.TreeListNode{`0})">
            <summary>Вставляет элемент в список <see cref="T:System.Collections.Generic.IList`1"/> по указанному индексу.</summary>
            <param name="index">Индекс (с нуля), по которому следует вставить параметр <paramref name="item"/>.</param><param name="item">Объект, вставляемый в <see cref="T:System.Collections.Generic.IList`1"/>.</param><exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index"/> не является допустимым индексом в <see cref="T:System.Collections.Generic.IList`1"/>.</exception><exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.Generic.IList`1"/> доступен только для чтения.</exception>
        </member>
        <member name="M:MathCore.Graphs.TreeListNode`1.Insert(System.Int32,`0)">
            <summary>Вставляет элемент в список <see cref="T:System.Collections.Generic.IList`1"/> по указанному индексу.</summary>
            <param name="index">Индекс (с нуля), по которому следует вставить параметр <paramref name="item"/>.</param><param name="item">Объект, вставляемый в <see cref="T:System.Collections.Generic.IList`1"/>.</param><exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index"/> не является допустимым индексом в <see cref="T:System.Collections.Generic.IList`1"/>.</exception><exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.Generic.IList`1"/> доступен только для чтения.</exception>
        </member>
        <member name="M:MathCore.Graphs.TreeListNode`1.RemoveAt(System.Int32)">
            <summary>Удаляет элемент <see cref="T:System.Collections.Generic.IList`1"/> по указанному индексу.</summary>
            <param name="index">Индекс (с нуля) удаляемого элемента.</param><exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index"/> не является допустимым индексом в <see cref="T:System.Collections.Generic.IList`1"/>.</exception><exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.Generic.IList`1"/> доступен только для чтения.</exception>
        </member>
        <member name="P:MathCore.Graphs.TreeListNode`1.System#Collections#Generic#IList{TValue}#Item(System.Int32)">
            <summary>Получает или задает элемент по указанному индексу.</summary>
            <returns>Элемент с указанным индексом.</returns>
            <param name="index">Индекс (с нуля) элемента, который необходимо получить или задать.</param><exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index"/> не является допустимым индексом в <see cref="T:System.Collections.Generic.IList`1"/>.</exception><exception cref="T:System.NotSupportedException">Свойство задано, и объект <see cref="T:System.Collections.Generic.IList`1"/> доступен только для чтения.</exception>
        </member>
        <member name="M:MathCore.Graphs.TreeListNode`1.System#Collections#Generic#ICollection{TValue}#Add(`0)">
            <summary>Добавляет элемент в интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <param name="item">Объект, добавляемый в интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения.</exception>
        </member>
        <member name="M:MathCore.Graphs.TreeListNode`1.Clear">
            <summary>Удаляет все элементы из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения.</exception>
        </member>
        <member name="M:MathCore.Graphs.TreeListNode`1.Contains(`0)">
            <summary>Определяет, содержит ли интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> указанное значение.</summary>
            <returns>Значение true, если объект <paramref name="item"/> найден в <see cref="T:System.Collections.Generic.ICollection`1"/>; в противном случае — значение false.</returns>
            <param name="item">Объект, который требуется найти в <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
        </member>
        <member name="M:MathCore.Graphs.TreeListNode`1.CopyTo(`0[],System.Int32)">
            <summary>
            Копирует элементы <see cref="T:System.Collections.Generic.ICollection`1"/> в массив <see cref="T:System.Array"/>, начиная с указанного индекса <see cref="T:System.Array"/>.
            </summary>
            <param name="array">Одномерный массив <see cref="T:System.Array"/>, в который копируются элементы из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>. Индексация в массиве <see cref="T:System.Array"/> должна начинаться с нуля.</param><param name="index">Значение индекса (с нуля) в массиве <paramref name="array"/>, с которого начинается копирование.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="array"/> имеет значение null.</exception><exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index"/> меньше 0.</exception><exception cref="T:System.ArgumentException">Массив <paramref name="array"/> является многомерным.-или-
                            Значение индекса массива <paramref name="index"/> больше или равно длине массива <paramref name="array"/>.-или-Количество элементов в исходном интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/> превышает размер доступного места, начиная с индекса <paramref name="index"/> и до конца массива назначения <paramref name="array"/>.-или-Тип <paramref name="TValue"/> не может быть автоматически приведен к типу массива назначения <paramref name="array"/>.</exception>
        </member>
        <member name="M:MathCore.Graphs.TreeListNode`1.Remove(`0)">
            <summary>Удаляет первое вхождение указанного объекта из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <returns>
            Значение true, если объект <paramref name="item"/> успешно удален из <see cref="T:System.Collections.Generic.ICollection`1"/>, в противном случае — значение false. Этот метод также возвращает значение false, если параметр <paramref name="item"/> не найден в исходном интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            <param name="item">Объект, который необходимо удалить из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения.</exception>
        </member>
        <member name="P:MathCore.Graphs.TreeListNode`1.System#Collections#Generic#ICollection{TValue}#Count">
            <summary>Получает число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <returns>Число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.</returns>
        </member>
        <member name="M:MathCore.Graphs.TreeListNode`1.Contains(MathCore.Graphs.TreeListNode{`0})">
            <summary>Определяет, содержит ли интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> указанное значение.</summary>
            <returns>
            Значение true, если объект <paramref name="item"/> найден в <see cref="T:System.Collections.Generic.ICollection`1"/>; в противном случае — значение false.
            </returns>
            <param name="item">Объект, который требуется найти в <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
        </member>
        <member name="M:MathCore.Graphs.TreeListNode`1.CopyTo(MathCore.Graphs.TreeListNode{`0}[],System.Int32)">
            <summary>
            Копирует элементы <see cref="T:System.Collections.Generic.ICollection`1"/> в массив <see cref="T:System.Array"/>, начиная с указанного индекса <see cref="T:System.Array"/>.
            </summary>
            <param name="array">Одномерный массив <see cref="T:System.Array"/>, в который копируются элементы из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>. Индексация в массиве <see cref="T:System.Array"/> должна начинаться с нуля.</param><param name="index">Значение индекса (с нуля) в массиве <paramref name="array"/>, с которого начинается копирование.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="array"/> имеет значение null.</exception><exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index"/> меньше 0.</exception><exception cref="T:System.ArgumentException">Массив <paramref name="array"/> является многомерным.-или-
                            Значение индекса массива <paramref name="index"/> больше или равно длине массива <paramref name="array"/>.-или-Количество элементов в исходном интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/> превышает размер доступного места, начиная с индекса <paramref name="index"/> и до конца массива назначения <paramref name="array"/>.-или-Тип <paramref name="T"/> не может быть автоматически приведен к типу массива назначения <paramref name="array"/>.</exception>
        </member>
        <member name="M:MathCore.Graphs.TreeListNode`1.Remove(MathCore.Graphs.TreeListNode{`0})">
            <summary>Удаляет первое вхождение указанного объекта из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <returns>
            Значение true, если объект <paramref name="item"/> успешно удален из <see cref="T:System.Collections.Generic.ICollection`1"/>, в противном случае — значение false. Этот метод также возвращает значение false, если параметр <paramref name="item"/> не найден в исходном интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            <param name="item">Объект, который необходимо удалить из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения.</exception>
        </member>
        <member name="P:MathCore.Graphs.TreeListNode`1.System#Collections#Generic#ICollection{MathCore#Graphs#TreeListNode{TValue}}#Count">
            <summary>Получает число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <returns>Число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.</returns>
        </member>
        <member name="P:MathCore.Graphs.TreeListNode`1.IsReadOnly">
            <summary>Получает значение, указывающее, доступен ли интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> только для чтения.</summary>
            <returns>Значение true, если интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения, в противном случае — значение false.</returns>
        </member>
        <member name="M:MathCore.Graphs.TreeListNode`1.System#Collections#Generic#IEnumerable{TValue}#GetEnumerator">
            <summary>Возвращает перечислитель, выполняющий перебор элементов в коллекции</summary>
            <returns>Интерфейс <see cref="T:System.Collections.Generic.IEnumerator`1"/>, который может использоваться для перебора элементов коллекции.</returns>
        </member>
        <member name="T:MathCore.ICloneable`1">
            <summary>Объект поддерживает клонирование</summary>
            <typeparam name="T">Тип объекта</typeparam>
        </member>
        <member name="M:MathCore.ICloneable`1.Clone">
            <summary>Клонирование объекта</summary>
            <returns>Клонированный экземпляр объекта</returns>
        </member>
        <member name="T:MathCore.ICountable">
            <summary>Объект позволяет определять количество вложенных объектов</summary>
        </member>
        <member name="P:MathCore.ICountable.Count">
            <summary>Число элементов</summary>
        </member>
        <member name="T:MathCore.IIndexableRead`2">
            <summary>Объект индексируемый только для чтения значений</summary>
            <typeparam name="TIndex">Тип индекса</typeparam>
            <typeparam name="TValue">Тип элементов</typeparam>
        </member>
        <member name="P:MathCore.IIndexableRead`2.Item(`0)">
            <summary>Индексатор объекта только для чтения</summary>
            <param name="index">Индекс</param>
        </member>
        <member name="T:MathCore.IIndexableRead`3">
            <summary>Объект индексируемый только для чтения значений с двумя индексами</summary>
            <typeparam name="TIndex1">Тип первого индекса</typeparam>
            <typeparam name="TIndex2">Тип второго индекса</typeparam>
            <typeparam name="TValue">Тип значений</typeparam>
        </member>
        <member name="P:MathCore.IIndexableRead`3.Item(`0,`1)">
            <summary>Индексатор объекта только для чтения</summary>
            <param name="index1">Первый индекс</param>
            <param name="index2">Второй индекс</param>
        </member>
        <member name="T:MathCore.IIndexableWrite`2">
            <summary>Объект индексируемый только для записи значений</summary>
            <typeparam name="TIndex">Тип индекса</typeparam>
            <typeparam name="TValue">Тип элементов</typeparam>
        </member>
        <member name="P:MathCore.IIndexableWrite`2.Item(`0)">
            <summary>Индексатор объекта только для записи</summary><param name="index">Индекс</param>
        </member>
        <member name="T:MathCore.IIndexableWrite`3">
            <summary>Объект индексируемый только для записи значений с двумя индексами</summary>
            <typeparam name="TIndex1">Тип первого индекса</typeparam>
            <typeparam name="TIndex2">Тип второго индекса</typeparam>
            <typeparam name="TValue">Тип значений</typeparam>
        </member>
        <member name="P:MathCore.IIndexableWrite`3.Item(`0,`1)">
            <summary>Индексатор объекта только для записи</summary>
            <param name="index1">Первый индекс</param><param name="index2">Второй индекс</param>
        </member>
        <member name="T:MathCore.IIndexable`2">
            <summary>Объект индексируемый</summary>
            <typeparam name="TIndex">Тип индекса</typeparam><typeparam name="TValue">Тип элементов</typeparam>
        </member>
        <member name="P:MathCore.IIndexable`2.Item(`0)">
            <summary>Индексатор объекта</summary><param name="index">Индекс</param>
        </member>
        <member name="T:MathCore.IIndexable`3">
            <summary>Объект индексируемый с двумя параметрами индекса</summary>
            <typeparam name="TIndex1">Тип первого индекса</typeparam>
            <typeparam name="TIndex2">Тип второго индекса</typeparam>
            <typeparam name="TValue">Тип элементов</typeparam>
        </member>
        <member name="P:MathCore.IIndexable`3.Item(`0,`1)">
            <summary>Индексатор объекта</summary>
            <param name="index1">Первый индекс</param><param name="index2">Второй индекс</param>
        </member>
        <member name="T:MathCore.IIndexable`1">
            <summary>Объект индексируемый с целочисленным индексом</summary>
            <typeparam name="TValue">Тип элементов</typeparam>
        </member>
        <member name="T:MathCore.IIndexableRef`1">
            <summary>Объект, индексируемый целочисленным индексом по ссылке</summary>
            <typeparam name="TValue">Тип элементов</typeparam>
        </member>
        <member name="P:MathCore.IIndexableRef`1.Item(System.Int32)">
            <summary>Ссылка на значение, доступное внутри объекта по индексу</summary>
            <param name="index">Индекс значения</param>
        </member>
        <member name="T:MathCore.IIndexableReadonlyRef`1">
            <summary>Объект, индексируемый целочисленным индексом по ссылке только для чтения</summary>
            <typeparam name="TValue">Тип элементов</typeparam>
        </member>
        <member name="P:MathCore.IIndexableReadonlyRef`1.Item(System.Int32)">
            <summary>Ссылка только для чтения на значение, доступное внутри объекта по индексу</summary>
            <param name="index">Индекс значения</param>
        </member>
        <member name="T:MathCore.INamedRead">
            <summary>Объект, обладающий именем</summary>
        </member>
        <member name="P:MathCore.INamedRead.Name">
            <summary>Имя объекта</summary>
        </member>
        <member name="T:MathCore.INamed">
            <summary>Объект с возможностью задавать имя</summary>
        </member>
        <member name="P:MathCore.INamed.Name">
            <summary>Имя объекта</summary>
        </member>
        <member name="T:MathCore.NamedInterfaceExtensions">
            <summary>Методы-расширения интерфейса именованных объектов</summary>
        </member>
        <member name="M:MathCore.NamedInterfaceExtensions.Rename(MathCore.INamed,System.String)">
            <summary>Изменить имя объекта</summary>
            <param name="obj">Объект, имя которого требуется изменить</param>
            <param name="NewName">Новое имя объекта</param>
        </member>
        <member name="T:MathCore.Interpolation.BezierCurve">
            <summary><see url="http://ru.wikipedia.org/wiki/Кривая_Безье">Кривая Безье</see></summary>
        </member>
        <member name="M:MathCore.Interpolation.BezierCurve.BinomCoefficient(System.Int32,System.Int32)">
            <summary>
            Биномиальный коэффициент (1+x)^n из <paramref name="n"/> по <paramref name="k"/>
            <see url="http://ru.wikipedia.org/wiki/Биномиальный_коэффициент">Википедия:Биномиальный коэффициент</see>
            </summary>
            <param name="n">Степень <see url="http://ru.wikipedia.org/wiki/Бином_Ньютона">бинома Ньютона</see></param>
            <param name="k">Номер коэффициента</param>
            <returns>Коэффициент разложения Бинома Ньютона (1+x)^n</returns>
        </member>
        <member name="M:MathCore.Interpolation.BezierCurve.GetBernshteynPolynom(System.Int32,System.Int32)">
            <summary>Получить <seealso url="http://ru.wikipedia.org/wiki/Многочлен_Бернштейна">Полином Бернштейна</seealso>></summary>
            <param name="k">Номер многочлена</param>
            <param name="n">Степень</param>
            <returns></returns>
        </member>
        <member name="F:MathCore.Interpolation.BezierCurve._Points">
            <summary>Набор точек аппроксимации</summary>
        </member>
        <member name="F:MathCore.Interpolation.BezierCurve._BernshteynPolynoms">
            <summary><see url="http://ru.wikipedia.org/wiki/Многочлен_Бернштейна">Полином Бернштейна</see>></summary>        
        </member>
        <member name="M:MathCore.Interpolation.BezierCurve.#ctor(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Новая <see url="http://ru.wikipedia.org/wiki/Кривая_Безье">кривая Безье</see></summary>
            <param name="X">Список координат точек x</param>
            <param name="Y">Список координат точек y</param>
        </member>
        <member name="M:MathCore.Interpolation.BezierCurve.#ctor(System.Collections.Generic.IEnumerable{MathCore.Complex})">
            <summary>Новая <see url="http://ru.wikipedia.org/wiki/Кривая_Безье">кривая Безье</see></summary>
            <param name="Points">Набор точек в виде <see cref="T:MathCore.Complex">комплексных чисел</see></param>
        </member>
        <member name="M:MathCore.Interpolation.BezierCurve.#ctor(System.Collections.Generic.IEnumerable{MathCore.Vectors.Vector2D})">
            <summary>Новая <see url="http://ru.wikipedia.org/wiki/Кривая_Безье">кривая Безье</see></summary>
            <param name="Points">Набор точек</param>
        </member>
        <member name="M:MathCore.Interpolation.BezierCurve.Initialize(System.Collections.Generic.IEnumerable{MathCore.Vectors.Vector2D})">
            <summary>Инициализировать кривую Безье</summary>
            <param name="Points">Набор точек</param>
        </member>
        <member name="M:MathCore.Interpolation.BezierCurve2.Bernstein(System.Int32,System.Int32,System.Double)">
            <summary>Calculate Bernstein basis</summary>
        </member>
        <member name="T:MathCore.Interpolation.CubicSpline">
            <summary>Интерполирование функций естественными кубическими сплайнами</summary>
            <remarks>Разработчик: Назар Андриенко Email: nuzikprogrammer@gmail.com</remarks>
        </member>
        <member name="T:MathCore.Interpolation.CubicSpline.SplineState">
            <summary>Структура, описывающая сплайн на каждом сегменте сетки</summary>
        </member>
        <member name="F:MathCore.Interpolation.CubicSpline._SplineStates">
            <summary>Сплайн</summary>
        </member>
        <member name="M:MathCore.Interpolation.CubicSpline.Initialize(System.Double[],System.Double[])">
            <summary>Инициализация сплайна</summary>
            <param name="X">Массив аргументов</param><param name="Y">Массив значений</param>
            <exception cref="T:System.ArgumentException">Возникает в случае, если размерности массивов не равны</exception>
        </member>
        <member name="T:MathCore.Interpolation.IInterpolator">
            <summary>Интерфейс интерполяции</summary>
        </member>
        <member name="M:MathCore.Interpolation.IInterpolator.Value(System.Double)">
            <summary>Получить значение</summary>
            <param name="x">Переменная</param>
            <returns>Значение</returns>
        </member>
        <member name="T:MathCore.Interpolation.Mapping">
            <summary>Линейный интерполятор вещественного значения</summary>
        </member>
        <member name="M:MathCore.Interpolation.Mapping.GetValue(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Линейная интерполяция</summary>
            <param name="x">Аргумент интерполируемого значения</param>
            <param name="x1">Аргумент первого значения</param>
            <param name="y1">Первое значение</param>
            <param name="x2">Аргумент второго значения</param>
            <param name="y2">Второе значение</param>
            <returns></returns>
        </member>
        <member name="T:MathCore.MNK">
            <summary>Метод наименьших квадратов</summary>
        </member>
        <member name="F:MathCore.MNK._A">
            <summary>Коэффициенты аппроксимирующего полинома</summary>
        </member>
        <member name="F:MathCore.MNK._M">
            <summary>Максимальный показатель степени многочлена аппроксимации</summary>
        </member>
        <member name="F:MathCore.MNK._XData">
            <summary>Значение абсцисс точек данных</summary>
        </member>
        <member name="F:MathCore.MNK._YData">
            <summary>Значение ординат точек данных</summary>
        </member>
        <member name="M:MathCore.MNK.#ctor(System.Double[],System.Double[],System.Int32)">
            <summary>Аппроксиматор методом наименьших квадратов</summary>
            <param name="X">Массив аргументов</param>
            <param name="Y">Массив значений</param>
            <param name="m">Степень полинома интерполяции</param>
        </member>
        <member name="T:MathCore.Interval`1">
            <summary>Интервал сравнимых величин</summary>
            <typeparam name="T">Тип сравнимых величин</typeparam>
        </member>
        <member name="M:MathCore.Interval`1.Value(`0,`0,System.Boolean)">
            <summary>Определение нового интервала</summary>
            <param name="Min">Минимальное значение</param>
            <param name="Max">Максимальное значение</param>
            <param name="IncludeLimits">Границы интервала входят?</param>
            <returns>Новый интервал в указанных границах</returns>
        </member>
        <member name="F:MathCore.Interval`1._MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="F:MathCore.Interval`1._MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="F:MathCore.Interval`1._Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="F:MathCore.Interval`1._Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="P:MathCore.Interval`1.MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="P:MathCore.Interval`1.MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="P:MathCore.Interval`1.Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="P:MathCore.Interval`1.Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="M:MathCore.Interval`1.#ctor(`0,`0)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верхняя граница интервала</param>
        </member>
        <member name="M:MathCore.Interval`1.#ctor(`0,`0,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="IncludeLimits">Включать пределы? (default:true)</param>
        </member>
        <member name="M:MathCore.Interval`1.#ctor(`0,System.Boolean,`0,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="MinInclude">Включена ли нижняя граница интервала?</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="MaxInclude">Включена ли верхняя граница интервала</param>
        </member>
        <member name="M:MathCore.Interval`1.Normalize(`0)">
            <summary>
            Метод возвращает указанное значение, если оно находится внутри интервала,
            либо соответствующую его границу, если значение входит за его пределы
            </summary>
            <param name="Value">Нормализуемое значение</param>
            <returns>
            Значение, переданное в качестве аргумента, если оно входит в интервал,
            иначе соответствующая граница интервала
            </returns>
        </member>
        <member name="M:MathCore.Interval`1.Normalize(`0@)">
            <summary>Замена значения ссылки на значение границы интервала, если значение не входит в интервал</summary>
            <param name="Value">Проверяемое значение</param>
        </member>
        <member name="M:MathCore.Interval`1.Check(`0)">
            <summary>Проверка на вхождение значения в интервал</summary>
            <param name="Value">Проверяемое значение</param>
            <returns>Истина, если значение входит в интервал</returns>
        </member>
        <member name="M:MathCore.Interval`1.IsInclude(MathCore.Interval{`0})">
            <summary>Проверка - входит ли указанный интервал в текущий</summary>
            <param name="I">Проверяемый интервал</param>
            <returns>Истина, если проверяемый интервал находится в границах текущего</returns>
        </member>
        <member name="M:MathCore.Interval`1.GetHashCode">
            <summary>Играет роль хэш-функции для определенного типа. </summary>
            <returns>Хэш-код для текущего объекта <see cref="T:System.Object"/>.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:MathCore.Interval`1.Equals(MathCore.Interval{`0})">
            <summary>Указывает, равен ли текущий объект другому объекту того же типа.</summary>
            <returns>true, если текущий объект равен параметру <paramref name="other"/>, в противном случае — false.</returns>
            <param name="other">Объект, который требуется сравнить с данным объектом.</param>
        </member>
        <member name="M:MathCore.Interval`1.Equals(System.Object)">
            <summary>
            Определяет, равен ли заданный объект <see cref="T:System.Object"/> текущему объекту <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true, если указанный объект <see cref="T:System.Object"/> равен текущему объекту <see cref="T:System.Object"/>; в противном случае — false.
            </returns>
            <param name="obj">Объект <see cref="T:System.Object"/>, который требуется сравнить с текущим объектом <see cref="T:System.Object"/>.</param>
            <exception cref="T:System.NullReferenceException">Параметр <paramref name="obj"/> имеет значение null.</exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:MathCore.Interval`1.System#ICloneable#Clone">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Interval`1.Clone">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Interval`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Interval`1.op_Implicit(MathCore.Interval{`0})~System.Predicate{`0}">
            <summary>Оператор неявного приведения типа к предикату</summary>
            <param name="I">Интервал</param>
            <returns>Предикат от вещественного типа двойной точности</returns>
        </member>
        <member name="M:MathCore.Interval`1.op_ExclusiveOr(`0,MathCore.Interval{`0})">
            <summary>Оператор проверки на вхождение величины в интервал</summary>
            <param name="Value">Проверяемая величина</param>
            <param name="I">Интервал</param>
            <returns>Истина, если величина внутри интервала</returns>
        </member>
        <member name="M:MathCore.Interval`1.op_ExclusiveOr(MathCore.Interval{`0},`0)">
            <summary>Оператор проверки на вхождение величины в интервал</summary>
            <param name="Value">Проверяемая величина</param>
            <param name="I">Интервал</param>
            <returns>Истина, если величина внутри интервала</returns>
        </member>
        <member name="T:MathCore.Interval">
            <summary>Интервал вещественных значений двойной точности</summary>
        </member>
        <member name="M:MathCore.Interval.Comparer_Length(MathCore.Interval,MathCore.Interval)">
            <summary>Метод сравнения двух интервалов</summary>
            <param name="a">Первый сравниваемый интервал</param>
            <param name="b">Второй сравниваемый интервал</param>
            <returns>1 - если первый интервал больше второго, -1 - если первый интервал меньше второго, 0 - если интервалы равны</returns>
        </member>
        <member name="F:MathCore.Interval._MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="F:MathCore.Interval._MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="F:MathCore.Interval._Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="F:MathCore.Interval._Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="P:MathCore.Interval.MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="P:MathCore.Interval.MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="P:MathCore.Interval.Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="P:MathCore.Interval.Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="P:MathCore.Interval.Length">
            <summary>Длина интервала</summary>
        </member>
        <member name="P:MathCore.Interval.Middle">
            <summary>Середина интервала</summary>
        </member>
        <member name="M:MathCore.Interval.#ctor(System.Double,System.Double)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верхняя граница интервала</param>
        </member>
        <member name="M:MathCore.Interval.#ctor(System.Double,System.Double,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="IncludeLimits">Включать пределы?</param>
        </member>
        <member name="M:MathCore.Interval.#ctor(System.Double,System.Boolean,System.Double,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="MinInclude">Включена ли нижняя граница интервала?</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="MaxInclude">Включена ли верхняя граница интервала</param>
        </member>
        <member name="M:MathCore.Interval.Normalize(System.Double)">
            <summary>
            Метод возвращает указанное значение, если оно находится внутри интервала,
            либо соответствующую его границу, если значение входит за его пределы
            </summary>
            <param name="Value">Нормализуемое значение</param>
            <returns>
            Значение, переданное в качестве аргумента, если оно входит в интервал,
            иначе соответствующая граница интервала
            </returns>
        </member>
        <member name="M:MathCore.Interval.Normalize(System.Double@)">
            <summary>Замена значения ссылки на значение границы интервала, если значение не входит в интервал</summary>
            <param name="Value">Проверяемое значение</param>
        </member>
        <member name="M:MathCore.Interval.Check(System.Double)">
            <summary>Проверка на вхождение значения в интервал</summary>
            <param name="Value">Проверяемое значение</param>
            <returns>Истина, если значение входит в интервал</returns>
        </member>
        <member name="M:MathCore.Interval.ToString(System.String,System.IFormatProvider)">
            <summary>Форматирует значение текущего экземпляра с использованием заданного формата.</summary>
            <returns>Объект <see cref="T:System.String"/> содержит значение текущего экземпляра в заданном формате.</returns>
            <param name="Format">
            Объект <see cref="T:System.String"/>, задающий используемый формат.— или — 
            Значение null для использования формата по умолчанию, определенного для типа реализации 
            <see cref="T:System.IFormattable"/>. 
            </param>
            <param name="FormatProvider">
            Объект <see cref="T:System.IFormatProvider"/>, используемый для форматирования значения.— или — 
            Значение null для получения сведений о форматировании чисел на основе текущего значения параметра языкового 
            стандарта операционной системы. 
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:MathCore.Interval.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Interval.Equals(MathCore.Interval)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Interval.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.IoC.IServiceRegistrations">
            <summary>Регистратор сервисов</summary>
        </member>
        <member name="P:MathCore.IoC.IServiceRegistrations.Item(System.Type)">
            <summary>Запрос регистрации сервиса по его типу</summary>
            <param name="ServiceType">Тип запрашиваемого сервиса</param>
        </member>
        <member name="T:MathCore.IoC.ServiceManager">
            <summary>Менеджер сервисов</summary>
        </member>
        <member name="M:MathCore.IoC.ServiceManager.Dispose">
            <inheritdoc />
        </member>
        <member name="M:MathCore.IoC.ServiceRegistrations.ServiceRegistration.Dispose">
            <inheritdoc />
        </member>
        <member name="T:MathCore.IoC.ServiceRegistrations.ServiceRegistrationMode">
            <summary>Режим регистрации сервиса</summary>
        </member>
        <member name="F:MathCore.IoC.ServiceRegistrations.ServiceRegistrationMode.Singleton">
            <summary>Режим регистрации единого объекта для всех вызовов</summary>
        </member>
        <member name="F:MathCore.IoC.ServiceRegistrations.ServiceRegistrationMode.SingleCall">
            <summary>Режим регистрации, при котором для каждого вызова будет создан новый экземпляр сервиса</summary>
        </member>
        <member name="F:MathCore.IoC.ServiceRegistrations.ServiceRegistrationMode.SingleThread">
            <summary>Режим регистрации, при котором для каждого потока будет создан единый экземпляр сервиса</summary>
        </member>
        <member name="M:MathCore.IoC.ServiceRegistrations.SingleThreadServiceRegistration`1.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.IoC.ServiceRegistrations.SingletonServiceRegistration`1.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.JSON.JSONObjectCreatorBase">
            <summary>Базовый класс генераторов JSON объектов</summary>
        </member>
        <member name="M:MathCore.JSON.JSONObjectCreatorBase.Create(System.Object)">
            <summary>Создать объект JSON</summary>
            <param name="obj">Объект-прототип, на основе которого генерируется JSON-объекта</param>
            <returns>Объект JSON</returns>
        </member>
        <member name="T:MathCore.JSON.JSONObjectCreator`1">
            <summary>Генератор JSON-объекта по объекту-прототипу</summary>
            <typeparam name="T">Тип объекта-прототипа</typeparam>
        </member>
        <member name="F:MathCore.JSON.JSONObjectCreator`1._Obj">
            <summary>Объект-прототип</summary>
        </member>
        <member name="F:MathCore.JSON.JSONObjectCreator`1._FieldsDescriptions">
            <summary>Список именованных методов получения JSON-объектов - полей из объекта-прототипа</summary>
        </member>
        <member name="M:MathCore.JSON.JSONObjectCreator`1.#ctor(`0)">
            <summary>Инициализация нового генератора JSON-объектов</summary>
            <param name="obj"></param>
        </member>
        <member name="M:MathCore.JSON.JSONObjectCreator`1.AddField(System.String,System.Func{`0,System.Object})">
            <summary>Добавить новый метод определения поля JSON-объекта из объекта-прототипа</summary>
            <param name="Name">Имя поля</param>
            <param name="Field">Метод получения JSON-объекта поля</param>
            <returns>Генератор JSON-объектов с добавленным методом</returns>
        </member>
        <member name="M:MathCore.JSON.JSONObjectCreator`1.Create">
            <summary>Создать JSON-объект из исходного объекта-прототипа</summary>
            <returns></returns>
        </member>
        <member name="M:MathCore.JSON.JSONObjectCreator`1.Create(System.Object)">
            <summary>Создать JSON-объект из указанного объекта-прототипа</summary>
            <param name="obj">Объект-прототип</param>
            <returns>JSON-объект</returns>
        </member>
        <member name="M:MathCore.JSON.JSONObjectCreator`1.Create(`0)">
            <summary>Создать JSON-объект из указанного объекта-прототипа</summary>
            <param name="obj">Объект-прототип</param>
            <returns>JSON-объект</returns>
        </member>
        <member name="M:MathCore.JSON.JSONObjectCreator`1.op_Implicit(MathCore.JSON.JSONObjectCreator{`0})~MathCore.JSON.JSONObject">
            <summary>Оператор неявного приведения типа объекта-генератора к типу JSON-объекта</summary>
            <param name="creator">Объект-генератор</param>
        </member>
        <member name="T:MathCore.JSON.JSONObject">
            <summary>Парсер структуры JSON</summary>
        </member>
        <member name="F:MathCore.JSON.JSONObject._Name">
            <summary>Имя структуры</summary>
        </member>
        <member name="F:MathCore.JSON.JSONObject._Data">
            <summary>Значение структуры</summary>
        </member>
        <member name="F:MathCore.JSON.JSONObject._Fields">
            <summary>Словарь полей структуры по ключу-имени поля</summary>
        </member>
        <member name="P:MathCore.JSON.JSONObject.Name">
            <summary>Имя структуры</summary>
        </member>
        <member name="P:MathCore.JSON.JSONObject.Data">
            <summary>Значение структуры</summary>
        </member>
        <member name="P:MathCore.JSON.JSONObject.IsComplex">
            <summary>Признак того, что структура является сложной - со вложенными полями</summary>
        </member>
        <member name="P:MathCore.JSON.JSONObject.Fields">
            <summary>Перечисление имён полей структуры</summary>
        </member>
        <member name="P:MathCore.JSON.JSONObject.Item(System.String)">
            <summary>Перечисление полей структуры по указанному имени</summary>
            <param name="Field">Имя поля структуры</param>
            <returns>Вложенные поля с указанным именем</returns>
        </member>
        <member name="M:MathCore.JSON.JSONObject.#ctor(System.String)">
            <summary>Инициализация новой структуры JSON из строкового представления</summary>
            <param name="str">Строковое представление структуры JSON</param>
        </member>
        <member name="M:MathCore.JSON.JSONObject.#ctor(System.String,System.String)">
            <summary>Инициализация новой структуры JSON из строкового представления с указанием имени</summary>
            <param name="Name">Имя структуры</param>
            <param name="str">Строковое представление структуры JSON</param>
        </member>
        <member name="M:MathCore.JSON.JSONObject.ToInt(System.Nullable{System.Int32})">
            <summary>Преобразование значения структуры к целому числу</summary>
            <param name="Default">Значение по умолчанию</param>
            <returns>Целочисленное значение структуры, либо значение по умолчанию, если преобразование невозможно</returns>
        </member>
        <member name="M:MathCore.JSON.JSONObject.ToDouble(System.Nullable{System.Double})">
            <summary>Преобразование значения структуры к вещественному числу</summary>
            <param name="Default">Значение по умолчанию</param>
            <returns>Вещественное значение структуры, либо значение по умолчанию, если преобразование невозможно</returns>
        </member>
        <member name="M:MathCore.JSON.JSONObject.ToBool(System.Nullable{System.Boolean})">
            <summary>Преобразование значения структуры к логическому значению</summary>
            <param name="Default">Значение по умолчанию</param>
            <returns>Логическое значение структуры, либо значение по умолчанию, если преобразование невозможно</returns>
        </member>
        <member name="M:MathCore.JSON.JSONObject.ToString">
            <summary>Строковое представление структуры</summary>
            <returns>Строковое представление структуры</returns>
        </member>
        <member name="M:MathCore.JSON.JSONObject.op_Implicit(MathCore.JSON.JSONObject)~System.String">
            <summary>Оператор неявного приведения структуры JSON к строковому значению</summary>
            <param name="json">Структура JSON</param>
        </member>
        <member name="M:MathCore.JSON.JSONObject.GetText(System.String,System.Int32@,System.String,System.String)">
            <summary>
            Выделение подстроки, ограниченной шаблоном начала и шаблоном окончания строки начиная с указанного смещения
            </summary>
            <param name="Str">Входная строка</param>
            <param name="Offset">
            Смещение во входной строке начала поиска - в конце работы метода соответствует месту окончания поиска
            </param>
            <param name="Open">Шаблон начала подстроки</param>
            <param name="Close">Шаблон окончания подстроки</param>
            <returns>Подстрока, заключённая между указанными шаблонами начала и окончания</returns>
            <exception cref="T:System.FormatException">
            Если шаблон завершения строки не найден, либо если количество шаблонов начала строки превышает 
            количество шаблонов окончания во входной строке
            </exception>
        </member>
        <member name="T:MathCore.LambdaComparer`1">
            <summary>Объект, представляющий метод сравнения двух объектов типа <typeparamref name="T"/>, задаваемый lambda-выражением</summary>
            <typeparam name="T">Тип сравниваемых объектов</typeparam>
        </member>
        <member name="M:MathCore.LambdaComparer`1.Compare(`0,`0)">
            <summary>Сравнивает два объекта и возвращает значение, показывающее, что один объект меньше или больше другого или равен ему</summary>
            <param name="x">Первый сравниваемый объект.</param>
            <param name="y">Второй сравниваемый объект.</param>
            <returns>
            Значение Условие Меньше нуля<paramref name="x"/> меньше, чем <paramref name="y"/>.Нуль<paramref name="x"/> равно <paramref name="y"/>.Больше нуля<paramref name="x"/> больше, чем <paramref name="y"/>.
            </returns>
        </member>
        <member name="M:MathCore.LambdaComparer`1.System#Collections#IComparer#Compare(System.Object,System.Object)">
            <inheritdoc />
        </member>
        <member name="P:MathCore.LambdaDictionary`2.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:MathCore.LambdaDictionary`2.Count">
            <inheritdoc />
        </member>
        <member name="P:MathCore.LambdaDictionary`2.Keys">
            <inheritdoc />
        </member>
        <member name="P:MathCore.LambdaDictionary`2.Values">
            <inheritdoc />
        </member>
        <member name="P:MathCore.LambdaDictionary`2.Item(`0)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaDictionary`2.Add(`0,`1)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaDictionary`2.Clear">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaDictionary`2.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaDictionary`2.ContainsKey(`0)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaDictionary`2.TryGetValue(`0,`1@)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaDictionary`2.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:MathCore.LambdaEnumerable`1">
            <summary>Настраиваемое перечисление</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:MathCore.LambdaEnumerable`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaEnumerable`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaEqualityComparer`1.Equals(`0,`0)">
            <summary>Определяет, равны ли два указанных объекта.</summary>
            <returns>Значение true, если указанные объекты равны; в противном случае — значение false.</returns>
            <param name="x">Первый сравниваемый объект типа <typeparamref name="T"/>.</param>
            <param name="y">Второй сравниваемый объект типа <typeparamref name="T"/>.</param>
        </member>
        <member name="M:MathCore.LambdaEqualityComparer`1.GetHashCode(`0)">
            <summary>Возвращает хэш-код указанного объекта.</summary>
            <returns>Хэш-код указанного объекта.</returns>
            <param name="obj">Объект <see cref="T:System.Object"/>, для которого должен быть возвращен хэш-код.</param>
            <exception cref="T:System.ArgumentNullException">Тип <paramref name="obj"/> является ссылочным типом, значением <paramref name="obj"/> является null.</exception>
        </member>
        <member name="M:MathCore.LambdaFormatter`1.GetFormat(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaFormatter`1.Format(System.String,System.Object,System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.LambdaKeyedCollection`2">
            <summary>Коллекция, ключи которой определяются указанным методом на основе значений элементов</summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип значения элемента</typeparam>
        </member>
        <member name="F:MathCore.LambdaKeyedCollection`2._KeyExtractor">
            <summary>Метод определения ключа элемента</summary>
        </member>
        <member name="M:MathCore.LambdaKeyedCollection`2.#ctor(System.Func{`1,`0})">
            <summary>Инициализация новой коллекции, ключи которой определяются на основе значений элементов</summary>
            <param name="KeyExtractor">Метод определения ключа элемента</param>
        </member>
        <member name="M:MathCore.LambdaKeyedCollection`2.#ctor(System.Func{`1,`0},System.Collections.Generic.IEnumerable{`1})">
            <summary>Инициализация новой коллекции, ключи которой определяются на основе значений элементов</summary>
            <param name="KeyExtractor">Метод определения ключа элемента</param>
            <param name="Values">Коллекция элементов</param>
        </member>
        <member name="M:MathCore.LambdaKeyedCollection`2.GetKeyForItem(`1)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.LambdaProperty`1">
            <summary>Класс объектов-свойств, определяемых методами установки и чтения значения</summary>
        </member>
        <member name="F:MathCore.LambdaProperty`1._GetMethod">
            <summary>Метод получения значения свойства</summary>
        </member>
        <member name="F:MathCore.LambdaProperty`1._SetMethod">
            <summary>Метод установки значения свойства</summary>
        </member>
        <member name="P:MathCore.LambdaProperty`1.GetMethod">
            <summary>Метод получения значения свойства</summary>
        </member>
        <member name="P:MathCore.LambdaProperty`1.SetMethod">
            <summary>Метод установки значения свойства</summary>
        </member>
        <member name="P:MathCore.LambdaProperty`1.CanRead">
            <summary>Признак возможности чтения значения свойства (если задан метод чтения)</summary>
        </member>
        <member name="P:MathCore.LambdaProperty`1.CanWrite">
            <summary>Признак возможности устанавливать значение свойства (если задан метод записи)</summary>
        </member>
        <member name="P:MathCore.LambdaProperty`1.Value">
            <summary>Значение свойства</summary>
        </member>
        <member name="M:MathCore.LambdaProperty`1.#ctor(System.Func{`0},System.Action{`0})">
            <summary>Новое лямбда свойство</summary>
            <param name="GetMethod">Метод чтения значения</param>
            <param name="SetMethod">Метод записи значения</param>
        </member>
        <member name="M:MathCore.LambdaProperty`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaProperty`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaProperty`1.Equals(MathCore.LambdaProperty{`0})">
            <summary>Указывает, равен ли текущий объект другому объекту того же типа.</summary>
            <returns>true, если текущий объект равен параметру <paramref name="other"/>, в противном случае — false.</returns>
            <param name="other">Объект, который требуется сравнить с данным объектом.</param>
        </member>
        <member name="M:MathCore.LambdaProperty`1.GetHashCode">
            <summary>Играет роль хэш-функции для определенного типа. </summary>
            <returns>Хэш-код для текущего объекта <see cref="T:System.Object"/>.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:MathCore.LambdaToString">
            <summary>Форматтер строки с помощью лямбда-выражения</summary>
        </member>
        <member name="M:MathCore.LambdaToString.#ctor(System.Func{System.String})">
            <summary>Новый лямбда-форматтер</summary>
            <param name="CreateMethod">Метод генерации строки</param>
        </member>
        <member name="M:MathCore.LambdaToString.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaToStringObjectIndicator`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LamdaComparer`1.Equals(`0,`0)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LamdaComparer`1.GetHashCode(`0)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.MathParser.BlockTerm">
            <summary>Элемент мат.выражения - блок со скобками</summary>
        </member>
        <member name="F:MathCore.MathParser.BlockTerm._OpenBracket">
            <summary>Строковое значение открывающейся скобки</summary>
        </member>
        <member name="F:MathCore.MathParser.BlockTerm._CloseBracket">
            <summary>Строковое значение закрывающейся скобки</summary>
        </member>
        <member name="F:MathCore.MathParser.BlockTerm._Terms">
            <summary>Массив элементов подвыражения</summary>
        </member>
        <member name="P:MathCore.MathParser.BlockTerm.OpenBracket">
            <summary>Строковое значение открывающейся скобки</summary>
        </member>
        <member name="P:MathCore.MathParser.BlockTerm.CloseBracket">
            <summary>Строковое значение закрывающейся скобки</summary>
        </member>
        <member name="P:MathCore.MathParser.BlockTerm.Terms">
            <summary>Массив элементов подвыражения</summary>
        </member>
        <member name="M:MathCore.MathParser.BlockTerm.#ctor(System.String)">
            <summary>Новый блок математического выражения</summary>
            <param name="Str">Строковое значение блока</param>
        </member>
        <member name="M:MathCore.MathParser.BlockTerm.#ctor(System.String,System.String,System.String)">
            <summary>Новый блок выражения</summary>
            <param name="OpenBracket">Открывающаяся скобка</param>
            <param name="Str">Строковое значение блока</param>
            <param name="CloseBracket">Закрывающаяся скобка</param>
        </member>
        <member name="M:MathCore.MathParser.BlockTerm.GetNumberString(System.String,System.Int32@)">
            <summary>Получить цифровую строку</summary>
            <param name="Str">Исследуемая строка</param>
            <param name="pos">Исходная позиция в строке</param>
            <returns>Строка цифрового значения</returns>
        </member>
        <member name="M:MathCore.MathParser.BlockTerm.GetNameString(System.String,System.Int32@)">
            <summary>Получить имя из строки</summary>
            <param name="Str">Исходная строка</param>
            <param name="pos">Положение в строке</param>
            <returns>Строка имени</returns>
        </member>
        <member name="M:MathCore.MathParser.BlockTerm.GetTerms(System.String)">
            <summary>Получить список элементов математического выражения из строки</summary>
            <param name="Str">Строковое представление математического выражения</param>
            <returns>Массив элементов математического выражения</returns>
        </member>
        <member name="M:MathCore.MathParser.BlockTerm.ToString">
            <summary>Преобразование в строковое представление</summary>
            <returns>Строковое представление</returns>
        </member>
        <member name="M:MathCore.MathParser.BlockTerm.GetSubTree(MathCore.MathParser.ExpressionParser,MathCore.MathParser.MathExpression)">
            <summary>Получить корень поддерева выражений</summary>
            <param name="Parser">Парсер выражения</param>
            <param name="Expression">Математическое выражение</param>
            <returns>Корень поддерева</returns>
        </member>
        <member name="T:MathCore.MathParser.Bracket">
            <summary>Скобки</summary>
        </member>
        <member name="P:MathCore.MathParser.Bracket.NewRound">
            <summary>Круглые скобки</summary>
        </member>
        <member name="P:MathCore.MathParser.Bracket.NewRect">
            <summary>Квадратные скобки</summary>
        </member>
        <member name="P:MathCore.MathParser.Bracket.NewFigure">
            <summary>Фигурные скобки</summary>
        </member>
        <member name="P:MathCore.MathParser.Bracket.Start">
            <summary>Открывающая скобка</summary>
        </member>
        <member name="P:MathCore.MathParser.Bracket.Stop">
            <summary>Закрывающая скобка</summary>
        </member>
        <member name="M:MathCore.MathParser.Bracket.#ctor(System.String,System.String)">
            <summary>Скобки</summary>
            <param name="Start">Строка открывающей скобки</param>
            <param name="Stop">Строка закрывающей скобки</param>
        </member>
        <member name="M:MathCore.MathParser.Bracket.Equals(MathCore.MathParser.Bracket)">
            <summary>Проверка на эквивалентность другим скобкам</summary>
            <param name="other">Проверяемые на эквивалентность скобки</param>
            <returns>Истина, если проверяемые скобки эквивалентны данным</returns>
        </member>
        <member name="M:MathCore.MathParser.Bracket.Equals(System.Object)">
            <summary>Проверка на эквивалентность</summary>
            <param name="obj">Проверяемый объект</param>
            <returns>Истина, если объект - скобки и вид скобок совпадает</returns>
        </member>
        <member name="M:MathCore.MathParser.Bracket.GetHashCode">
            <summary>Получить хэш-код</summary>
            <returns>Хэш-код</returns>
        </member>
        <member name="M:MathCore.MathParser.Bracket.Clone">
            <summary>Клонирование скобок</summary>
            <returns>Клон скобок</returns>
        </member>
        <member name="M:MathCore.MathParser.Bracket.ToString">
            <summary>Строковое представление скобок</summary>
            <returns>Строковое представление</returns>
        </member>
        <member name="M:MathCore.MathParser.Bracket.Surround(System.String)">
            <summary>Разместить текст в скобках</summary>
            <param name="str">Размещаемый текст</param>
            <returns>Текст в скобках</returns>
        </member>
        <member name="T:MathCore.MathParser.CharTerm">
            <summary>Символьный элемент математического выражения</summary>
        </member>
        <member name="P:MathCore.MathParser.CharTerm.Value">
            <summary>Символьное значение элемента</summary>
        </member>
        <member name="M:MathCore.MathParser.CharTerm.#ctor(System.Char)">
            <summary>Новый символьный элемент</summary>
            <param name="c">Символьное значение элемента</param>
        </member>
        <member name="M:MathCore.MathParser.CharTerm.GetSubTree(MathCore.MathParser.ExpressionParser,MathCore.MathParser.MathExpression)">
            <summary>Получить поддерево</summary>
            <param name="Parser">Парсер мат.выражения</param>
            <param name="Expression">Математическое выражение</param>
            <returns>Результат вызова метода Parser.GetOperatorNode(Value)</returns>
        </member>
        <member name="T:MathCore.MathParser.ConstantsCollection">
            <summary>Коллекция констант</summary>
        </member>
        <member name="F:MathCore.MathParser.ConstantsCollection._Expression">
            <summary>Ссылка на выражение</summary>
        </member>
        <member name="F:MathCore.MathParser.ConstantsCollection._Items">
            <summary>Элементы коллекции</summary>
        </member>
        <member name="P:MathCore.MathParser.ConstantsCollection.Count">
            <summary>Количество элементов коллекции</summary>
        </member>
        <member name="P:MathCore.MathParser.ConstantsCollection.Item(System.String)">
            <summary>Итератор констант по имени</summary>
            <param name="Name">Имя константы</param>
            <returns>Константа с указанным именем</returns>
        </member>
        <member name="M:MathCore.MathParser.ConstantsCollection.#ctor(MathCore.MathParser.MathExpression)">
            <summary>Инициализация новой коллекции констант</summary>
            <param name="Expression">Математическое выражение, которому принадлежит коллекция</param>
        </member>
        <member name="M:MathCore.MathParser.ConstantsCollection.Add(MathCore.MathParser.ExpressionVariable)">
            <summary>Добавить элемент в коллекцию</summary>
            <param name="Constant">Добавляемое значение, как константа</param>
        </member>
        <member name="M:MathCore.MathParser.ConstantsCollection.GetNames">
            <summary>Получить имена констант коллекции</summary>
            <returns>Перечисление имён констант коллекции</returns>
        </member>
        <member name="M:MathCore.MathParser.ConstantsCollection.System#Collections#Generic#IEnumerable{MathCore#MathParser#ExpressionVariable}#GetEnumerator">
            <summary>Получить перечислитеь констант коллекции</summary>
            <returns>Перечислитель констант</returns>
        </member>
        <member name="M:MathCore.MathParser.ConstantsCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>Получить перечислитеь констант коллекции</summary>
            <returns>Перечислитель констант</returns>
        </member>
        <member name="M:MathCore.MathParser.DifferentialOperator.#ctor">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MathParser.DifferentialOperator.GetValue(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MathParser.DifferentialOperator.Compile(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MathParser.DifferentialOperator.Compile(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression,System.Linq.Expressions.ParameterExpression[])">
            <inheritdoc />
        </member>
        <member name="T:MathCore.MathParser.EventExpressionVariable">
            <summary>Событийная переменная</summary>
            <remarks>Переменная математического выражения, значение которой определяется через генерацию события</remarks>
        </member>
        <member name="E:MathCore.MathParser.EventExpressionVariable.Call">
            <summary>Событие запроса значения переменной</summary>
        </member>
        <member name="M:MathCore.MathParser.EventExpressionVariable.OnCall(System.EventArgs{System.Double})">
            <summary>Метод генерации события</summary>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="F:MathCore.MathParser.EventExpressionVariable._EventArg">
            <summary>Аргумент события</summary>
        </member>
        <member name="F:MathCore.MathParser.EventExpressionVariable._ClearAtCall">
            <summary>Флаг предварительной очистки значения аргумента события</summary>
        </member>
        <member name="P:MathCore.MathParser.EventExpressionVariable.Value">
            <summary>Значение переменной</summary>
        </member>
        <member name="P:MathCore.MathParser.EventExpressionVariable.IsPrecomputable">
            <summary>Признак предвычислимости всегда = false</summary>
        </member>
        <member name="P:MathCore.MathParser.EventExpressionVariable.ClearAtCall">
            <summary>Флаг предварительной очистки значения аргумента события</summary>
        </member>
        <member name="M:MathCore.MathParser.EventExpressionVariable.#ctor">
            <summary>Инициализация новой событийной переменной</summary>
        </member>
        <member name="M:MathCore.MathParser.EventExpressionVariable.#ctor(System.String)">
            <summary>Инициализация новой событийной переменной</summary>
            <param name="Name">Имя переменной</param>
        </member>
        <member name="M:MathCore.MathParser.EventExpressionVariable.GetValue">
            <summary>Получение значения переменной</summary>
            <returns>Значение переменой</returns>
        </member>
        <member name="M:MathCore.MathParser.EventExpressionVariable.Clone">
            <summary>Метод клонирования событийной переменной</summary>
            <returns>Клонированная событийная переменная</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionFunction">
            <summary>функция в структуре математического выражения</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionFunction.Delegate">
            <summary>Делегат функции</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionFunction.Arguments">
            <summary>Массив имён аргументов</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionFunction.#ctor(System.String,System.String[])">
            <summary>Инициализация новой функции структуры математического выражения по сигнатуре</summary>
            <param name="Name">Имя функции</param>
            <param name="Arguments">Список имён аргументов</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionFunction.GetValue(System.Double[])">
            <summary>Метод получения значения функции по массиву значений её аргументов</summary>
            <param name="arguments">Массив аргументов функции</param>
            <returns>Значение функции</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionFunction.IsEqualSignature(System.String,System.Int32)">
            <summary>Проверка на эквивалентность сигнатуре</summary>
            <param name="sName">Имя функции</param>
            <param name="ArgumentsCount">Количество аргументов</param>
            <returns>Истина, если сигнатура соответствует функции</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionFunction.IsEqualSignature(System.String,System.String[])">
            <summary>Проверка на эквивалентность сигнатуре</summary>
            <param name="sName">Имя функции</param>
            <param name="Arguments">Массив имён аргументов</param>
            <returns>Истина, если сигнатура соответствует функции</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionFunction.GetValue">
            <summary>Метод получения значения функции. В общем виде не поддерживается.</summary>
            <returns>Значение функции</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionFunction.Clone">
            <summary>Клонирование функции</summary>
            <returns>Клон функции</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionItem">
            <summary>Элемент математического выражения</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionItem.Name">
            <summary>Имя</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionItem.#ctor">
            <summary>Инициализация нового элемента математического выражения</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionItem.#ctor(System.String)">
            <summary>Инициализация нового элемента математического выражения</summary><param name="Name">Имя элемента</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionItem.GetValue">
            <summary>Метод определения значения</summary><returns>Численное значение элемента выражения</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionOperator">
            <summary>Оператор</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionOperator.GetValue">
            <summary>Получить значение</summary>
            <returns>Значение оператора</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionParser">
            <summary>Парсер математических выражений</summary>
        </member>
        <member name="E:MathCore.MathParser.ExpressionParser.NewNodeAdded">
            <summary>Событие возникает при добавлении нового узла в дерево выражения</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.OnNewNodeAdded(System.EventArgs{MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode})">
            <summary>При добавлении нового узла в дерево выражения</summary>
            <param name="e">Аргумент события, содержащий добавляемый узел</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.OnNewNodeAdded(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode@)">
            <summary>Обработка очередного добавляемого в дерево узла</summary>
            <param name="NewNode">Новый добавляемый узел дерева выражения</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.ProcessNewNode(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode@)">
            <summary>Обработка нового узла дерева выражения</summary>
            <param name="NewNode">Новый добавляемый узел</param>
        </member>
        <member name="E:MathCore.MathParser.ExpressionParser.StringPreprocessing">
            <summary>Событие предобработки входящей строки</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.OnStringPreprocessing(System.EventArgs{System.String})">
            <summary>Генерация события предобработки входящей строки</summary>
            <param name="args">Аргумент события, содержащий обрабатываемую строку</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.OnStringPreprocessing(System.String@)">
            <summary>Генерация события предобработки входящей строки</summary>
            <param name="StrExpression">Обрабатываемая строка</param>
        </member>
        <member name="T:MathCore.MathParser.ExpressionParser.FindFunctionEventArgs">
            <summary>Аргумент события обнаружения функции</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionParser.FindFunctionEventArgs.Name">
            <summary>Имя обнаруженной функции</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionParser.FindFunctionEventArgs.Arguments">
            <summary>Массив имён аргументов функции</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionParser.FindFunctionEventArgs.ArgumentCount">
            <summary>Количество аргументов функции</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionParser.FindFunctionEventArgs.Function">
            <summary>Делегат функции, который надо использовать при её вычислении</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.FindFunctionEventArgs.#ctor(System.String,System.String[])">
            <summary>Инициализация аргумента события обнаружения функции</summary>
            <param name="Name">Имя функции</param>
            <param name="Arguments">Массив имён аргументов функции</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.FindFunctionEventArgs.SignatureEqual(System.String,System.Int32)">
            <summary>Проверка на совпадение сигнатуры функции по имени и числу переменных</summary>
            <param name="name">Имя проверяемой функции</param>
            <param name="ArgumentsCount">Число переменных</param>
            <returns></returns>
        </member>
        <member name="E:MathCore.MathParser.ExpressionParser.FindFunction">
            <summary>Событие, возникающее в процессе разбора математического выражения при обнаружении функции</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.OnFindFunction(MathCore.MathParser.ExpressionParser.FindFunctionEventArgs)">
            <summary>Обработчик события обнаружения функции в процессе разбора выражения</summary>
            <param name="Args">Аргументы события, содержащие имя функции, имена аргументов и делегат метода функции</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.OnFunctionFind(System.String,System.String[])">
            <summary>Обработчик события обнаружения функции в процессе разбора выражения</summary>
            <param name="Name">Имя функции</param>
            <param name="Arguments">Аргументы функции</param>
            <returns>Делегат функции</returns>
        </member>
        <member name="E:MathCore.MathParser.ExpressionParser.VariableProcessing">
            <summary>Событие обработки переменных при разборе мат.выражений</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.OnVariableProcessing(System.EventArgs{MathCore.MathParser.ExpressionVariable})">
            <summary> Обработка обнаруженной переменной</summary>
            <param name="e">Обнаруженная переменная</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.OnVariableProcessing(MathCore.MathParser.ExpressionVariable)">
            <summary> Обработка обнаруженной переменной</summary>
            <param name="Variable">Обнаруженная переменная</param>
        </member>
        <member name="F:MathCore.MathParser.ExpressionParser._ExcludeCharsSet">
            <summary>Множество запрещённых символов</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionParser._Constants">
            <summary>Словарь констант</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionParser.ExcludeCharsSet">
            <summary>Множество запрещённых символов</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionParser.ExpressionSeparator">
            <summary>Разделитель выражений (по умолчанию ';')</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionParser.DecimalSeparator">
            <summary>Разделитель целой части и мантисcы десятичного числа</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionParser.Constants">
            <summary>Константы</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.#ctor">
            <summary>Парсер математических выражений</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.StrPreprocessing(System.String@)">
            <summary>Предварительная обработка входного строкового выражения</summary>
            <param name="Str">Обрабатываемая строка</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.Parse(System.String)">
            <summary>Разобрать строку математического выражения</summary>
            <param name="StrExpression">Строковое представление математического выражения</param>
            <returns>Математическое выражение</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.ProcessVariables(MathCore.MathParser.MathExpression)">
            <summary>Обработка переменных</summary>
            <param name="Expression">Обрабатываемое математическое выражение</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.ProcessFunctions(MathCore.MathParser.MathExpression)">
            <summary>Обработка функций</summary>
            <param name="Expression">Обрабатываемое математическое выражение</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.GetOperatorNode(System.Char)">
            <summary>Метод определения узла дерева, реализующего оператор</summary>
            <param name="Name">Имя оператора</param>
            <returns>Узел дерева оператора</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.GetFunctional(System.String)">
            <summary>Метод определения функционала по имени</summary>
            <param name="Name">Имя функционала</param>
            <returns>Функционал</returns>
            <exception cref="T:System.NotSupportedException">Возникает для неопределённых имён функционалов</exception>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.GetRoot(MathCore.MathParser.Term[],MathCore.MathParser.MathExpression)">
            <summary>Метод извлечения корня дерева из последовательности элементов математического выражения</summary>
            <param name="Group">группа элементов математического выражения</param>
            <param name="MathExpression">Ссылка на математическое выражение</param>
            <returns>Корень дерева мат.выражения</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.Combine(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Комбинация предыдущего и текущего узлов дерева</summary>
            <param name="Last">Предыдущий узел дерева (уже интегрированный в дерево)</param>
            <param name="Node">Текущий узел, который надо вставить в дерево</param>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.ExpressionTree">
            <summary>Дерево выражения</summary>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.ExpressionTree.BypassingType">
            <summary>Метод обхода дерева</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionTrees.ExpressionTree.BypassingType.LeftRightRoot">
            <summary>Левое поддерево, правое поддерево, корень</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionTrees.ExpressionTree.BypassingType.LeftRootRight">
            <summary>Левое поддерево, корень, правое поддерево</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionTrees.ExpressionTree.BypassingType.RootLeftRight">
            <summary>Корень, левое поддерево, правое поддерево</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionTrees.ExpressionTree.BypassingType.RightLeftRoot">
            <summary>Правое поддерево, левое поддерево, корень</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionTrees.ExpressionTree.BypassingType.RightRootLeft">
            <summary>Правое поддерево, корень, левое поддерево</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionTrees.ExpressionTree.BypassingType.RootRightLeft">
            <summary>Корень, правое поддерево, левое поддерево</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.ExpressionTree.Root">
            <summary>Корень</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.ExpressionTree.#ctor">
            <summary>Инициализация нового дерева математического выражения</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.ExpressionTree.#ctor(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового дерева математического выражения</summary><param name="Root">Узел - корень дерева</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.ExpressionTree.Clear">
            <summary>Очистить дерево</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.ExpressionTree.Remove(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Удалить узел</summary><param name="Node">Удаляемый узел</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.ExpressionTree.Swap(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Заменить узел</summary><param name="OldNode">Исходный узел</param><param name="NewNode">Новый узел</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.ExpressionTree.MoveParentDown(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Переместить узел вниз</summary><param name="Node">Перемещаемый узел</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.ExpressionTree.Bypass(MathCore.MathParser.ExpressionTrees.ExpressionTree.BypassingType)">
            <summary>Обойти дерево</summary><param name="type">Способ обхода</param><returns>Перечисление узлов дерева по указанному способу обхода</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.ExpressionTree.Dispose">
            <summary>Уничтожить дерево</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.ExpressionTree.ToString">
            <summary>Возвращает объект <see cref="T:System.String"/>, который представляет текущий объект <see cref="T:System.Object"/>.</summary>
            <returns>Объект <see cref="T:System.String"/>, представляющий текущий объект <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.ExpressionTree.Clone">
            <summary>Клонировать дерево</summary><returns>Клон дерева</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.ExpressionTree.System#ICloneable#Clone">
            <summary>Клонировать дерево</summary><returns>Клон дерева</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.ExpressionTree.GetEnumerator">
            <summary>Получить перечислитель узлов дерева по методу ЛКП</summary><returns>Перечислитель узлов дерева по методу ЛКП</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.AdditionOperatorNode">
            <summary>Узел дерева выражений, реализующий оператор сложения</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.AdditionOperatorNode.#ctor">
            <summary>Новый оператор сложения</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.AdditionOperatorNode.Compute">
            <summary>Вычисление узла</summary>
            <returns>Сумма поддеревьев</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.AdditionOperatorNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Linq.Expression.Add()</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.AdditionOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла</summary>
            <param name="Parameters">Массив параметров выражения</param>
            <returns>Linq.Expression.Add()</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.AdditionOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Полный клон узла с клонами поддеревьев</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.AndOperatorNode">
            <summary>Узел дерева мат.выражения, реализующий оператор ленивого И</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.AndOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора ленивого И</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.AndOperatorNode.Compute">
            <summary>Вычислить значение поддерева</summary>
            <returns>Численное значение поддерева</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.AndOperatorNode.LogicCompile">
            <summary>Компиляция логики узла</summary>
            <returns>Скомпилированное логическое выражение, реализующее операцию И</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.AndOperatorNode.LogicCompile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция логики узла</summary>
            <param name="Parameters">Параметры компиляции</param>
            <returns>Скомпилированное логическое выражение, реализующее операцию И</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.AndOperatorNode.Clone">
            <summary>Клонирование поддерева</summary>
            <returns>Клон поддерева</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.CharNode">
            <summary>Символьный узел дерева математического выражения</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.CharNode.Value">
            <summary>Значение символа узла</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.CharNode.#ctor">
            <summary>Инициализация нового строкового узла</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.CharNode.#ctor(System.Char)">
            <summary>Инициализация нового строкового узла</summary>
            <param name="value">Значение узла</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.CharNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.CharNode.ToString">
            <summary>Строковое представление узла</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.CharNode.op_Implicit(System.Char)~MathCore.MathParser.ExpressionTrees.Nodes.CharNode">
            <summary>Оператор неявного преобразования строки к типу строкового узла</summary>
            <param name="value">Строковое значение</param>
            <returns>Символьный узел</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.CharNode.op_Implicit(MathCore.MathParser.ExpressionTrees.Nodes.CharNode)~System.Char">
            <summary>Оператор неявного преобразования строкового узла к символьному типу</summary>
            <param name="node">Символьный узел</param>
            <returns>Значение Символьного узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.ComputedBracketNode">
            <summary>Узел дерева мат.выражения, реализующий скобки с возможностью вычисления</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionTrees.Nodes.ComputedBracketNode._Bracket">
            <summary>Скобки</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ComputedBracketNode.Bracket">
            <summary>Скобки</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ComputedBracketNode.#ctor(MathCore.MathParser.Bracket,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Вычислимый блочный узел дерева</summary>
            <param name="bracket">Скобки</param>
            <param name="Node">Узел-содержимое</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ComputedBracketNode.Compute">
            <summary>Вычислить значение узла</summary>
            <returns>Значение вложенного узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ComputedBracketNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Компиляция содержимого узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ComputedBracketNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла с параметрами</summary>
            <param name="Parameters">Список параметров выражения</param>
            <returns>Компиляция вложенного узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ComputedBracketNode.Clone">
            <summary>Клон узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ComputedBracketNode.ToString">
            <summary>Строковое представление узла</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.ComputedNode">
            <summary>Вычислимый узел дерева математического выражения</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ComputedNode.Compute">
            <summary>Вычислить значение поддерева</summary>
            <returns>Численное значение поддерева</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ComputedNode.Compile">
            <summary>Скомпилировать в выражение</summary>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ComputedNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Скомпилировать в выражение</summary>
            <param name="Parameters">Массив параметров</param>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.ConstValueNode">
            <summary>Узел дерева, хранящий константное значение</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionTrees.Nodes.ConstValueNode._Value">
            <summary>Значение узла</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ConstValueNode.IsPrecomputable">
            <summary>Флаг возможности получения значения без вычисления. Всегда = true</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ConstValueNode.Value">
            <summary>Значение узла. Не поддерживает присвоение</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ConstValueNode.#ctor">
            <summary>Инициализация константного узла</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ConstValueNode.#ctor(System.Double)">
            <summary>Инициализация константного узла</summary>
            <param name="Value">Значение узла</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ConstValueNode.#ctor(System.Int32)">
            <summary>Инициализация константного узла</summary>
            <param name="Value">Значение узла</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ConstValueNode.Compute">
            <summary>Вычислить значение поддерева</summary>
            <returns>Численное значение поддерева</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ConstValueNode.Compile">
            <summary>Скомпилировать в выражение</summary>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ConstValueNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Скомпилировать в выражение</summary>
            <param name="Parameters">Массив параметров</param>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ConstValueNode.Clone">
            <summary>Клонирование поддерева</summary>
            <returns>Клон поддерева</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.DivisionOperatorNode">
            <summary>Узел дерева мат.выражения, реализующий оператор деления</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.DivisionOperatorNode.#ctor">
            <summary>Инициализация узла оператора деления</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.DivisionOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>Значение узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.DivisionOperatorNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Скомпилированное выражение узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.DivisionOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла с параметрами</summary>
            <param name="Parameters">Список параметров выражения</param>
            <returns>Скомпилированное выражение узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.DivisionOperatorNode.Clone">
            <summary>Строковое представление узла</summary>
            <returns>Строковое представление</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode">
            <summary>Узел дерева мат.выражения, реализующий оператор равенства</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.GetAbsMethodCall(System.Linq.Expressions.Expression)">
            <summary>Получить выражение вызова метода определения модуля числа из класса Math</summary>
            <param name="x">Параметр выражения</param>
            <returns>Выражение <see cref="T:System.Linq.Expressions.Expression"/>, вызывающее метод Math.Abs с параметром x</returns>
        </member>
        <member name="F:MathCore.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.__Epsilon">
            <summary>Точность вычисления равенства для чисел с плавающей точкой</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.Epsilon">
            <summary>Точность вычисления равенства для чисел с плавающей точкой</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора равенства</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.#ctor(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового узла оператора равенства</summary>
            <param name="Left">Левое поддерево выражения</param>
            <param name="Right">Правое поддерево выражения</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.Comparer(System.Double,System.Double)">
            <summary>Метод сравнения</summary>
            <param name="x">Первое значение</param>
            <param name="y">Второе значение</param>
            <returns>0 - если разность между x и y по модулю меньше Epsilon и 1 во всех остальных случаях</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>0 - если разность между x и y по модулю меньше Epsilon и 1 во всех остальных случаях</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.LogicCompile">
            <summary>Компиляция логики узла</summary>
            <returns>Скомпилированное логическое выражение, реализующее операцию сравнения Равенство</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.LogicCompile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция логики узла</summary>
            <param name="Parameters">Параметры компиляции</param>
            <returns>Скомпилированное логическое выражение, реализующее операцию сравнения Равенство</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode">
            <summary>Узел дерева вычислений</summary>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ParentsIterator">
            <summary>Перечислитель предков узла</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ParentsIterator.Node">
            <summary>Исходный узел</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ParentsIterator.Item(System.Int32)">
            <summary>Итератор предков узла, где узел с индексом 0 - первый предок узла</summary>
            <param name="i">Номер предка</param>
            <returns>Предок указанного поколения</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ParentsIterator.#ctor(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Новый итератор предков узла</summary>
            <param name="Node">Обрабатываемый узел</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ParentsIterator.System#Collections#Generic#IEnumerable{MathCore#MathParser#ExpressionTrees#Nodes#ExpressionTreeNode}#GetEnumerator">
            <summary>Получить перечислитель предков узла</summary>
            <returns>Перечислитель предков узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ParentsIterator.System#Collections#IEnumerable#GetEnumerator">
            <summary>Получить перечислитель</summary>
            <returns>Перечислитель</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ParentsIterator.GetParentsEnumerable">
            <summary>Метод получения перечисления предков узла</summary>
            <returns>Перечисление предков узла</returns>
        </member>
        <member name="F:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode._Left">
            <summary>Узел левого поддерева</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode._Right">
            <summary> Узел правого поддерева</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.IsPrecomputable">
            <summary>Признак возможности получения тривиального значения</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.IsRoot">
            <summary>Является ли узел дерева корнем?</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.IsLeftSubtree">
            <summary>Признак - является ли текущий узел левым поддеревом</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.IsRightSubtree">
            <summary>Признак - является ли текущий узел правым поддеревом</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Parent">
            <summary>Ссылка на предка узла</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Left">
            <summary>Левое поддерево</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Right">
            <summary>Правое поддерево</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.RightNodes">
            <summary>Перечисление правых узлов правого поддерева включая корень</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.LeftNodes">
            <summary>Перечисление левых узлов левого поддерева включая корень</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Parents">
            <summary>Перечислитель предков узла</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Root">
            <summary>Ссылка на корень дерева</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Depth">
            <summary>Глубина положения узла в дереве</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.LastLeftChild">
            <summary>Самый левый дочерний узел, либо текущий</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.LastRightChild">
            <summary>Самый правый дочерний узел, либо текущий</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Item(System.String)">
            <summary>Доступ к элементам узла по указанному пути</summary>
            <param name="path">Путь к элементам узла Пример:.\.\l\r\r\l  ..\l\r\r</param>
            <returns>Элемент узла, выбранный по указанному пути</returns>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Item(System.Func{MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode})">
            <summary>Доступ к дочерним элементам узла с помощью метода выбора</summary>
            <param name="ChildSelector">Метод выбора элементов узла</param>
            <returns>Перечисление дочерних элементов по указанному методу</returns>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Item(System.Func{MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode})">
            <summary> Итератор элементов узла методом выборки</summary>
            <param name="Selector">Метод выборки узлов относительно текущего</param>
            <returns>Перечисление узлов по указанному методу</returns>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Path">
            <summary>Путь к узлу</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Bypassing(MathCore.MathParser.ExpressionTrees.ExpressionTree.BypassingType)">
            <summary>Метод обхода дерева</summary>
            <param name="type">Тип обхода дерева</param>
            <returns>Перечисление элементов дерева</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.GetChilds">
            <summary>Перечисление дочерних элементов дерева</summary>
            <returns>Перечисление дочерних элементов дерева</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.SwapToChild(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Поменять узел местами с дочерним</summary>
            <param name="Parent">Материнский узел</param>
            <param name="Child">Дочерний узел</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Swap(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Подменить узел А узлом В</summary>
            <param name="A">Замещаемый узел</param>
            <param name="B">Подменяемый узел</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.SwapTo(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Заменить узел на указанный</summary>
            <param name="Node">Узел, на который производится замена</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Remove">
            <summary>Удалить узел с перекоммутацией ссылок</summary>
            <returns>Если удаляется корень, то левое поддерево, иначе ссылка не предка узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.GetNextLeft">
            <summary>Получить следующий узел слева</summary>
            <returns>Узел слева от текущего</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.GetNextRight">
            <summary>Получить следующий узел справа</summary>
            <returns>Узел справа от текущего</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.GetVariables">
            <summary>Перечисление переменных, известных данному узлу дерева</summary>
            <returns>Перечисление всех известных данному узлу дерева переменных</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.GetFunctions">
            <summary>Перечисление функций, известных данному узлу дерева</summary>
            <returns>Перечисление всех известных данному узлу дерева функций</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.GetFunctionals">
            <summary>Перечисление функционалов, известных данному узлу дерева</summary>
            <returns>Перечисление всех известных данному узлу дерева функционалов</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Dispose">
            <summary>Уничтожить узел рекуррентно с поддеревьями</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Clone">
            <summary>Клонирование поддерева</summary>
            <returns>Клон поддерева</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ToString">
            <summary>Преобразование узла в строку</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.System#ICloneable#Clone">
            <summary>Клонирование поддерева</summary>
            <returns>Клон поддерева</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.op_Implicit(System.String)~MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode">
            <summary>Оператор неявного преобразования строки в узел дерева</summary>
            <param name="value">Строковое значение</param>
            <returns>Строковый узел дерева</returns>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.FunctionalNode.Name">
            <summary>Имя узла</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionTrees.Nodes.FunctionalNode._ParametersExpression">
            <summary>Выражение параметров</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionTrees.Nodes.FunctionalNode._CoreExpression">
            <summary>Выражение ядра функции</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.FunctionalNode.Parameters">
            <summary>Выражение параметров</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.FunctionalNode.Core">
            <summary>Выражение ядра функции</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.FunctionalNode.Operator">
            <summary>Оператор</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionalNode.Compute">
            <summary>Вычислить значение поддерева</summary>
            <returns>Численное значение поддерева</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionalNode.Compile">
            <summary>Скомпилировать в выражение</summary>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionalNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Скомпилировать в выражение</summary>
            <param name="Parameters">Массив параметров</param>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionalNode.ToString">
            <summary>Преобразование узла в строку</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionalNode.Clone">
            <summary>Клонирование поддерева</summary>
            <returns>Клон поддерева</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode">
            <summary>Узел дерева выражения, содержащий сведения об аргументе функции</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.ArgumentNode">
            <summary>Узел аргумента</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.ArgumentName">
            <summary>Узел имени аргумента</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.#ctor">
            <summary>Инициализация узла дерева информации об аргументе функции</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.#ctor(System.String,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация узла дерева информации об аргументе функции</summary>
            <param name="Name">Имя</param>
            <param name="Expression">Узел выражения аргумента</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.#ctor(MathCore.MathParser.ExpressionTrees.Nodes.StringNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация узла дерева информации об аргументе функции</summary>
            <param name="Name">Имя</param>
            <param name="Expression">Выражение узла</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.Compute">
            <summary>Метод вычисления значения узла</summary>
            <returns>Значение аргумента</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.Compile">
            <summary>Компиляция узла аргумента</summary>
            <returns>Скомпилированное выражение</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла аргумента с учётом списка параметров</summary>
            <param name="Parameters">Массив параметров процесса компиляции</param>
            <returns>Скомпилированное значение узла аргумента дерева выражения</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode">
            <summary>Узел дерева мат.выражения, хранящий данные об аргументе функции</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.EnumArguments(MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode)">
            <summary>Перечисление аргументов начиная с указанного</summary>
            <param name="Node">Первый узел аргумента</param>
            <returns>Перечисление пар имени-корня дерева аргумента</returns>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.ArgumentSubtree">
            <summary>Значение аргумента - правое поддерево</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.ArgumentName">
            <summary>Имя аргумента - левое поддерево</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.#ctor">
            <summary>Инициализация узла-аргумента</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.#ctor(System.String,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация узла-аргумента</summary>
            <param name="Name">Имя аргумента</param>
            <param name="Node">Узел поддерева аргумента</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.#ctor(MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode)">
            <summary>Инициализация узла-аргумента</summary>
            <param name="Node">Узел поддерева аргумента</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>Значение узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.Compile">
            <summary>Компиляция узла аргумента</summary>
            <returns>Скомпилированное выражение корня поддерева аргумента</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла аргумента</summary>
            <param name="Parameters">Список параметров выражения</param>
            <returns>Скомпилированное выражение корня поддерева аргумента</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клонирование узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode">
            <summary>Узел дерева выражения, содержащий функцию</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode.Name">
            <summary>Имя функции</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode.ArgumentsNames">
            <summary>Массив имён аргументов функции</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode.Arguments">
            <summary>Перечисление аргументов функции</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode.Function">
            <summary>Функция узла</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode.#ctor">
            <summary>Инициализация нового функционального узла</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode.#ctor(System.String)">
            <summary>Инициализация нового функционального узла</summary>
            <param name="Name">Имя функции</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode.#ctor(MathCore.MathParser.ExpressionTrees.Nodes.StringNode)">
            <summary>Инициализация нового функционального узла</summary>
            <param name="Name">Имя функции</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode.#ctor(MathCore.MathParser.FunctionTerm,MathCore.MathParser.ExpressionParser,MathCore.MathParser.MathExpression)">
            <summary>Инициализация нового функционального узла</summary>
            <param name="Term">Выражение функции</param>
            <param name="Parser">Парсер выражения</param>
            <param name="Expression">Математическое выражение</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>Значение функции</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode.GetFunctionArgumentNodes(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Получить перечисление аргументов функции</summary>
            <param name="FunctionNode">Узел функции</param>
            <returns>Перечисление аргументов функции</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Скомпилированное выражение узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла</summary>
            <param name="Parameters">Список параметров выражения</param>
            <returns>Скомпилированное выражение узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode.ToString">
            <summary>Строковое представление узла</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode">
            <summary>Узел дерева мат.выражения, реализующий оператор больше</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора больше</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode.#ctor(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового узла оператора больше</summary>
            <param name="Left">Левое поддерево выражения</param>
            <param name="Right">Правое поддерево выражения</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode.Comparer(System.Double,System.Double)">
            <summary>Метод сравнения</summary>
            <param name="x">Первое значение</param>
            <param name="y">Второе значение</param>
            <returns>1 - если x больше y и 0 - в противном случае</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>0 - если разность между x и y по модулю меньше Epsilon и 1 во всех остальных случаях</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode.LogicCompile">
            <summary>Компиляция логики узла</summary>
            <returns>Скомпилированное логическое выражение, реализующее операцию сравнения Больше</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode.LogicCompile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция логики узла</summary>
            <param name="Parameters">Параметры компиляции</param>
            <returns>Скомпилированное логическое выражение, реализующее операцию сравнения Больше</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.IntervalNode">
            <summary>Узел интервального значения</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.IntervalNode.Min">
            <summary>Минимальное значение</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.IntervalNode.Max">
            <summary>Максимальное значение</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.IntervalNode.Clone">
            <summary>Клонирование поддерева</summary>
            <returns>Клон поддерева</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.IntervalNode.ToString">
            <summary>Преобразование узла в строку</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode">
            <summary>Узел дерева мат.выражения, реализующий оператор меньше</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора меньше</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode.#ctor(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового узла оператора меньше</summary>
            <param name="Left">Левое поддерево выражения</param>
            <param name="Right">Правое поддерево выражения</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode.Comparer(System.Double,System.Double)">
            <summary>Метод сравнения</summary>
            <param name="x">Первое значение</param>
            <param name="y">Второе значение</param>
            <returns>1 - если x меньше y и 0 - в противном случае</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>0 - если разность между x и y по модулю меньше Epsilon и 1 во всех остальных случаях</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode.LogicCompile">
            <summary>Компиляция логики узла</summary>
            <returns>Скомпилированное логическое выражение, реализующее операцию сравнения Меньше</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode.LogicCompile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция логики узла</summary>
            <param name="Parameters">Параметры компиляции</param>
            <returns>Скомпилированное логическое выражение, реализующее операцию сравнения Меньше</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.LogicOperatorNode">
            <summary>Узел дерева мат.выражения, реализующий логическую операцию</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.LogicOperatorNode.LogicCompile">
            <summary>Компиляция логики узла</summary>
            <returns>Скомпилированное логическое выражение, реализующее логику оператора</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.LogicOperatorNode.LogicCompile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция логики узла</summary>
            <param name="Parameters">Параметры компиляции</param>
            <returns>Скомпилированное логическое выражение, реализующее логику оператора</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.LogicOperatorNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.LogicOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла</summary>
            <param name="Parameters">Массив параметров выражения</param>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.MultiplicationOperatorNode">
            <summary>Узел дерева мат.выражения, реализующий оператор умножения "*"</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.MultiplicationOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора произведения</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.MultiplicationOperatorNode.#ctor(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового узла оператора произведения</summary>
            <param name="Left">Левое поддерево произведения</param>
            <param name="Right">Правое поддерево произведения</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.MultiplicationOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>Произведение значений корней правого и левого поддеревьев</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.MultiplicationOperatorNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.MultiplicationOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла</summary>
            <param name="Parameters">Массив параметров выражения</param>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.MultiplicationOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.NotOperatorNode">
            <summary>Узел дерева мат.выражения, реализующий оператор отрицания</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.NotOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора меньше</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.NotOperatorNode.#ctor(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового узла оператора меньше</summary>
            <param name="Left">Левое поддерево выражения</param>
            <param name="Right">Правое поддерево выражения</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.NotOperatorNode.Comparer(System.Double,System.Double)">
            <summary>Метод отрицания</summary>
            <param name="x">Первое значение</param>
            <param name="y">Второе значение</param>
            <returns>1 - если x меньше y и 0 - в противном случае</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.NotOperatorNode.ComparerSingle(System.Double)">
            <summary>Метод отрицания</summary>
            <param name="x">Значение</param>
            <returns>1 - если x меньше y и 0 - в противном случае</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.NotOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>0 - если разность между x и y по модулю меньше Epsilon и 1 во всех остальных случаях</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.NotOperatorNode.LogicCompile">
            <summary>Компиляция логики узла</summary>
            <returns>Скомпилированное логическое выражение, реализующее операцию отрицания НЕ</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.NotOperatorNode.LogicCompile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция логики узла</summary>
            <param name="Parameters">Параметры компиляции</param>
            <returns>Скомпилированное логическое выражение, реализующее операцию отрицания НЕ</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.NotOperatorNode.ToString">
            <summary>Строковое представление узла</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.NotOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.OperatorNode">
            <summary>Узел дерева мат.выражения, реализующий оператор</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.OperatorNode.IsPrecomputable">
            <summary>Оператор является предвычислимым если предвычислимы его правое и левое поддерево</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.OperatorNode.Priority">
            <summary>Приоритет оператора</summary>
            <remarks>
            Чем выше приоритет, тем глубже в дереве должен находиться оператор
            Шакала базовых приоритетов:
             + - 0
             - - 5
             * - 10
             / - 15
             ^ - 20
            </remarks>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.OperatorNode.Name">
            <summary>Ипя оператора</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.OperatorNode.#ctor">
            <summary>Инициализация оператора</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.OperatorNode.#ctor(System.String)">
            <summary>Инициализация оператора</summary>
            <param name="Name">Имя оператора</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.OperatorNode.#ctor(System.String,System.Int32)">
            <summary>Инициализация оператора</summary>
            <param name="Name">Имя оператора</param>
            <param name="Priority">Приоритет оператора</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.OperatorNode.ToString">
            <summary>Строковое представление узла</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.OrOperatorNode">
            <summary>Узел дерева мат.выражения, реализующий оператор ленивого ИЛИ</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.OrOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора ленивого ИЛИ</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.OrOperatorNode.Compute">
            <summary>Вычислить значение поддерева</summary>
            <returns>Численное значение поддерева</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.OrOperatorNode.LogicCompile">
            <summary>Компиляция логики узла</summary>
            <returns>Скомпилированное логическое выражение, реализующее операцию ИЛИ</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.OrOperatorNode.LogicCompile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция логики узла</summary>
            <param name="Parameters">Параметры компиляции</param>
            <returns>Скомпилированное логическое выражение, реализующее операцию ИЛИ</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.OrOperatorNode.Clone">
            <summary>Клонирование поддерева</summary>
            <returns>Клон поддерева</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.ParsedNode">
            <summary>Узел дерева выражения стадии разбора</summary>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.PowerOperatorNode">
            <summary>Узел дерева математического выражения, реализующий оператор возведения в степень</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.PowerOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора возведения в степень</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.PowerOperatorNode.Compute">
            <summary>Вычисление узла выражения</summary>
            <returns>Возведение значения корня левого поддерева в степень значения корня правого поддерева</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.PowerOperatorNode.Compile">
            <summary>Компиляция выражения узла</summary>
            <returns>Скомпилированное выражение узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.PowerOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция выражения узла</summary>
            <param name="Parameters">Массив параметров выражения</param>
            <returns>Скомпилированное выражение узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.PowerOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.SelectorOperatorNode">
            <summary>Узел дерева мат.выражения, реализующий оператор выбора</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.SelectorOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора выбора</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.SelectorOperatorNode.#ctor(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового узла оператора выбора</summary>
            <param name="Left">Левое поддерево выражения</param>
            <param name="Right">Правое поддерево выражения</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.SelectorOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns></returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.SelectorOperatorNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.SelectorOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла</summary>
            <param name="Parameters">Массив параметров выражения</param>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.SelectorOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.StringNode">
            <summary>Строковый узел дерева математического выражения</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.StringNode.Value">
            <summary>Значение узла</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.StringNode.#ctor">
            <summary>Инициализация нового строкового узла</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.StringNode.#ctor(System.String)">
            <summary>Инициализация нового строкового узла</summary>
            <param name="value">Значение узла</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.StringNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.StringNode.ToString">
            <summary>Строковое представление узла</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.StringNode.op_Implicit(System.String)~MathCore.MathParser.ExpressionTrees.Nodes.StringNode">
            <summary>Оператор неявного преобразования строки к типу строкового узла</summary>
            <param name="value">Строковое значение</param>
            <returns>Строковый узел</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.StringNode.op_Implicit(MathCore.MathParser.ExpressionTrees.Nodes.StringNode)~System.String">
            <summary>Оператор неявного преобразования строкового узла к строковому типу</summary>
            <param name="node">Строковый узел</param>
            <returns>Значение строкового узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.subtractionOperatorNode">
            <summary>Узел дерева выражения, реализующий оператор вычитания</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.subtractionOperatorNode.#ctor">
            <summary>Инициализация нового оператора вычитания</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.subtractionOperatorNode.Compute">
            <summary>Вычисление значение узла</summary>
            <returns>Значение разности значений правого и левого поддеревьев</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.subtractionOperatorNode.Compile">
            <summary>Компиляция выражения узла</summary>
            <returns>Скомпилированное выражение узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.subtractionOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция выражения узла</summary>
            <param name="Parameters">Список параметров выражения</param>
            <returns>Скомпилированное выражение узла</returns>
            <returns></returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.subtractionOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.ValueNode">
            <summary>Узел дерева мат.выражения, хранящий значение</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ValueNode.Value">
            <summary>Значение узла</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ValueNode.ToString">
            <summary>Преобразование в строковую форму</summary>
            <returns>Строковое представление</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.VariableValueNode">
            <summary>Узел дерева, хранящий переменную</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.VariableValueNode.IsPrecomputable">
            <summary>Признак возможности получения тривиального значения</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.VariableValueNode.Variable">
            <summary>Ссылка на переменную</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.VariableValueNode.Value">
            <summary>Значение узла</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.VariableValueNode.Name">
            <summary>Имя переменной</summary> 
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.VariableValueNode.#ctor(MathCore.MathParser.ExpressionVariable)">
            <summary>Новый узел переменной</summary>
            <param name="Variable">Переменная</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.VariableValueNode.ToString">
            <summary>Преобразование в строковую форму</summary>
            <returns>Строковое представление</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.VariableValueNode.Compute">
            <summary>Вычислить значение поддерева</summary>
            <returns>Численное значение поддерева</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.VariableValueNode.Compile">
            <summary>Скомпилировать в выражение</summary>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.VariableValueNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Скомпилировать в выражение</summary>
            <param name="Parameters">Массив параметров</param>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.VariableValueNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.VariantOperatorNode">
            <summary>Узел дерева мат.выражения, реализующий оператор определения вариантов</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.VariantOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора определения вариантов</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.VariantOperatorNode.#ctor(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового узла оператора определения вариантов</summary>
            <param name="Left">Левое поддерево выражения</param>
            <param name="Right">Правое поддерево выражения</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.VariantOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns></returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.VariantOperatorNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.VariantOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла</summary>
            <param name="Parameters">Массив параметров выражения</param>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.VariantOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionVariable">
            <summary>Переменная математического выражения</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionVariable._Value">
            <summary>Значение переменной</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionVariable._IsConstant">
            <summary>Является ли константой?</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionVariable.Value">
            <summary>Значение переменной</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionVariable.IsPrecomputable">
            <summary>Признак возможности предвычисления значения</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionVariable.IsConstant">
            <summary>Является ли константой?</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionVariable.GetValue">
            <summary>Метод извлечения значения</summary>
            <returns>Численное значение переменной</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionVariable.#ctor(System.String)">
            <summary>Инициализация нового экземпляра переменной</summary>
            <param name="Name">Имя переменной</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionVariable.Clone">
            <summary>Клонирование переменной</summary>
            <returns>Новый экземпляр переменной с тем же именем и тем же значением</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionVariable.ToString">
            <summary>Преобразование в строку</summary>
            <returns>Строковое представление переменной</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionVariable.op_Implicit(System.Double)~MathCore.MathParser.ExpressionVariable">
            <summary>Оператор неявного привидения вещественного числа к типу переменной</summary>
            <param name="x">Вещественное число</param>
            <returns>Безымянная переменная, хранящая указанное число</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionVariable.op_Implicit(MathCore.MathParser.ExpressionVariable)~System.Double">
            <summary>Оператор неявного привидения к типу вещественного числа</summary>
            <param name="variable">Приводимая переменная</param>
            <returns>Значение переменной</returns>
        </member>
        <member name="T:MathCore.MathParser.Functional">
            <summary>Функционал</summary>
        </member>
        <member name="M:MathCore.MathParser.Functional.#ctor(System.String)">
            <summary>Инициализация нового функционала</summary>
            <param name="Name">Имя функционала</param>
        </member>
        <member name="M:MathCore.MathParser.Functional.GetValue">
            <summary>Метод определения значения</summary>
            <returns>Численное значение элемента выражения</returns>
        </member>
        <member name="M:MathCore.MathParser.Functional.GetValue(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression)">
            <summary>Метод определения значения</summary>
            <param name="ParametersExpression">Выражение параметров</param>
            <param name="Function">Ядро функционала</param>
            <returns>Численное значение вычисленного выражения</returns>
        </member>
        <member name="M:MathCore.MathParser.Functional.Compile(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression)">
            <summary>Скомпилировать в выражение</summary>
            <returns>Скомпилированное выражение <see cref="N:System.Linq.Expressions"/></returns>
        </member>
        <member name="M:MathCore.MathParser.Functional.Compile(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression,System.Linq.Expressions.ParameterExpression[])">
            <summary>Скомпилировать в выражение</summary>
            <param name="Function">Выражение ядра функции</param>
            <param name="Parameters">Массив параметров</param>
            <param name="ParametersExpression">Выражение параметров</param>
            <returns>Скомпилированное выражение <see cref="N:System.Linq.Expressions"/></returns>
        </member>
        <member name="M:MathCore.MathParser.Functional.Initialize(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression,MathCore.MathParser.ExpressionParser,MathCore.MathParser.MathExpression)">
            <summary>Инициализация оператора</summary>
            <param name="Parameters">Блок параметров</param>
            <param name="Function">Блок ядра функции</param>
            <param name="Parser">Парсер мат.выражения</param>
            <param name="Expression">Внешнее мат.выражение</param>
        </member>
        <member name="T:MathCore.MathParser.FunctionalsCollection">
            <summary>Коллекция функционалов</summary>
        </member>
        <member name="F:MathCore.MathParser.FunctionalsCollection._Operators">
            <summary>Список функционалов</summary>
        </member>
        <member name="F:MathCore.MathParser.FunctionalsCollection._Expression">
            <summary>Ссылка на математическое выражение, с которым связана коллекция</summary>
        </member>
        <member name="P:MathCore.MathParser.FunctionalsCollection.Count">
            <summary>Количество функционалов в коллекции</summary>
        </member>
        <member name="M:MathCore.MathParser.FunctionalsCollection.#ctor(MathCore.MathParser.MathExpression)">
            <summary>Инициализация новой коллекции функционалов</summary>
            <param name="Expression">Математическое выражение, на которое ссылается коллекция</param>
        </member>
        <member name="M:MathCore.MathParser.FunctionalsCollection.Add(MathCore.MathParser.Functional)">
            <summary>Добавить функционал в коллекцию</summary>
            <param name="Operator">Добавляемый функционал</param>
            <returns>Истина, если добавление прошло успешно</returns>
        </member>
        <member name="T:MathCore.MathParser.FunctionalTerm">
            <summary>Блок определения функции</summary>
        </member>
        <member name="P:MathCore.MathParser.FunctionalTerm.Parameters">
            <summary>Параметры оператора</summary>
        </member>
        <member name="M:MathCore.MathParser.FunctionalTerm.#ctor(MathCore.MathParser.FunctionTerm,MathCore.MathParser.BlockTerm)">
            <summary>Инициализация блока комплексного оператора</summary>
            <param name="Header">Заголовок блока</param>
            <param name="Body">Тело блока</param>
        </member>
        <member name="M:MathCore.MathParser.FunctionalTerm.GetSubTree(MathCore.MathParser.ExpressionParser,MathCore.MathParser.MathExpression)">
            <summary>Получить поддерево комплексного оператора</summary>
            <param name="Parser">Парсер</param>
            <param name="Expression">Математическое выражение</param>
            <returns>Узел комплексного оператора</returns>
        </member>
        <member name="M:MathCore.MathParser.FunctionalTerm.ToString">
            <summary>Преобразование в строковую форму</summary>
            <returns>Строковое представление элемента</returns>
        </member>
        <member name="T:MathCore.MathParser.FunctionsCollection">
            <summary>Коллекция функций</summary>
        </member>
        <member name="F:MathCore.MathParser.FunctionsCollection._MathExpression">
            <summary>Ссылка на математическое выражение</summary>
        </member>
        <member name="F:MathCore.MathParser.FunctionsCollection._Functions">
            <summary>Список функций математического выражения</summary>
        </member>
        <member name="P:MathCore.MathParser.FunctionsCollection.Names">
            <summary>Имена функций</summary>
        </member>
        <member name="P:MathCore.MathParser.FunctionsCollection.Count">
            <summary>Количество используемых функций</summary>
        </member>
        <member name="P:MathCore.MathParser.FunctionsCollection.Item(System.String,System.Int32)">
            <summary>Индексатор функций по имени и списку параметров</summary>
            <param name="Name">Имя функции</param>
            <param name="ArgumentsCount">Количество аргументов</param>
            <returns>Функция, удовлетворяющая загаданной сигнатуре</returns>
        </member>
        <member name="P:MathCore.MathParser.FunctionsCollection.Item(System.String,System.String[])">
            <summary>Индексатор функций по имени и списку параметров</summary>
            <param name="Name">Имя функции</param>
            <param name="Arguments">Список имён аргументов</param>
            <returns>Функция, удовлетворяющая загаданной сигнатуре</returns>
        </member>
        <member name="M:MathCore.MathParser.FunctionsCollection.#ctor(MathCore.MathParser.MathExpression)">
            <summary>Инициализация новой коллекции функций математического выражения</summary>
            <param name="MathExpression">Математическое выражение, на которое ссылается создаваемая коллекция</param>
        </member>
        <member name="M:MathCore.MathParser.FunctionsCollection.Add(MathCore.MathParser.ExpressionFunction)">
            <summary>Добавить функцию в коллекцию</summary>
            <param name="function">Функция</param>
            <returns>Истина, если функция была добавлена</returns>
        </member>
        <member name="M:MathCore.MathParser.FunctionsCollection.System#Collections#Generic#IEnumerable{MathCore#MathParser#ExpressionFunction}#GetEnumerator">
            <summary>Возвращает перечислитель, выполняющий перебор элементов в коллекции</summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.IEnumerator`1"/>, который может использоваться для перебора элементов коллекции.
            </returns>
        </member>
        <member name="M:MathCore.MathParser.FunctionsCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>Возвращает перечислитель, который осуществляет перебор элементов коллекции</summary>
            <returns>
            Объект <see cref="T:System.Collections.IEnumerator"/>, который может использоваться для перебора элементов коллекции.
            </returns>
        </member>
        <member name="T:MathCore.MathParser.FunctionTerm">
            <summary>Функциональный элемент выражения</summary>
        </member>
        <member name="P:MathCore.MathParser.FunctionTerm.Block">
            <summary>Блок со скобками</summary>
        </member>
        <member name="M:MathCore.MathParser.FunctionTerm.#ctor(MathCore.MathParser.StringTerm,MathCore.MathParser.BlockTerm)">
            <summary>Новый функциональный элемент выражения</summary>
            <param name="StrTerm">Строковый элемент выражения</param>
            <param name="Block">Блок выражения</param>
        </member>
        <member name="M:MathCore.MathParser.FunctionTerm.GetSubTree(MathCore.MathParser.ExpressionParser,MathCore.MathParser.MathExpression)">
            <summary>Получить поддерево</summary>
            <param name="Parser">Парсер</param>
            <param name="Expression">Математическое выражение</param>
            <returns>Узел функции</returns>
        </member>
        <member name="M:MathCore.MathParser.FunctionTerm.ToString">
            <summary>Преобразование в строковую форму</summary>
            <returns>Строковое представление элемента</returns>
        </member>
        <member name="T:MathCore.MathParser.IntegralOperator">
            <summary>Комплексный оператор интегрирования</summary>
        </member>
        <member name="M:MathCore.MathParser.IntegralOperator.#ctor">
            <summary>Создание нового комплексного интегратора интегрирования</summary>
        </member>
        <member name="M:MathCore.MathParser.IntegralOperator.#ctor(System.String)">
            <summary>Создание нового комплексного интегратора интегрирования</summary>
            <param name="Name">Имя оператора</param>
        </member>
        <member name="M:MathCore.MathParser.IntegralOperator.Initialize(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression,MathCore.MathParser.ExpressionParser,MathCore.MathParser.MathExpression)">
            <summary>Инициализация оператора</summary>
            <param name="Parameters">Блок параметров</param>
            <param name="Function">Блок ядра функции</param>
            <param name="Parser">Парсер</param>
            <param name="Expression">Внешнее выражение</param>
        </member>
        <member name="M:MathCore.MathParser.IntegralOperator.GetValue(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression)">
            <summary>Метод определения значения</summary>
            <returns>Численное значение элемента выражения</returns>
        </member>
        <member name="T:MathCore.MathParser.IntegralOperator.AdaptiveIntegralDelegate">
            <summary>Делегат адаптивного интегрирования</summary>
            <param name="d">Делегат интегрируемой функции</param>
            <param name="Min">Начальное значение интервала интегрирования</param>
            <param name="Max">Конечное значение интервала интегрирования</param>
            <param name="Parameters">Массив параметров интегрируемой функции</param>
            <returns>Значение интеграла</returns>
        </member>
        <member name="M:MathCore.MathParser.IntegralOperator.GetAdaptiveIntegral(System.Delegate,System.Double,System.Double,System.Double[])">
            <summary>Получить численное значение интеграла адаптивным методом</summary>
            <param name="d">Делегат интегрируемой функции</param>
            <param name="Min">Начальное значение интервала интегрирования</param>
            <param name="Max">Конечное значение интервала интегрирования</param>
            <param name="Parameters">Массив параметров интегрируемой функции</param>
            <returns>Значение интеграла</returns>
        </member>
        <member name="T:MathCore.MathParser.IntegralOperator.IntegralDelegate">
            <summary>Получить численное значение интеграла методом трапеций</summary>
            <param name="d">Делегат интегрируемой функции</param>
            <param name="Min">Начальное значение интервала интегрирования</param>
            <param name="Max">Конечное значение интервала интегрирования</param>
            <param name="Parameters">Массив параметров интегрируемой функции</param>
            <param name="dx">Шаг интерполяции</param>
            <returns>Значение интеграла</returns>
        </member>
        <member name="M:MathCore.MathParser.IntegralOperator.GetIntegral(System.Delegate,System.Double,System.Double,System.Double[],System.Double)">
            <summary>Получить численное значение интеграла методом трапеций</summary>
            <param name="d">Делегат интегрируемой функции</param>
            <param name="Min">Начальное значение интервала интегрирования</param>
            <param name="Max">Конечное значение интервала интегрирования</param>
            <param name="Parameters">Массив параметров интегрируемой функции</param>
            <param name="dx">Шаг интерполяции</param>
            <returns>Значение интеграла</returns>
        </member>
        <member name="M:MathCore.MathParser.IntegralOperator.Compile(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression)">
            <summary>Скомпилировать в выражение</summary>
            <returns>Скомпилированное выражение <see cref="N:System.Linq.Expressions"/></returns>
        </member>
        <member name="M:MathCore.MathParser.IntegralOperator.Compile(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression,System.Linq.Expressions.ParameterExpression[])">
            <summary>Скомпилировать в выражение</summary>
            <param name="Function">Ядро функции</param>
            <param name="Parameters">Массив параметров</param>
            <param name="ParametersExpression">Выражение параметров</param>
            <returns>Скомпилированное выражение <see cref="N:System.Linq.Expressions"/></returns>
        </member>
        <member name="T:MathCore.MathParser.LambdaExpressionVariable">
            <summary>лямбда-переменная</summary>
            <remarks>Значение переменной - результат вычисления лямбда-функции</remarks>
        </member>
        <member name="F:MathCore.MathParser.LambdaExpressionVariable._Value">
            <summary>Функция вычисления значения переменной</summary>
        </member>
        <member name="P:MathCore.MathParser.LambdaExpressionVariable.IsPrecomputable">
            <summary>Признак отсутствия возможности предвычисления значения</summary>
        </member>
        <member name="M:MathCore.MathParser.LambdaExpressionVariable.#ctor(System.Func{System.Double})">
            <summary>Инициализация нового экземпляра лямбда-переменной</summary>
            <param name="Source">лямбда-функция получения значения переменной</param>
        </member>
        <member name="M:MathCore.MathParser.LambdaExpressionVariable.#ctor(System.String,System.Func{System.Double})">
            <summary>Инициализация нового экземпляра лямбда-переменной</summary>
            <param name="Name">Имя переменной</param>
            <param name="Source">лямбда-функция получения значения переменной</param>
        </member>
        <member name="M:MathCore.MathParser.LambdaExpressionVariable.GetValue">
            <summary>Получить значение переменной</summary>
            <returns>Численное значение переменной</returns>
        </member>
        <member name="M:MathCore.MathParser.LambdaExpressionVariable.Clone">
            <summary>Клонировать переменную</summary>
            <returns>Новый экземпляр лямбда-переменной с тем же именем и клоном функции</returns>
        </member>
        <member name="T:MathCore.MathParser.MathExpression">
            <summary>Математическое выражение</summary>
        </member>
        <member name="F:MathCore.MathParser.MathExpression._ExpressionTree">
            <summary>Дерево математического выражения</summary>
        </member>
        <member name="F:MathCore.MathParser.MathExpression._Variables">
            <summary>Коллекция переменных математического выражения</summary>
        </member>
        <member name="F:MathCore.MathParser.MathExpression._Constants">
            <summary>Коллекция констант математического выражения</summary>
        </member>
        <member name="F:MathCore.MathParser.MathExpression._Functions">
            <summary>Коллекция функций, участвующих в выражении</summary>
        </member>
        <member name="F:MathCore.MathParser.MathExpression._Functionals">
            <summary>Коллекция функционалов</summary>
        </member>
        <member name="F:MathCore.MathParser.MathExpression._Name">
            <summary>Имя выражения</summary>
        </member>
        <member name="P:MathCore.MathParser.MathExpression.Name">
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value"/> is <see langword="null" />.</exception>
            <exception cref="T:System.ArgumentException" accessor="set">Указано пустое имя функции</exception>
        </member>
        <member name="P:MathCore.MathParser.MathExpression.IsPrecomputable">
            <summary>Является ли выражение предвычислимым?</summary>
        </member>
        <member name="P:MathCore.MathParser.MathExpression.Tree">
            <summary>Дерево математического выражения</summary>
        </member>
        <member name="P:MathCore.MathParser.MathExpression.Variable">
            <summary>Переменные, входящие в математическое выражение</summary>
        </member>
        <member name="P:MathCore.MathParser.MathExpression.Constants">
            <summary>Константы, входящие в математическое выражение</summary>
        </member>
        <member name="P:MathCore.MathParser.MathExpression.Functions">
            <summary>Коллекция функций, участвующих в выражении</summary>
        </member>
        <member name="P:MathCore.MathParser.MathExpression.Functionals">
            <summary>Коллекция функционалов</summary>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.#ctor(System.String)">
            <summary>Инициализация пустого математического выражения</summary>
            <param name="Name">Имя функции</param>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.#ctor(MathCore.MathParser.ExpressionTrees.ExpressionTree,System.String)">
            <summary>Инициализация нового математического выражения</summary>
            <param name="Tree">Дерево математического выражения</param>
            <param name="Name">Имя функции</param>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.#ctor(System.String,MathCore.MathParser.ExpressionParser)">
            <summary>Инициализация нового математического выражения</summary>
            <param name="StrExpression">Строковое представление выражения</param>
            <param name="Parser">Ссылка на парсер</param>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.System#IDisposable#Dispose">
            <summary>Уничтожить математическое выражение</summary>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.Compute">
            <summary>Вычисление математического выражения</summary>
            <returns>Значение выражения</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.Compute(System.Double[])">
            <summary>Вычисление математического выражения</summary>
            <returns>Значение выражения</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.Compile">
            <summary>Компиляция математического выражения в функцию без параметров</summary>
            <returns>Функция типа double func(void) без параметров</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.Compile1">
            <summary>Компиляция функции одной переменной</summary>
            <returns>Делегат функции одной переменной</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.Compile2">
            <summary>Компиляция функции двух переменных</summary>
            <returns>Делегат функции двух переменных</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.Compile3">
            <summary>Компиляция функции трёх переменных</summary>
            <returns>Делегат функции трёх переменных</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.Compile(System.String[])">
            <summary>Компиляция математического выражения в функцию указанного типа</summary>
            <param name="ArgumentName">Список имён параметров</param>
            <returns>Делегат скомпилированного выражения</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.CompileMultiParameters(System.String[])">
            <summary>Многопараметрическая компиляция мат.выражения</summary>
            <param name="ArgumentName">Массив имён компилируемых параметров</param>
            <returns>Делегат функции, принимающий на вход массив значений параметров</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.Compile``1(System.String[])">
            <summary>Компиляция математического выражения в функцию указанного типа</summary>
            <typeparam name="TDelegate">Тип делегата функции</typeparam>
            <param name="ArgumentName">Список имён параметров</param>
            <returns>Делегат скомпилированного выражения</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.GetExpression(System.Linq.Expressions.ParameterExpression[]@,System.String[])">
            <summary>Получить Linq.Expression выражение, построенное на основе дерева выражений</summary>
            <param name="vars">Список входных переменных</param>
            <param name="ArgumentName">Список имён аргументов</param>
            <returns>Выражение типа Linq.Expression</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.GetExpression``1(System.Linq.Expressions.ParameterExpression[]@,System.String[])">
            <summary>Получить Linq.Expression выражение, построенное на основе дерева выражений</summary>
            <typeparam name="TDelegate">Тип делегата выражения</typeparam>
            <param name="vars">Список входных переменных</param>
            <param name="ArgumentName">Список имён аргументов</param>
            <returns>Выражение типа Linq.Expression</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.ToString">
            <summary>Преобразование в строку</summary>
            <returns>Строковое представление</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.CheckConstantsCollection(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression)">
            <summary>Перенос констант из выражения источника в выражение приёмник</summary>
            <param name="Source">Выражение источник</param>
            <param name="Result">Выражение приёмник</param>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.Clone">
            <summary>Клонирование выражения</summary>
            <returns>Копия объектной модели выражения</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.CombineExpressions(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression,MathCore.MathParser.ExpressionTrees.Nodes.OperatorNode)">
            <summary>Комбинация двух выражений с использованием узла-оператора</summary>
            <param name="x">Первое выражение</param>
            <param name="y">Второе выражение</param>
            <param name="node">Узел операции</param>
            <returns>Математическое выражение, в корне дерева которого лежит узел оператора. Поддеревья - корни первого и второго выражений</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.op_Addition(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression)">
            <summary>Оператор сложения двух выражений</summary>
            <param name="x">Первое слагаемое</param>
            <param name="y">Второе слагаемое</param>
            <returns>Выражение-сумма, корень которого - узел суммы. Поддеревья - корни выражений слагаемых</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.op_Subtraction(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression)">
            <summary>Оператор вычитания двух выражений</summary>
            <param name="x">Уменьшаемое</param>
            <param name="y">Вычитаемое</param>
            <returns>Выражение-разность, корень которого - узел разности. Поддеревья - корни выражений вычитаемого и уменьшаемого</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.op_Multiply(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression)">
            <summary>Оператор умножения двух выражений</summary>
            <param name="x">Первый сомножитель</param>
            <param name="y">Второй сомножитель</param>
            <returns>Выражение-произведения, корень которого - узел произведения. Поддеревья - корни выражений сомножителей</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.op_Division(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression)">
            <summary>Оператор деления двух выражений</summary>
            <param name="x">Делимое</param>
            <param name="y">Делитель</param>
            <returns>Выражение-частное, корень которого - узел деления. Поддеревья - корни выражений делимого и делителя</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.op_ExclusiveOr(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression)">
            <summary>Оператор возведения в степень</summary>
            <param name="x">Основание</param>
            <param name="y">Показатель степени</param>
            <returns>Выражение-степень, корень которого - узел степени. Поддеревья - корни выражений Основания и показателя степени</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.op_Implicit(MathCore.MathParser.MathExpression)~MathCore.MathParser.ExpressionTrees.ExpressionTree">
            <summary>Оператор неявного приведения типов математического выражения к типу дерева выражения</summary>
            <param name="Expression">Математическое выражение</param>
            <returns>Дерево математического выражения</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.op_Implicit(MathCore.MathParser.ExpressionTrees.ExpressionTree)~MathCore.MathParser.MathExpression">
            <summary>Оператор неявного приведения типов дерева выражения к типу математического выражения</summary>
            <param name="Tree">Дерево математического выражения</param>
            <returns>Математическое выражение, содержащее указанное дерево</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.op_Implicit(MathCore.MathParser.MathExpression)~System.Func{System.Double}">
            <summary>Оператор неявного приведения типов математического выражения к типу делегата функции double Func(void)</summary>
            <param name="expr">Математическое выражения</param>
            <returns>Результат компиляции математического выражения</returns>
        </member>
        <member name="T:MathCore.MathParser.NumberTerm">
            <summary>Числовой элемент математического выражения</summary>
        </member>
        <member name="F:MathCore.MathParser.NumberTerm._IntValue">
            <summary>Численное значение элемента</summary>
        </member>
        <member name="P:MathCore.MathParser.NumberTerm.Value">
            <summary>Численное значение элемента</summary>
        </member>
        <member name="M:MathCore.MathParser.NumberTerm.#ctor(System.String)">
            <summary>Новый численный элемент мат.выражения</summary>
            <param name="Str">Строковое значение элемента</param>
        </member>
        <member name="M:MathCore.MathParser.NumberTerm.GetSubTree(MathCore.MathParser.ExpressionParser,MathCore.MathParser.MathExpression)">
            <summary>Извлечь поддерево</summary>
            <param name="Parser">Парсер</param>
            <param name="Expression">Математическое выражение</param>
            <returns>Узел константного значения</returns>
        </member>
        <member name="M:MathCore.MathParser.NumberTerm.TryAddFractionPart(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode@,MathCore.MathParser.Term,System.Char,MathCore.MathParser.Term)">
            <summary>Попытаться добавить дробное значение числа</summary>
            <param name="node">Узел выражения</param>
            <param name="SeparatorTerm">Блок разделитель</param>
            <param name="DecimalSeparator">Блок с целой частью числа</param>
            <param name="FractionPartTerm">Блок с дробной частью числа</param>
            <returns>Истина, если действие совершено успешно. Ложь, если в последующих блоках не содержится нужной информации</returns>
        </member>
        <member name="T:MathCore.MathParser.StringTerm">
            <summary>Строковый элемент выражения</summary>
        </member>
        <member name="P:MathCore.MathParser.StringTerm.Name">
            <summary>Имя строкового элемента</summary>
        </member>
        <member name="M:MathCore.MathParser.StringTerm.#ctor(System.String)">
            <summary>Новый строковый элемент</summary>
            <param name="Name">Имя строкового элемента</param>
        </member>
        <member name="M:MathCore.MathParser.StringTerm.GetSubTree(MathCore.MathParser.ExpressionParser,MathCore.MathParser.MathExpression)">
            <summary>Поддерево элемента, состоящее из узла-переменной</summary>
            <param name="Parser">Парсер</param>
            <param name="Expression">Математическое выражение</param>
            <returns>Узел дерева с переменной, полученной из Expression.Variable[Name]</returns>
        </member>
        <member name="T:MathCore.MathParser.SumOperator">
            <summary>Оператор суммы</summary>
        </member>
        <member name="M:MathCore.MathParser.SumOperator.#ctor">
            <summary>Инициализация нового оператора суммы</summary>
        </member>
        <member name="M:MathCore.MathParser.SumOperator.#ctor(System.String)">
            <summary>Инициализация нового оператора суммы</summary>
            <param name="Name"></param>
        </member>
        <member name="M:MathCore.MathParser.SumOperator.Initialize(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression,MathCore.MathParser.ExpressionParser,MathCore.MathParser.MathExpression)">
            <summary>Инициализация оператора</summary>
            <param name="Parameters">Блок параметров</param>
            <param name="Function">Блок ядра функции</param>
            <param name="Parser">Парсер мат.выражения</param>
            <param name="Expression">Внешнее мат.выражение</param>
        </member>
        <member name="M:MathCore.MathParser.SumOperator.GetValue(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression)">
            <summary>Метод определения значения</summary>
            <returns>Численное значение элемента выражения</returns>
        </member>
        <member name="T:MathCore.MathParser.SumOperator.SumDelegate">
            <summary>Метод суммирования</summary>
            <param name="d">Суммируемая функция - ядро</param>
            <param name="Min">Начало интервала</param>
            <param name="Max">Конец интервала</param>
            <param name="Parameters">Массив параметров функции</param>
            <returns>Значение суммы функции</returns>
        </member>
        <member name="M:MathCore.MathParser.SumOperator.GetSum(System.Delegate,System.Double,System.Double,System.Double[])">
            <summary>Получение значения суммы</summary>
            <param name="d">Суммируемая функция - ядро</param>
            <param name="Min">Начало интервала суммирования</param>
            <param name="Max">Конец интервала суммирования</param>
            <param name="Parameters">Массив параметров</param>
            <returns>Сумма функции</returns>
        </member>
        <member name="M:MathCore.MathParser.SumOperator.Compile(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression)">
            <summary>Скомпилировать в выражение</summary>
            <param name="ParametersExpression">Выражение блока параметров</param>
            <param name="Function">Выражение блока ядра оператора - функции</param>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathCore.MathParser.SumOperator.Compile(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression,System.Linq.Expressions.ParameterExpression[])">
            <summary>Скомпилировать в выражение</summary>
            <param name="Function">Ядро функции</param>
            <param name="Parameters">Массив параметров</param>
            <param name="ParametersExpression">Выражение параметров</param>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="T:MathCore.MathParser.Term">
            <summary>Элемент математического выражения</summary>
        </member>
        <member name="F:MathCore.MathParser.Term._Value">
            <summary>Строковое содержимое</summary>
        </member>
        <member name="M:MathCore.MathParser.Term.#ctor(System.String)">
            <summary>Конструктор элемента математического выражения</summary>
            <param name="Value">Строковое содержимое</param>
        </member>
        <member name="M:MathCore.MathParser.Term.GetSubTree(MathCore.MathParser.ExpressionParser,MathCore.MathParser.MathExpression)">
            <summary>Метод извлечения поддерева для данного элемента математического выражения</summary>
            <param name="Parser">Парсер математического выражения</param>
            <param name="Expression">Математическое выражение</param>
            <returns>Узел дерева мат.выражения, являющийся поддеревом для данного элемента мат.выражения</returns>
        </member>
        <member name="M:MathCore.MathParser.Term.ToString">
            <summary>Строковое представление элемента мат.выражения</summary>
            <returns>Строковое содержимое элемента мат.выражения</returns>
        </member>
        <member name="T:MathCore.MathParser.VariablesCollection">
            <summary>Коллекция переменных</summary>
        </member>
        <member name="F:MathCore.MathParser.VariablesCollection._Expression">
            <summary>Математическое выражение</summary>
        </member>
        <member name="P:MathCore.MathParser.VariablesCollection.Count">
            <summary>Количество переменных в коллекции</summary>
        </member>
        <member name="P:MathCore.MathParser.VariablesCollection.Item(System.String)">
            <summary>Итератор переменных коллекции</summary>
            <param name="Name">Имя переменной</param>
            <returns>Переменная с указанным именем</returns>
        </member>
        <member name="P:MathCore.MathParser.VariablesCollection.Item(System.Int32)">
            <summary>Итератор переменных коллекции</summary>
            <param name="i">Индекс переменной</param>
            <returns>Переменная с указанным индексом</returns>
        </member>
        <member name="P:MathCore.MathParser.VariablesCollection.Names">
            <summary>Перечисление всех имён переменных коллекции</summary>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.#ctor(MathCore.MathParser.MathExpression)">
            <summary>Инициализация новой коллекции переменных</summary>
            <param name="expression">Математическое выражение, которому принадлежит коллекция</param>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.Add(MathCore.MathParser.ExpressionVariable)">
            <summary>Добавить переменную в коллекцию</summary>
            <param name="Variable">Переменная</param>
            <returns>Истина, если переменная была добавлена</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.MoveToConstCollection(System.String)">
            <summary>Переместить переменную из коллекции переменных в коллекцию констант</summary>
            <param name="Variable">Перемещаемая переменная</param>
            <returns>Истина, если переменная была перемещена из коллекции переменных в коллекцию констант</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.MoveToConstCollection(MathCore.MathParser.ExpressionVariable)">
            <summary>Переместить переменную из коллекции переменных в коллекцию констант</summary>
            <param name="Variable">Перемещаемая переменная</param>
            <returns>Истина, если переменная была перемещена из коллекции переменных в коллекцию констант</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.Remove(MathCore.MathParser.ExpressionVariable)">
            <summary>Удаление переменной из коллекции</summary>
            <param name="Variable">Удаляемая переменная</param>
            <returns>Истина, если удаление прошло успешно</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.RemoveFromCollection(MathCore.MathParser.ExpressionVariable)">
            <summary>Удалить переменную из коллекции</summary>
            <param name="Variable">Удаляемая переменная</param>
            <returns>Истина, если переменная удалена успешно</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.ClearCollection">
            <summary>Очистить коллекцию переменных</summary>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.Exist(System.String)">
            <summary>Существует ли в коллекции переменная с указанным именем</summary>
            <param name="Name">Искомое имя переменной</param>
            <returns>Истина, если в коллекции присутствует переменная с указанным именем</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.Exist(MathCore.MathParser.ExpressionVariable)">
            <summary>Проверка на существование переменной в коллекции</summary>
            <param name="variable">Проверяемая переменная</param>
            <returns>Истина, если указанная переменная входит в коллекцию</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.Exist(System.Predicate{MathCore.MathParser.ExpressionVariable})">
            <summary>Существует ли переменная в коллекции с заданным критерием поиска</summary>
            <param name="exist">Критерий поиска переменной</param>
            <returns>Истина, если найдена переменная по указанному критерию</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.ExistInTree(System.String)">
            <summary>Существует ли узел переменной в дереве с указанным именем</summary>
            <param name="Name">Искомое имя переменной</param>
            <returns>Истина, если указанное имя переменной существует в дереве</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.ExistInTree(System.Func{MathCore.MathParser.ExpressionTrees.Nodes.VariableValueNode,System.Boolean})">
            <summary>Существует ли узел переменной в дереве</summary>
            <param name="exist">Критерий поиска</param>
            <returns>Истина, если найден узел по указанному критерию</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.GetTreeNodes(System.String)">
            <summary>Получить перечисление узлов переменных с указанным именем</summary>
            <param name="VariableName">Искомое имя переменной</param>
            <returns>Перечисление узлов с переменными с указанным именем</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.GetTreeNodes(System.Func{MathCore.MathParser.ExpressionTrees.Nodes.VariableValueNode,System.Boolean})">
            <summary>Получить перечисление узлов дерева с переменными</summary>
            <param name="selector">Метод выборки узлов</param>
            <returns>Перечисление узлов переменных</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.GetTreeNodesOf``1">
            <summary>Получить перечисление узлов дерева выражения, содержащих указанный тип переменных</summary>
            <typeparam name="TVariable">Тип переменной</typeparam>
            <returns>Перечисление узлов дерева с указанным типом переменных</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.GetTreeNodesVOf``1(System.Func{``0,System.Boolean})">
            <summary>Получить перечисление узлов дерева выражения, содержащих указанный тип переменных</summary>
            <typeparam name="TVariable">Тип переменной</typeparam>
            <param name="selector">Метод выбора узлов по содержащимся в них переменным</param>
            <returns>Перечисление узлов дерева с указанным типом переменных</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.GetTreeNodesOf``1(System.Func{MathCore.MathParser.ExpressionTrees.Nodes.VariableValueNode,System.Boolean})">
            <summary>Получить перечисление узлов дерева выражения, содержащих указанный тип переменных</summary>
            <typeparam name="TVariable">Тип переменной</typeparam>
            <param name="selector">Метод выбора узлов</param>
            <returns>Перечисление узлов дерева с указанным типом переменных</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.System#Collections#Generic#IEnumerable{MathCore#MathParser#ExpressionVariable}#GetEnumerator">
            <summary>Возвращает перечислитель, выполняющий перебор элементов в коллекции</summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.IEnumerator`1"/>, который может использоваться для перебора элементов коллекции.
            </returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>Возвращает перечислитель, который осуществляет перебор элементов коллекции</summary>
            <returns>
            Объект <see cref="T:System.Collections.IEnumerator"/>, который может использоваться для перебора элементов коллекции.
            </returns>
        </member>
        <member name="T:MathCore.Matrix">
            <summary>Матрица NxM</summary>
            <remarks>
            i (первый индекс) - номер строки, 
            j (второй индекс) - номер столбца
            ------------ j ---------->
            | a11 a12 a13 a14 a15 a16 a1M
            | a21........................
            | a31........................
            | a41.......aij..............
            i a51........................
            | a61........................
            | aN1.....................aNM
            \/
            </remarks>
        </member>
        <member name="T:MathCore.Matrix.Array">
            <summary>Операции над двумерными массивами</summary>
        </member>
        <member name="M:MathCore.Matrix.Array.MatrixToColsArray(System.Double[0:,0:])">
            <summary>Преобразовать двумерный массив элементов матрицы в массив массивов-столбцов</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <returns>Массив столбцов</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.MatrixToRowsArray(System.Double[0:,0:])">
            <summary>Преобразовать двумерный массив элементов матрицы в массив массивов-строк</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <returns>Массив строк</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.ColsArrayToMatrix(System.Double[][])">
            <summary>Создать двумерный массив массив матрицы из массива столбцов</summary>
            <param name="cols">Массив столбцов матрицы</param>
            <returns>Двумерный массив элементов матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="cols"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.RowsArrayToMatrix(System.Double[][])">
            <summary>Создать двумерный массив массив матрицы из массива строк</summary>
            <param name="rows">Массив строк матрицы</param>
            <returns>Двумерный массив элементов матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="rows"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.IsMatrixSingular(System.Double[0:,0:])">
            <summary>Проверка - является ли матрица вырожденной</summary>
            <param name="matrix">Проверяемая матрица</param>
            <returns>Истина, если определитель матрицы равен нулю</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица не содержит элементов, или если матрица не квадратная</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Rank(System.Double[0:,0:])">
            <summary>Определение ранга матрицы</summary>
            <param name="matrix">Матрица, ранг которой требуется определить</param>
            <returns>Ранг матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица не содержит элементов</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.CreateDiagonal(System.Double[])">
            <summary>Создать диагональную матрицу</summary>
            <param name="elements">Элементы диагонали матрицы</param>
            <returns>Двумерный массив, содержащий на главной диагонали элементы диагональной матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="elements"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Массив не содержит элементов</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetMatrixShadow(System.Double[0:,0:])">
            <summary>Получить массив элементов тени (главной диагонали) матрицы</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Массив элементов тени матрицы</returns>
            <exception cref="T:System.ArgumentException">Массив не содержит элементов</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.EnumerateMatrixShadow(System.Double[0:,0:])">
            <summary>Перечислить элементы тени (главной диагонали) матрицы</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Перечисление элементов тени матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Массив не содержит элементов</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Permutation_Left(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Применение матрицы перестановок слева (перестановка строк)</summary>
            <param name="matrix">Матрица, подвергаемая перестановке строк</param>
            <param name="p">Матрица перестановок (строк)</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="p"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица перестановок не квадратная</exception>
            <exception cref="T:System.ArgumentException">Число строк матрицы не равно числу столбцов матрицы перестановок</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Permutation_Right(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Применение матрицы перестановок справа (перестановка столбцов)</summary>
            <param name="matrix">Матрица, подвергаемая перестановке столбцов</param>
            <param name="p">Матрица перестановок (столбцов)</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="p"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица перестановок не квадратная</exception>
            <exception cref="T:System.ArgumentException">Число строк матрицы не равно числу столбцов матрицы перестановок</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Permutation_Left_Internal(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Применение матрицы перестановок слева (перестановка строк) без проверок</summary>
            <param name="matrix">Матрица, подвергаемая перестановке строк</param>
            <param name="p">Матрица перестановок (строк)</param>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="p"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Permutation_Right_Internal(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Применение матрицы перестановок справа (перестановка столбцов) без проверок</summary>
            <param name="matrix">Матрица, подвергаемая перестановке столбцов</param>
            <param name="p">Матрица перестановок (столбцов)</param>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="p"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Create(System.Int32,System.Int32,System.Func{System.Int32,System.Int32,System.Double})">
            <summary>Создать и инициализировать двумерный массив-матрицу</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="Creator">Функция, принимающая номер строки и номер столбца и возвращающая значение элемента матрицы</param>
            <returns>Массив элементов матрицы</returns>
        </member>
        <member name="M:MathCore.Matrix.Array.CreateColArray(System.Double[])">
            <summary>Создать двумерный массив элементов матрицы-столбца</summary>
            <param name="data">Элементы массива матрицы-столбца</param>
            <returns>Двумерный массив элементов матрицы столбца</returns>
            <exception cref="T:System.ArgumentNullException">Если массив <paramref name="data"/> не определён</exception>
            <exception cref="T:System.ArgumentException">Если массив <paramref name="data"/> имеет длину 0</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.CreateRowArray(System.Double[])">
            <summary>Создать двумерный массив элементов матрицы-строки</summary>
            <param name="data">Элементы массива матрицы-строки</param>
            <returns>Двумерный массив элементов матрицы строки</returns>
            <exception cref="T:System.ArgumentNullException">Если массив <paramref name="data"/> не определён</exception>
            <exception cref="T:System.ArgumentException">Если массив <paramref name="data"/> имеет длину 0</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetLength(System.Double[0:,0:],System.Int32@,System.Int32@)">
            <summary>Получить размерность массива матрицы</summary>
            <param name="matrix">Массив элементов матрицы, размеры которого требуется получить</param>
            <param name="N">Число строк матрицы</param>
            <param name="M">Число столбцов (элементов строки) матрицы</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetRowsCount(System.Double[0:,0:],System.Int32@)">
            <summary>Получить число строк массива матрицы</summary>
            <param name="matrix">Массив элементов матрицы, размеры которого требуется получить</param>
            <param name="N">Число строк матрицы</param>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetColsCount(System.Double[0:,0:],System.Int32@)">
            <summary>Получить число столбцов (элементов строки) массива матрицы</summary>
            <param name="matrix">Массив элементов матрицы, размеры которого требуется получить</param>
            <param name="M">Число столбцов (элементов строки) матрицы</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetUnitaryArrayMatrix(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param>
            <returns>Квадратный двумерный массив размерности NxN с 1 на главной диагонали</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если размерность матрицы <paramref name="N"/> меньше 1</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.InitializeUnitaryMatrix(System.Double[0:,0:])">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <returns>Квадратный двумерный массив размерности NxN с 1 на главной диагонали</returns>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetTransvection(System.Double[0:,0:],System.Int32)">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="i0">Опорная строка</param>
            <returns>Трансвекция матрицы А</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="A"/></exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="A"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если опорная строка <paramref name="i0"/> матрицы <paramref name="A"/> &lt; 0 и &gt; числа строк матрицы</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Transvection(System.Double[0:,0:],System.Int32,System.Double[0:,0:])">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="j0">Опорный столбец</param>
            <param name="result">Двумерный массив элементов матрицы результата</param>
            <returns>Трансвекция матрицы А</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрицы <paramref name="A"/> и <paramref name="result"/> не заданы</exception>  
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="A"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если опорный столбец <paramref name="j0"/> матрицы <paramref name="A"/> меньше 0 или больше числа столбцов матрицы</exception>
            <exception cref="T:System.ArgumentException">В случае если размер матрицы <paramref name="result"/> не совпадает с размером матрицы <paramref name="A"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetCol(System.Double[0:,0:],System.Int32)">
            <summary>Получить столбец матрицы в виде матрицы</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="j">Номер столбца</param>
            <returns>Матрица-столбец, составленная из элементов столбца матрицы c индексом j</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер столбца <paramref name="j"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа столбцов матрицы</exception>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetCol_Array(System.Double[0:,0:],System.Int32)">
            <summary>Получить столбец матрицы в виде массива</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="j">Номер столбца</param>
            <returns>Массив, составленная из элементов столбца матрицы c индексом <paramref name="j"/></returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер столбца <paramref name="j"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа столбцов матрицы</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetCol_Array(System.Double[0:,0:],System.Int32,System.Double[])">
            <summary>Получить столбец матрицы в виде массива</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="j">Номер столбца</param>
            <param name="result">Массив, составленная из элементов столбца матрицы c индексом <paramref name="j"/></param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если массив <paramref name="result"/> не задан</exception>
            <exception cref="T:System.ArgumentException">В случае если размер массива <paramref name="result"/> не соответствует числу строк матрицы</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер столбца <paramref name="j"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа столбцов матрицы</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetRow(System.Double[0:,0:],System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="i">Номер строки</param>
            <returns>Матрица-строка, составленная из элементов строки матрицы с индексом <paramref name="i"/></returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер строки <paramref name="i"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа строк матрицы</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetRow_Array(System.Double[0:,0:],System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="i">Номер строки</param>
            <returns>Массив, составленный из элементов строки матрицы с индексом <paramref name="i"/></returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер строки <paramref name="i"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа строк матрицы</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetRow_Array(System.Double[0:,0:],System.Int32,System.Double[])">
            <summary>Получить строку матрицы</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="i">Номер строки</param>
            <param name="result">Массив, составленный из элементов строки матрицы с индексом i</param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если массив <paramref name="result"/> не задан</exception>
            <exception cref="T:System.ArgumentException">В случае если размер массива <paramref name="result"/> не соответствует числу столбцов матрицы</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер строки <paramref name="i"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа строк матрицы</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Inverse(System.Double[0:,0:])">
            <summary>Получить обратную матрицу</summary>
            <param name="matrix">Обращаемая матрица</param>
            <returns>Обратная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.InvalidOperationException">Невозможно найти обратную матрицу для вырожденной матрицы</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Inverse(System.Double[0:,0:],System.Double[0:,0:]@)">
            <summary>Получить обратную матрицу</summary>
            <param name="matrix">Обращаемая матрица</param>
            <param name="p">Матрица перестановок</param>
            <returns>Обратная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.InvalidOperationException">Невозможно найти обратную матрицу для вырожденной матрицы</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Размерность массива 0х0</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Inverse(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Получить обратную матрицу</summary>
            <param name="matrix">Матрица, подлежащая обращению</param>
            <param name="result">Обратная матрица</param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="result"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetSolve(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:]@)">
            <summary>Метод решения СЛАУ A*X=B -&gt; X</summary>
            <param name="matrix">Матрица СЛАУ</param>
            <param name="b">Правая часть СЛАУ</param>
            <param name="p">Матрица перестановок</param>
            <returns>Матрица решения уравнения A*X=B -&gt; X</returns>
            <exception cref="T:System.InvalidOperationException">Невозможно найти обратную матрицу для вырожденной матрицы</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">В случае если матрица системы <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Solve(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Boolean)">
            <summary>Метод решения СЛАУ</summary>
            <param name="matrix">Матрица СЛАУ</param>
            <param name="b">Правая часть СЛАУ</param>
            <param name="p">Матрица перестановок</param>
            <param name="clone_b">Работать с копией <paramref name="b"/></param>
            <exception cref="T:System.InvalidOperationException">Невозможно найти обратную матрицу для вырожденной матрицы</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">В случае если матрица системы <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.TrySolve(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Boolean)">
            <summary>Попытаться решить СЛАУ</summary>
            <param name="matrix">Матрица СЛАУ</param>
            <param name="b">Правая часть СЛАУ</param>
            <param name="p">Матрица перестановок</param>
            <param name="clone_b">Работать с копией <paramref name="b"/></param>
            <returns>Истина, если решение СЛАУ получено; ложь - если матрица СЛАУ <paramref name="matrix"/> вырождена</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="b"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">В случае если матрица системы <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Transpose(System.Double[0:,0:])">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Transpose(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Транспонирование матрицы</summary>
            <param name="matrix">Исходная матрица</param>
            <param name="result">Транспонированная матрица</param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="result"/> не задана</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetAdjunct(System.Double[0:,0:],System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="n">Номер строки</param>
            <param name="m">Номер столбца</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер строки <paramref name="n"/> меньше 0, или больше, либо равен числу строк матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер столбца <paramref name="m"/> меньше 0, или больше, либо равен числу столбцов матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.CopyMinor(System.Double[0:,0:],System.Int32,System.Int32,System.Int32,System.Int32,System.Double[0:,0:])">
            <summary>Скопировать минор из матрицы в матрицу результата</summary>
            <param name="matrix">Массив элементов исходной матрицы</param>
            <param name="n">Номер строки</param>
            <param name="m">Номер столбца</param>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="result">Минор матрицы</param>
        </member>
        <member name="M:MathCore.Matrix.Array.GetMinor(System.Double[0:,0:],System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="n">Номер строки</param>
            <param name="m">Номер столбца</param>
            <returns>Минор элемента матрицы [n,m]</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер строки <paramref name="n"/> меньше 0, или больше, либо равен числу строк матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер столбца <paramref name="m"/> меньше 0, или больше, либо равен числу столбцов матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetMinor(System.Double[0:,0:],System.Int32,System.Int32,System.Double[0:,0:])">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="n">Номер строки</param>
            <param name="m">Номер столбца</param>
            <param name="result">Минор элемента матрицы [n,m]</param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер строки <paramref name="n"/> меньше 0, или больше, либо равен числу строк матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер столбца <paramref name="m"/> меньше 0, или больше, либо равен числу столбцов матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentException">В случае если число строк матрицы результата <paramref name="result"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentException">В случае если число столбцов матрицы результата <paramref name="result"/> не равно числу столбцов исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetDeterminant(System.Double[0:,0:])">
            <summary>Определитель матрицы</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Определитель матрицы</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Swap``1(``0@,``0@)">
            <summary>Поменять значения местами</summary>
            <typeparam name="T">Тип значения</typeparam>
        </member>
        <member name="M:MathCore.Matrix.Array.GetLUPDecomposition(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double@)">
            <summary>Разложение матрицы на верхне-треугольную и нижне-треугольную</summary>
            <remarks>
            This method is based on the 'LU Decomposition and Its Applications' 
            section of Numerical Recipes in C by William H. Press, Saul A. Teukolsky, William T. 
            Vetterling and Brian P. Flannery,  University of Cambridge Press 1992.  
            </remarks>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="l">Нижне-треугольная матрица</param>
            <param name="u">Верхне-треугольная матрица</param>
            <param name="p">Матрица преобразований P*X = L*U</param>
            <param name="d">Определитель матрицы</param>
            <returns>Истина, если процедура декомпозиции прошла успешно. Ложь, если матрица вырождена</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если размерность матрицы <paramref name="matrix"/> меньше 1</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetLUDecomposition(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double@)">
            <summary>Разложение матрицы на верхне-треугольную и нижне-треугольную</summary>
            <remarks>
            This method is based on the 'LU Decomposition and Its Applications' 
            section of Numerical Recipes in C by William H. Press, Saul A. Teukolsky, William T. 
            Vetterling and Brian P. Flannery,  University of Cambridge Press 1992.  
            </remarks>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="l">Нижне-треугольная матрица</param>
            <param name="u">Верхне-треугольная матрица</param>
            <param name="d">Определитель матрицы</param>
            <returns>Истина, если процедура декомпозиции прошла успешно. Ложь, если матрица вырождена</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу matrix</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если размерность матрицы N меньше 1</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetLUPDecomposition(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double@)">
            <summary>Разложение матрицы на верхне-треугольную и нижне-треугольную</summary>
            <remarks>
            This method is based on the 'LU Decomposition and Its Applications' 
            section of Numerical Recipes in C by William H. Press, Saul A. Teukolsky, William T. 
            Vetterling and Brian P. Flannery,  University of Cambridge Press 1992.  
            </remarks>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="c">Матрица с результатами разложения: элементы ниже главной диагонали - матрица L, элементы выше - матрица U</param>
            <param name="p">Массив матрицы перестановок</param>
            <param name="d">Определитель матрицы</param>
            <returns>Истина, если операция выполнена успешно</returns>
            <exception cref="T:System.ArgumentException">Матрица не квадратная</exception>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу matrix</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetLUPDecomposition(System.Double[0:,0:],System.Double[0:,0:]@,System.Double@)">
            <summary>LU-разложение матрицы</summary>
            <param name="matrix">Разлагаемая матрица</param>
            <param name="c">Матрица с результатами разложения: элементы ниже главной диагонали - матрица L, элементы выше - матрица U</param>
            <param name="d">Определитель матрицы</param>
            <returns>Истина, если процедура выполнена успешно</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу matrix</exception>
            <exception cref="T:System.ArgumentException">Матрица не квадратная</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetLUDecomposition(System.Double[0:,0:],System.Double[0:,0:]@)">
            <summary>LU-разложение матрицы</summary>
            <param name="matrix">Разлагаемая матрица</param>
            <param name="c">Матрица с результатами разложения: элементы ниже главной диагонали - матрица L, элементы выше - матрица U</param>
            <returns>Истина, если разложение выполнено успешно</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу matrix</exception>
            <exception cref="T:System.ArgumentException">Матрица не квадратная</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.CreatePermutationMatrix(System.Int32[])">
            <summary>Создать матрицу перестановок из массива индексов</summary>
            <param name="indexes">Массив индексов элементов столбцов</param>
            <returns>Матрица перестановок</returns>
        </member>
        <member name="M:MathCore.Matrix.Array.GetTriangle(System.Double[0:,0:],System.Double[0:,0:]@,System.Int32@,System.Double@)">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="p">Матрица перестановок</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <returns>Треугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetTriangle(System.Double[0:,0:],System.Int32@,System.Double@)">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <returns>Треугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetTriangle(System.Double[0:,0:],System.Double[0:,0:],System.Int32@,System.Double@)">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="b">Матрица правой части</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <returns>Треугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetTriangle(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Int32@,System.Double@,System.Boolean)">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="b">Матрица правой части</param>
            <param name="p">Матрица перестановок</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <param name="clone_b">Клонировать матрицу правых частей</param>
            <returns>Треугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Triangulate(System.Double[0:,0:],System.Double[0:,0:]@,System.Double@)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к треугольному виду</param>
            <param name="p">Матрица перестановок</param>
            <param name="d">Определитель матрицы (произведение диагональных элементов)</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Triangulate(System.Double[0:,0:],System.Double@)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к треугольному виду</param>
            <param name="d">Определитель матрицы (произведение диагональных элементов)</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Triangulate(System.Double[0:,0:],System.Double[0:,0:],System.Double@)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к треугольному виду</param>
            <param name="b">Присоединённая матрица, над которой выполняются те же операции, что и над <paramref name="matrix"/></param>
            <param name="d">Определитель матрицы (произведение диагональных элементов)</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Triangulate(System.Double[0:,0:]@,System.Double[0:,0:],System.Double@,System.Boolean)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к треугольному виду</param>
            <param name="b">Присоединённая матрица, над которой выполняются те же операции, что и над <paramref name="matrix"/></param>
            <param name="d">Определитель матрицы (произведение диагональных элементов)</param>
            <param name="clone">Клонировать исходную матрицу</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Triangulate(System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double@,System.Boolean,System.Boolean)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к треугольному виду</param>
            <param name="b">Присоединённая матрица, над которой выполняются те же операции, что и над <paramref name="matrix"/></param>
            <param name="p">Матрица перестановок</param>
            <param name="d">Определитель матрицы (произведение диагональных элементов)</param>
            <param name="clone_matrix">Клонировать исходную матрицу</param>
            <param name="clone_b">Клонировать присоединённую матрицу</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.AreEquals(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Сравнение двух двумерных массивов элементов матриц</summary>
            <param name="A">Первый массив</param>
            <param name="B">Второй массив</param>
            <returns>Истина, если оба массивы не определены, либо если оба массивы - один и тот же массив, либо если элементы массивов идентичны</returns>
            <exception cref="T:System.ArgumentNullException">matrix is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.AreEquals(System.Double[0:,0:],System.Double[0:,0:],System.Double)">
            <summary>Сравнение двух двумерных массивов элементов матриц</summary>
            <param name="A">Первый массив</param>
            <param name="B">Второй массив</param>
            <param name="eps">Точность сравнения</param>
            <returns>Истина, если оба массивы не определены, либо если оба массивы - один и тот же массив, либо если элементы массивов идентичны</returns>
            <exception cref="T:System.ArgumentNullException">matrix is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetMaxRowAbsSum(System.Double[0:,0:])">
            <summary>Вычисление максимума от сумм абсолютных значений по элементам строк</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Максимальная из сумм абсолютных значений элементов строк</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetMaxColAbsSum(System.Double[0:,0:])">
            <summary>Вычисление максимума от сумм абсолютных значений по элементам столбцов</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Максимальная из сумм абсолютных значений элементов столбцов</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetRMS(System.Double[0:,0:])">
            <summary>Вычисление среднеквадратичного значения элементов матрицы</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Среднеквадратичное значение элементов матрицы</returns>
            <exception cref="T:System.ArgumentNullException">matrix is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Sqr(System.Double)">
            <summary>Квадрат числа</summary>
            <param name="x">Значение, квадрат которого требуется получить</param>
            <returns>Квадрат указанного числа</returns>
        </member>
        <member name="M:MathCore.Matrix.Array.GaussSeidelConverge(System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double,System.Int32,System.Int32)">
            <summary>Метод проверки сходимости метода Метод Гаусса — Зейделя</summary>
            <remarks>Метод меняет местами матрицы решения текущего и прошлого шагов, если метод Гаусса — Зейделя не сошёлся на текущем шаге</remarks>
            <param name="new_x">Новое полученное решение</param>
            <param name="last_x">Решение, полученное на прошлом шаге метода</param>
            <param name="eps">Требуемая точность решения</param>
            <param name="N">Число строк матрицы решения</param>
            <param name="M">Число столбцов матрицы решения</param>
            <returns>Истина, если метод сошёлся Метод Гаусса — Зейделя</returns>
        </member>
        <member name="M:MathCore.Matrix.Array.GaussSeidelSolve(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:],System.Double)">
            <summary>Метод Гаусса — Зейделя решения системы линейных уравнений</summary>
            <param name="matrix">Матрица коэффициентов</param>
            <param name="x">Матрица неизвестных</param>
            <param name="b">Матрица правых частей</param>
            <param name="eps">Требуемая точность</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="x"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="b"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица системы не содержит элементов</exception>
            <exception cref="T:System.ArgumentException">Матрица системы не квадратная</exception>
            <exception cref="T:System.ArgumentException">Число строк массива неизвестных не совпадает с числом строк матрицы системы</exception>
            <exception cref="T:System.ArgumentException">Число строк массива правой части СЛАУ не совпадает с числом строк матрицы системы</exception>
            <exception cref="T:System.ArgumentException">Число столбцов массива правых частей не совпадает с числом столбцов массива неизвестных</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="eps"/> &lt;= <see cref="T:System.Double"/>.<see cref="F:System.Double.Epsilon"/></exception> Solve
        </member>
        <member name="M:MathCore.Matrix.Array.QRDecomposition(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:])">
            <summary>QR-разложение матрицы</summary>
            <param name="matrix">Разлагаемая матрица</param>
            <param name="q">Унитарная матрица (ортогональная) - должна быть передана квадратная матрица nxn != null</param>
            <param name="r">Верхне-треугольная матрица - должна быть передана квадратная матрица nxn != null</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица не содержит элементов</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.QRDecomposition(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@)">
            <summary>QR-разложение матрицы</summary>
            <param name="matrix">Разлагаемая матрица</param>
            <param name="q">Унитарная матрица (ортогональная) - создаётся квадратная матрица nxn != null</param>
            <param name="r">Верхне-треугольная матрица - создаётся квадратная матрица nxn != null</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица не содержит элементов</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.SVD(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[]@,System.Double[0:,0:]@)">
            <summary>SVD-разложение</summary>
            <param name="matrix">Разлагаемая матрица</param>
            <param name="u">Матрица левых сингулярных векторов</param>
            <param name="w">Вектор собственных чисел</param>
            <param name="v">Матрица правых сингулярных векторов</param>
            <exception cref="T:System.ArgumentNullException">matrix is <see langword="null"/></exception>
            <exception cref="T:System.InvalidOperationException">Метод не сошёлся за 30 итераций</exception>
        </member>
        <member name="T:MathCore.Matrix.Array.Operator">
            <summary>Операторы над двумерными массивами</summary>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Multiply(System.Double[],System.Double[])">
            <summary>Скалярное произведение векторов</summary>
            <param name="v1">Первый множитель скалярного произведения</param>
            <param name="v2">второй множитель скалярного произведения</param>
            <returns>Скалярное произведение векторов</returns>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.VectorLength(System.Double[])">
            <summary>Длина вектора</summary>
            <param name="v">Вектор элементов</param>
            <returns>Длина вектора</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="v"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Multiply(System.Double[],System.Double)">
            <summary>Умножение вектора на число</summary>
            <param name="v1">Первый сомножитель - вектор элементов</param>
            <param name="v2">Второй сомножитель - число, на которое должны быть умножены все элементы вектора</param>
            <returns>Вектор произведений элементов входного вектора и числа</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="v1"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Divide(System.Double[],System.Double)">
            <summary>Деление вектора элементов на число</summary>
            <param name="v1">Вектор-делимое</param>
            <param name="v2">Число-делитель</param>
            <returns>Вектор, составленный из частного элементов вектора-делимого и числового делителя</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="v1"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Projection(System.Double[],System.Double[])">
            <summary>Проекция вектора на вектор</summary>
            <returns>Вектор - произведение компонентов исходных векторов</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="v1"/> or <paramref name="v2"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Длины векторов не совпадают</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Add(System.Double[0:,0:],System.Double)">
            <summary>Оператор вычисления суммы двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив суммы элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Add(System.Double[],System.Double[])">
            <summary>Поэлементное сложение двух матриц</summary>
            <param name="a">Матрица - первое слагаемое</param>
            <param name="b">Матрица - второе слагаемое</param>
            <returns>Матрица, составленная из элементов - сумм элементов исходных матриц</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> or <paramref name="b"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Subtract(System.Double[],System.Double[])">
            <summary>Оператор вычитания между двумя столбцами</summary>
            <param name="a">Столбец уменьшаемого</param>
            <param name="b">Столбец вычитаемого</param>
            <returns>Вектор-столбец разности указанных векторов</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> or <paramref name="b"/> is <see langword="null"/></exception>
            <exception cref="T:System.InvalidOperationException">Размеры векторов не совпадают</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.MultiplyComponent(System.Double[],System.Double[])">
            <summary>Оператор вычисления поэлементного произведения двух векторов</summary>
            <param name="a">Вектор элементов первого множителя</param>
            <param name="b">Вектор элементов второго множителя</param>
            <returns>Вектор элементов произведения</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> or <paramref name="b"/> is <see langword="null"/></exception>
            <exception cref="T:System.InvalidOperationException">Размеры векторов не совпадают</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.DivideComponent(System.Double[],System.Double[])">
            <summary>Оператор вычисления поэлементного деления двух векторов</summary>
            <param name="a">Вектор - делимое</param>
            <param name="b">Вектор - делитель</param>
            <returns>Вектор, составленный из поэлементного частного элементов векторов делимого и делителя</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> or <paramref name="b"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Subtract(System.Double[0:,0:],System.Double)">
            <summary>Оператор вычисления разности двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив разности элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Subtract(System.Double,System.Double[0:,0:])">
            <summary>Оператор вычисления разности двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив разности элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Multiply(System.Double[0:,0:],System.Double)">
            <summary>Оператор вычисления произведения двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив произведения элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Divide(System.Double[0:,0:],System.Double)">
            <summary>Оператор вычисления произведения двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив произведения элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Divide(System.Double,System.Double[0:,0:])">
            <summary>Оператор вычисления частного двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив частного элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Add(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Оператор вычисления суммы элементов двух матриц</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="B">Массив элементов второй матрицы</param>
            <returns>Массив суммы элементов двух матриц</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матрицы не равны</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Subtract(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Оператор вычисления разности элементов двух матриц</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="B">Массив элементов второй матрицы</param>
            <returns>Массив разности элементов двух матриц</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матрицы не равны</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.MultiplyCol(System.Double[0:,0:],System.Double[])">
            <summary>Оператор вычисления произведения элементов матрицы на столбец</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="col">Массив элементов столбца</param>
            <returns>Массив произведения элементов матрицы и столбца</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="col"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матрицы и столбца не равны</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.MultiplyRow(System.Double[],System.Double[0:,0:])">
            <summary>Оператор вычисления произведения элементов строки и матрицы</summary>
            <param name="B">Массив элементов первой матрицы</param>
            <param name="row">Массив элементов строки</param>
            <returns>Массив произведения элементов матрицы и столбца</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="row"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матрицы и строки не равны</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.MultiplyRowToCol(System.Double[],System.Double[])">
            <summary>Оператор вычисления произведения элементов строки и элементов столбца</summary>
            <param name="col">Массив элементов столбца</param>
            <param name="row">Массив элементов строки</param>
            <returns>Массив произведения элементов строки и столбца</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="col"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="row"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности строки и столбца не равны</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Multiply(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Оператор вычисления произведения двух матриц</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="B">Массив элементов второй матрицы</param>
            <returns>Массив произведения двух матриц</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Multiply(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Оператор вычисления произведения двух матриц</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="B">Массив элементов второй матрицы</param>
            <param name="result">Массив элементов произведения</param>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="result"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матриц не согласованы</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк <paramref name="result"/> не равно числу строк <paramref name="A"/></exception>
            <exception cref="T:System.ArgumentException">В случае если число столбцов <paramref name="result"/> не равно числу строк <paramref name="B"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Divide(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param>
            <param name="B">Делитель</param>
            <returns>Частное двух матриц</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матриц не согласованы</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Concatenate(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Объединение матриц по строкам, либо столбцам</summary>
            <returns>Двумерный массив, содержащий объединение элементов исходных массивов по строкам, либо столбцам</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="A"/> or <paramref name="B"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.BiliniarMultiply(System.Double[],System.Double[0:,0:],System.Double[])">
            <summary>Оператор вычисления билинейной формы с векторными операндами b = <paramref name="x"/>*<paramref name="a"/>*<paramref name="y"/></summary>
            <param name="x">Массив компонент левой строки билинейной формы</param>
            <param name="a">Матрица билинейной формы</param>
            <param name="y">Массив компонент правого столбца билинейной формы</param>
            <returns>Результат вычисления билинейной формы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="x"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="y"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Если длина строки <paramref name="x"/> не равна числу строк матрицы <paramref name="a"/></exception>
            <exception cref="T:System.ArgumentException">Если длина столбца <paramref name="y"/> не равна числу столбцов матрицы <paramref name="a"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.BiliniarMultiply(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Оператор вычисления билинейной формы с векторными операндами b = <paramref name="x"/>*<paramref name="a"/>*<paramref name="y"/></summary>
            <param name="x">Двумерный массив компонент матрицы первого операнда билинейной формы</param>
            <param name="a">Двумерный массив компонент матрицы оператора билинейной нормы</param>
            <param name="y">Двумерный массив компонент матрицы второго операнда билинейной формы</param>
            <returns>
            Двумерный массив компонент матрицы результата вычисления билинейной формы, 
            число строк которого равно числу строк операнда <paramref name="x"/>, число столбцов - равно числу столбцов операнда <paramref name="y"/>
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="x"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="y"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Число столбцов <paramref name="x"/> не равно числу строк <paramref name="a"/></exception>
            <exception cref="T:System.ArgumentException">Число строк <paramref name="y"/> не равно числу столбцов <paramref name="a"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.BiliniarMultiplyAuto(System.Double[],System.Double[0:,0:])">
            <summary>Вычисление оператора билинейной формы для одного операнда B = X*A*X^T</summary>
            <param name="x">Элементы массива вектора операнда оператора билинейной формы</param>
            <param name="a">Элементы двумерного массива матрицы оператора билинейной формы (должна быть квадратной с числом строк, равным числу элементов вектора операнда <paramref name="x"/>)</param>
            <returns>Численное значение результата вычисления билинейной формы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="x"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Если массив элементов матрицы <paramref name="a"/> не квадратный</exception>
            <exception cref="T:System.ArgumentException">Если число элементов вектора <paramref name="x"/> не равно числу строк массива элементов матрицы <paramref name="a"/></exception>
        </member>
        <member name="M:MathCore.Matrix.SVD(MathCore.Matrix@,System.Double[]@,MathCore.Matrix@)">
            <summary>SVD-разложение матрицы</summary>
            <param name="U"></param>
            <param name="w"></param>
            <param name="V"></param>
        </member>
        <member name="M:MathCore.Matrix.SVD(MathCore.Matrix@,MathCore.Matrix@,MathCore.Matrix@)">
            <summary>SVD-разложение матрицы</summary>
            <param name="U"></param>
            <param name="S"></param>
            <param name="V"></param>
        </member>
        <member name="M:MathCore.Matrix.op_Explicit(MathCore.Matrix)~MathCore.MatrixInt">
            <summary>Оператор явного приведения вещественной матрицы к целочисленной</summary>
            <param name="matrix">Вещественная матрица</param>
        </member>
        <member name="M:MathCore.Matrix.CreateCol(System.Double[])">
            <summary>Создать матрицу-столбец</summary><param name="data">Элементы столбца</param><returns>Матрица-столбец</returns>
            <exception cref="T:System.ArgumentNullException">Если массив <paramref name="data"/> не определён</exception>
            <exception cref="T:System.ArgumentException">Если массив <paramref name="data"/> имеет длину 0</exception>
        </member>
        <member name="M:MathCore.Matrix.CreateRow(System.Double[])">
            <summary>Создать матрицу-строку</summary><param name="data">Элементы строки</param><returns>Матрица-строка</returns>
            <exception cref="T:System.ArgumentNullException">Если массив <paramref name="data"/> не определён</exception>
            <exception cref="T:System.ArgumentException">Если массив <paramref name="data"/> имеет длину 0</exception>
        </member>
        <member name="M:MathCore.Matrix.CreateDiagonalMatrix(System.Double[])">
            <summary>Создать диагональную матрицу</summary><param name="elements">Элементы диагональной матрицы</param>
            <returns>Диагональная матрица</returns>
        </member>
        <member name="M:MathCore.Matrix.GetUnitaryMatrix(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param><returns>Единичная матрица размерности NxN с 1 на главной диагонали</returns>
        </member>
        <member name="M:MathCore.Matrix.GetTransvection(MathCore.Matrix,System.Int32)">
            <summary>Трансвекция матрицы</summary><param name="A">Трансвецируемая матрица</param><param name="j">Опорный столбец</param>
            <returns>Трансвекция матрицы А</returns>                    
        </member>
        <member name="F:MathCore.Matrix._N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="F:MathCore.Matrix._M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="F:MathCore.Matrix._Data">
            <summary>Элементы матрицы</summary>
        </member>
        <member name="P:MathCore.Matrix.N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="P:MathCore.Matrix.M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="P:MathCore.Matrix.Item(System.Int32,System.Int32)">
            <summary>Элемент матрицы</summary>
            <param name="i">Номер строки (элемента в столбце)</param>
            <param name="j">Номер столбца (элемента в строке)</param>
            <returns>Элемент матрицы</returns>
        </member>
        <member name="P:MathCore.Matrix.Item(System.Int32)">
            <summary>Вектор-столбец</summary><param name="j">Номер столбца</param><returns>Столбец матрицы</returns>
        </member>
        <member name="P:MathCore.Matrix.IsSquare">
            <summary>Матрица является квадратной матрицей</summary>
        </member>
        <member name="P:MathCore.Matrix.IsCol">
            <summary>Матрица является столбцом</summary>
        </member>
        <member name="P:MathCore.Matrix.IsRow">
            <summary>Матрица является строкой</summary>
        </member>
        <member name="P:MathCore.Matrix.IsScalar">
            <summary>Матрица является числом</summary>
        </member>
        <member name="P:MathCore.Matrix.T">
            <summary>Транспонированная матрица</summary>
        </member>
        <member name="P:MathCore.Matrix.Norm_m">
            <summary>Максимум среди абсолютных сумм элементов строк</summary>
        </member>
        <member name="P:MathCore.Matrix.Norm_l">
            <summary>Максимум среди абсолютных сумм элементов столбцов</summary>
        </member>
        <member name="P:MathCore.Matrix.Norm_k">
            <summary>Среднеквадратичное значение элементов матрицы</summary>
        </member>
        <member name="M:MathCore.Matrix.#ctor(System.Int32,System.Int32)">
            <summary>Матрица</summary><param name="N">Число строк</param><param name="M">Число столбцов</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="N"/> &lt; 0 || <paramref name="M"/> &lt; 0</exception>
        </member>
        <member name="M:MathCore.Matrix.#ctor(System.Int32)">
            <summary>Квадратная матрица</summary><param name="N">Размерность</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="N" /> &lt; 0</exception>
        </member>
        <member name="T:MathCore.Matrix.MatrixItemCreator">
            <summary>Метод определения значения элемента матрицы</summary>
            <param name="i">Номер строки</param><param name="j">Номер столбца</param>
            <returns>Значение элемента матрицы M[<paramref name="i"/>, <paramref name="j"/>]</returns>
        </member>
        <member name="M:MathCore.Matrix.#ctor(System.Int32,MathCore.Matrix.MatrixItemCreator)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathCore.Matrix.#ctor(System.Int32,System.Int32,MathCore.Matrix.MatrixItemCreator)">
            <summary>Матрица</summary><param name="N">Число строк</param><param name="M">Число столбцов</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathCore.Matrix.#ctor(System.Double[0:,0:],System.Boolean)">
            <summary>Инициализация новой матрицы по двумерному массиву её элементов</summary>
            <param name="Data">Двумерный массив элементов матрицы</param>
            <param name="clone">Создать копию данных</param>
        </member>
        <member name="M:MathCore.Matrix.#ctor(System.Collections.Generic.IList{System.Double},System.Boolean)">
            <summary>Инициализация новой матрицы - столбца/строки</summary>
            <param name="DataCol">Элементы столбца матрицы</param>
            <param name="IsColumn">Создаётся матрица-столбец</param>
        </member>
        <member name="M:MathCore.Matrix.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Double}})">
            <summary>Инициализация новой матрицы на основе перечисления строк (перечисления элементов строк) </summary>
            <param name="Items">Перечисление строк, состоящих из перечисления элементов строк</param>
        </member>
        <member name="M:MathCore.Matrix.GetElements(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Double}})">
            <summary>Получить двумерный массив элементов матрицы</summary>
            <param name="ColsItems">Перечисление элементов (по столбцам)</param>
            <returns>Двумерный массив элементов матрицы</returns>
        </member>
        <member name="M:MathCore.Matrix.GetCol(System.Int32)">
            <summary>Получить столбец матрицы</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы номер j</returns>
        </member>
        <member name="M:MathCore.Matrix.GetRow(System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="i">Номер строки</param>
            <returns>Строка матрицы номер i</returns>
        </member>
        <member name="M:MathCore.Matrix.GetTriangle(MathCore.Matrix@,System.Int32@,System.Double@)">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <param name="P">Матрица перестановок</param>
            <param name="rank">Ранг матрицы</param>
            <param name="D">Определитель</param>
            <returns>Треугольная матрица</returns>
        </member>
        <member name="M:MathCore.Matrix.GetTriangle(MathCore.Matrix@,System.Boolean)">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <param name="B">Присоединённая матрица правой части СЛАУ</param>
            <param name="CloneB">Работать с клоном матрицы <paramref name="B"/></param>
            <returns>Треугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">Если <paramref name="B"/> <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.GetTriangle(MathCore.Matrix@,MathCore.Matrix@,System.Int32@,System.Double@,System.Boolean)">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <param name="B">Матрица правой части СЛАУ</param>
            <param name="P">Матрица перестановок</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <param name="CloneB">Клонировать матрицу правой части</param>
            <returns>Треугольная матрица</returns>
        </member>
        <member name="M:MathCore.Matrix.GetInverse(MathCore.Matrix@)">
            <summary>Получить обратную матрицу</summary>                                                     
            <param name="P">Матрица перестановок</param>
            <returns>Обратная матрица</returns>
        </member>
        <member name="M:MathCore.Matrix.GetTranspose">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
        </member>
        <member name="M:MathCore.Matrix.GetAdjunct(System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
        </member>
        <member name="M:MathCore.Matrix.GetMinor(System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
        </member>
        <member name="M:MathCore.Matrix.GetDeterminant">
            <summary>Определитель матрицы</summary>
        </member>
        <member name="M:MathCore.Matrix.GetLUDecomposition(MathCore.Matrix@,MathCore.Matrix@,MathCore.Matrix@,System.Double@)">
            <summary>Разложение матрицы на верхне-треугольную и нижне-треугольную</summary>
            <param name="L">Нижне-треугольная матрица</param>
            <param name="U">Верхне-треугольная матрица</param>
            <param name="P">Матрица преобразований P*X = L*U</param>
            <param name="D">Знак определителя</param>
            <returns>Истина, если разложение выполнено успешно, ложь - если матрица вырожденная</returns>
        </member>
        <member name="M:MathCore.Matrix.GetData">
            <summary>Получить внутренний массив элементов матрицы</summary>
            <returns></returns>
        </member>
        <member name="M:MathCore.Matrix.ToString">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.Matrix.ToStringFormat(System.String,System.String,System.IFormatProvider)">
            <summary>Преобразование матрицы в строку с форматированием</summary>
            <param name="Format">Строка формата вывода чисел</param>
            <param name="Splitter">Разделитель элементов матрицы</param>
            <param name="provider">Механизм форматирования чисел матрицы</param>
            <returns>Строковое представление матрицы</returns>
        </member>
        <member name="M:MathCore.Matrix.ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.Matrix.System#ICloneable#Clone">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.Matrix.MathCore#ICloneable{System#Double[,]}#Clone">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.Matrix.Clone">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.Matrix.op_Equality(MathCore.Matrix,MathCore.Matrix)">
            <summary>Оператор равенства двух матриц</summary>
            <returns>Истина, если матрицы совпадают по размеру и поэлементно</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Inequality(MathCore.Matrix,MathCore.Matrix)">
            <summary>Оператор неравенства двух матриц</summary>
            <returns>Истина, если матрицы не совпадают по размеру или поэлементно</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Equality(System.Double[0:,0:],MathCore.Matrix)">
            <summary>Оператор равенства матрицы и двумерного массива</summary>
            <returns>Истина, если матрица и двумерный массив совпадают по размеру и поэлементно</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Equality(MathCore.Matrix,System.Double[0:,0:])">
            <summary>Оператор равенства матрицы и двумерного массива</summary>
            <returns>Истина, если матрица и двумерный массив совпадают по размеру и поэлементно</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Inequality(System.Double[0:,0:],MathCore.Matrix)">
            <summary>Оператор неравенства матрицы и двумерного массива</summary>
            <returns>Истина, если матрица и двумерный массив не совпадают по размеру или поэлементно</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Inequality(MathCore.Matrix,System.Double[0:,0:])">
            <summary>Оператор неравенства матрицы и двумерного массива</summary>
            <returns>Истина, если матрица и двумерный массив не совпадают по размеру или поэлементно</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Addition(MathCore.Matrix,System.Double)">
            <summary>Оператор суммы матрицы и числа</summary>
            <returns>Матрица, элементы которой равны сумме элементов исходной матрицы и числа</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Addition(System.Double,MathCore.Matrix)">
            <summary>Оператор суммы матрицы и числа</summary>
            <returns>Матрица, элементы которой равны сумме элементов исходной матрицы и числа</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Subtraction(MathCore.Matrix,System.Double)">
            <summary>Оператор разности матрицы и числа</summary>
            <returns>Матрица, элементы которой равны разности элементов исходной матрицы и числа</returns>
        </member>
        <member name="M:MathCore.Matrix.op_UnaryNegation(MathCore.Matrix)">
            <summary>Оператор отрицания элементов матрицы</summary>
            <returns>Матрица, элементы которой являются отрицательными по отношению к элементам исходной матрицы</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Subtraction(System.Double,MathCore.Matrix)">
            <summary>Оператор разности числа и матрицы</summary>
            <returns>Матрица, элементы которой равны разности числа и элементов исходной матрицы</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Multiply(MathCore.Matrix,System.Double)">
            <summary>Оператор произведения матрицы и числа</summary>
            <returns>Матрица, элементы которой равны произведения элементов исходной матрицы и числа</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Multiply(System.Double,MathCore.Matrix)">
            <summary>Оператор суммы матрицы и числа</summary>
            <returns>Матрица, элементы которой равны сумме элементов исходной матрицы и числа</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Multiply(System.Double[0:,0:],MathCore.Matrix)">
            <summary>Оператор матричного произведения двумерного массива и матрицы</summary>
            <returns>Матрица - результат матричного умножения двухмерного массива и матрицы</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Multiply(System.Double[],MathCore.Matrix)">
            <summary>Оператор матричного произведения одномерного массива (строки) и матрицы</summary>
            <returns>Матрица - результат матричного умножения одномерного массива (строки) и матрицы</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Multiply(MathCore.Matrix,System.Double[])">
            <summary>Оператор матричного произведения матрицы и одномерного массива (столбца)</summary>
            <returns>Матрица - результат матричного умножения матрицы и одномерного массива (столбца)</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Multiply(MathCore.Matrix,System.Double[0:,0:])">
            <summary>Оператор матричного произведения матрицы и двумерного массива</summary>
            <returns>Матрица - результат матричного умножения матрицы и двумерного массива</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Division(MathCore.Matrix,System.Double)">
            <summary>Оператор деления матрицы и числа</summary>
            <returns>Матрица, элементы которой равны результату деления элементов исходной матрицы и числа</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Division(System.Double,MathCore.Matrix)">
            <summary>Оператор деления числа и матрицы</summary>
            <returns>Матрица, элементы которой равны результату деления числа и элементов исходной матрицы</returns>
        </member>
        <member name="M:MathCore.Matrix.op_ExclusiveOr(MathCore.Matrix,System.Int32)">
            <summary>Оператор возведения матрицы в степень</summary>
            <param name="M">Матрица - основание</param>
            <param name="n">Показатель степени</param>
            <returns>Матрица - результат возведения исходной матрицы в целую степень</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Addition(MathCore.Matrix,MathCore.Matrix)">
            <summary>Оператор сложения двух матриц</summary>
            <param name="A">Первое слагаемое</param><param name="B">Второе слагаемое</param><returns>Сумма двух матриц</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Subtraction(MathCore.Matrix,MathCore.Matrix)">
            <summary>Оператор разности двух матриц</summary>
            <param name="A">Уменьшаемое</param><param name="B">Вычитаемое</param><returns>Разность двух матриц</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Multiply(MathCore.Matrix,MathCore.Matrix)">
            <summary>Оператор произведения двух матриц</summary>
            <param name="A">Первый сомножитель</param><param name="B">Второй сомножитель</param><returns>Произведение двух матриц</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Division(MathCore.Matrix,MathCore.Matrix)">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param><param name="B">Делитель</param><returns>Частное двух матриц</returns>
        </member>
        <member name="M:MathCore.Matrix.op_BitwiseOr(MathCore.Matrix,MathCore.Matrix)">
            <summary>Конкатенация двух матриц (либо по строкам, либо по столбцам)</summary>
            <param name="A">Первое слагаемое</param><param name="B">Второе слагаемое</param><returns>Объединённая матрица</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Implicit(System.Double)~MathCore.Matrix">
            <summary>Оператор неявного приведения типа вещественного числа двойной точности к типу Матрица порядка 1х1</summary>
            <param name="X">Приводимое число</param><returns>Матрица порядка 1х1</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Explicit(MathCore.Matrix)~System.Double[0:,0:]">
            <summary>Оператор явного приведения матрицы к двумерному массиву</summary>
            <param name="M">Исходная матрица</param>
        </member>
        <member name="M:MathCore.Matrix.op_Explicit(System.Double[0:,0:])~MathCore.Matrix">
            <summary>Оператор явного приведения типа двумерного массива к матрице</summary>
            <param name="Data">Двумерный массив</param>
        </member>
        <member name="M:MathCore.Matrix.op_Explicit(System.Double[])~MathCore.Matrix">
            <summary>Оператор явного приведения одномерного массива к матрице (столбцу)</summary>
            <param name="Data">Одномерный массив</param>
        </member>
        <member name="M:MathCore.Matrix.Equals(System.Double[0:,0:])">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.Matrix.Equals(MathCore.Matrix)">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.Matrix.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.Matrix.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:MathCore.MatrixComplex">
            <summary>Матрица NxM</summary>
            <remarks>
            i (первый индекс) - номер строки, 
            j (второй индекс) - номер столбца
            ------------ j ---------->
            | a11 a12 a13 a14 a15 a16 a1M
            | a21........................
            | a31........................
            | a41.......aij..............
            i a51........................
            | a61........................
            | aN1.....................aNM
            \/
            </remarks>
        </member>
        <member name="M:MathCore.MatrixComplex.CreateCol(MathCore.Complex[])">
            <summary>Создать матрицу-столбец</summary><param name="data">Элементы столбца</param><returns>Матрица-столбец</returns>
            <exception cref="T:System.ArgumentNullException">Если массив <paramref name="data"/> не определён</exception>
            <exception cref="T:System.ArgumentException">Если массив <paramref name="data"/> имеет длину 0</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.CreateRow(MathCore.Complex[])">
            <summary>Создать матрицу-строку</summary><param name="data">Элементы строки</param><returns>Матрица-строка</returns>
            <exception cref="T:System.ArgumentNullException">Если массив <paramref name="data"/> не определён</exception>
            <exception cref="T:System.ArgumentException">Если массив <paramref name="data"/> имеет длину 0</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.CreateDiagonalMatrixComplex(MathCore.Complex[])">
            <summary>Создать диагональную матрицу</summary><param name="elements">Элементы диагональной матрицы</param>
            <returns>Диагональная матрица</returns>
        </member>
        <member name="T:MathCore.MatrixComplex.Array">
            <summary>Операции над двумерными массивами</summary>
        </member>
        <member name="T:MathCore.MatrixComplex.Array.Operator">
            <summary>Операторы над двумерными массивами</summary>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Multiply(MathCore.Complex[],MathCore.Complex[])">
            <summary>Скалярное произведение векторов</summary>
            <param name="v1">Первый множитель скалярного произведения</param>
            <param name="v2">второй множитель скалярного произведения</param>
            <returns>Скалярное произведение векторов</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.VectorLength(MathCore.Complex[])">
            <summary>Длина вектора</summary>
            <param name="v">Вектор элементов</param>
            <returns>Длина вектора</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="v"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Multiply(MathCore.Complex[],MathCore.Complex)">
            <summary>Умножение вектора на число</summary>
            <param name="v1">Первый сомножитель - вектор элементов</param>
            <param name="v2">Второй сомножитель - число, на которое должны быть умножены все элементы вектора</param>
            <returns>Вектор произведений элементов входного вектора и числа</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="v1"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Divide(MathCore.Complex[],MathCore.Complex)">
            <summary>Деление вектора элементов на число</summary>
            <param name="v1">Вектор-делимое</param>
            <param name="v2">Число-делитель</param>
            <returns>Вектор, составленный из частного элементов вектора-делимого и числового делителя</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="v1"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Projection(MathCore.Complex[],MathCore.Complex[])">
            <summary>Проекция вектора на вектор</summary>
            <returns>Вектор - произведение компонентов исходных векторов</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="v1"/> or <paramref name="v2"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Длины векторов не совпадают</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Add(MathCore.Complex[0:,0:],MathCore.Complex)">
            <summary>Оператор вычисления суммы двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив суммы элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Add(MathCore.Complex[],MathCore.Complex[])">
            <summary>Поэлементное сложение двух матриц</summary>
            <param name="a">Матрица - первое слагаемое</param>
            <param name="b">Матрица - второе слагаемое</param>
            <returns>Матрица, составленная из элементов - сумм элементов исходных матриц</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> or <paramref name="b"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Subtract(MathCore.Complex[],MathCore.Complex[])">
            <summary>Оператор вычитания между двумя столбцами</summary>
            <param name="a">Столбец уменьшаемого</param>
            <param name="b">Столбец вычитаемого</param>
            <returns>Вектор-столбец разности указанных векторов</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> or <paramref name="b"/> is <see langword="null"/></exception>
            <exception cref="T:System.InvalidOperationException">Размеры векторов не совпадают</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.MultiplyComponent(MathCore.Complex[],MathCore.Complex[])">
            <summary>Оператор вычисления поэлементного произведения двух векторов</summary>
            <param name="a">Вектор элементов первого множителя</param>
            <param name="b">Вектор элементов второго множителя</param>
            <returns>Вектор элементов произведения</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> or <paramref name="b"/> is <see langword="null"/></exception>
            <exception cref="T:System.InvalidOperationException">Размеры векторов не совпадают</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.DivideComponent(MathCore.Complex[],MathCore.Complex[])">
            <summary>Оператор вычисления поэлементного деления двух векторов</summary>
            <param name="a">Вектор - делимое</param>
            <param name="b">Вектор - делитель</param>
            <returns>Вектор, составленный из поэлементного частного элементов векторов делимого и делителя</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> or <paramref name="b"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Subtract(MathCore.Complex[0:,0:],MathCore.Complex)">
            <summary>Оператор вычисления разности двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив разности элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Subtract(MathCore.Complex,MathCore.Complex[0:,0:])">
            <summary>Оператор вычисления разности двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив разности элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Multiply(MathCore.Complex[0:,0:],MathCore.Complex)">
            <summary>Оператор вычисления произведения двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив произведения элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Divide(MathCore.Complex[0:,0:],MathCore.Complex)">
            <summary>Оператор вычисления произведения двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив произведения элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Divide(MathCore.Complex,MathCore.Complex[0:,0:])">
            <summary>Оператор вычисления частного двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив частного элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Add(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:])">
            <summary>Оператор вычисления суммы элементов двух матриц</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="B">Массив элементов второй матрицы</param>
            <returns>Массив суммы элементов двух матриц</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матрицы не равны</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Subtract(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:])">
            <summary>Оператор вычисления разности элементов двух матриц</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="B">Массив элементов второй матрицы</param>
            <returns>Массив разности элементов двух матриц</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матрицы не равны</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.MultiplyCol(MathCore.Complex[0:,0:],MathCore.Complex[])">
            <summary>Оператор вычисления произведения элементов матрицы на столбец</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="col">Массив элементов столбца</param>
            <returns>Массив произведения элементов матрицы и столбца</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="col"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матрицы и столбца не равны</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.MultiplyRow(MathCore.Complex[],MathCore.Complex[0:,0:])">
            <summary>Оператор вычисления произведения элементов строки и матрицы</summary>
            <param name="B">Массив элементов первой матрицы</param>
            <param name="row">Массив элементов строки</param>
            <returns>Массив произведения элементов матрицы и столбца</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="row"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матрицы и строки не равны</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.MultiplyRowToCol(MathCore.Complex[],MathCore.Complex[])">
            <summary>Оператор вычисления произведения элементов строки и элементов столбца</summary>
            <param name="col">Массив элементов столбца</param>
            <param name="row">Массив элементов строки</param>
            <returns>Массив произведения элементов строки и столбца</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="col"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="row"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности строки и столбца не равны</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Multiply(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:])">
            <summary>Оператор вычисления произведения двух матриц</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="B">Массив элементов второй матрицы</param>
            <returns>Массив произведения двух матриц</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Multiply(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:],MathCore.Complex[0:,0:])">
            <summary>Оператор вычисления произведения двух матриц</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="B">Массив элементов второй матрицы</param>
            <param name="result">Массив элементов произведения</param>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="result"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матриц не согласованы</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк <paramref name="result"/> не равно числу строк <paramref name="A"/></exception>
            <exception cref="T:System.ArgumentException">В случае если число столбцов <paramref name="result"/> не равно числу строк <paramref name="B"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Divide(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:])">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param>
            <param name="B">Делитель</param>
            <returns>Частное двух матриц</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матриц не согласованы</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Concatenate(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:])">
            <summary>Объединение матриц по строкам, либо столбцам</summary>
            <returns>Двумерный массив, содержащий объединение элементов исходных массивов по строкам, либо столбцам</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="A"/> or <paramref name="B"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.MatrixToColsArray(MathCore.Complex[0:,0:])">
            <summary>Преобразовать двумерный массив элементов матрицы в массив массивов-столбцов</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <returns>Массив столбцов</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.MatrixToRowsArray(MathCore.Complex[0:,0:])">
            <summary>Преобразовать двумерный массив элементов матрицы в массив массивов-строк</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <returns>Массив строк</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.ColsArrayToMatrix(MathCore.Complex[][])">
            <summary>Создать двумерный массив массив матрицы из массива столбцов</summary>
            <param name="cols">Массив столбцов матрицы</param>
            <returns>Двумерный массив элементов матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="cols"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.RowsArrayToMatrix(MathCore.Complex[][])">
            <summary>Создать двумерный массив массив матрицы из массива строк</summary>
            <param name="rows">Массив строк матрицы</param>
            <returns>Двумерный массив элементов матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="rows"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.IsMatrixSingular(MathCore.Complex[0:,0:])">
            <summary>Проверка - является ли матрица вырожденной</summary>
            <param name="matrix">Проверяемая матрица</param>
            <returns>Истина, если определитель матрицы равен нулю</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица не содержит элементов, или если матрица не квадратная</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Determinant(MathCore.Complex[0:,0:])">
            <summary>Вычисление определителя матрицы</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Значение определителя матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица не квадратная</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Rank(MathCore.Complex[0:,0:])">
            <summary>Определение ранга матрицы</summary>
            <param name="matrix">Матрица, ранг которой требуется определить</param>
            <returns>Ранг матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица не содержит элементов</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.CreateDiagonal(MathCore.Complex[])">
            <summary>Создать диагональную матрицу</summary>
            <param name="elements">Элементы диагонали матрицы</param>
            <returns>Двумерный массив, содержащий на главной диагонали элементы диагональной матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="elements"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Массив не содержит элементов</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetMatrixShadow(MathCore.Complex[0:,0:])">
            <summary>Получить массив элементов тени (главной диагонали) матрицы</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Массив элементов тени матрицы</returns>
            <exception cref="T:System.ArgumentException">Массив не содержит элементов</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.EnumerateMatrixShadow(MathCore.Complex[0:,0:])">
            <summary>Перечислить элементы тени (главной диагонали) матрицы</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Перечисление элементов тени матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Массив не содержит элементов</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Permutation_Left(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:])">
            <summary>Применение матрицы перестановок слева (перестановка строк)</summary>
            <param name="matrix">Матрица, подвергаемая перестановке строк</param>
            <param name="p">Матрица перестановок (строк)</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="p"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица перестановок не квадратная</exception>
            <exception cref="T:System.ArgumentException">Число строк матрицы не равно числу столбцов матрицы перестановок</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Permutation_Right(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:])">
            <summary>Применение матрицы перестановок справа (перестановка столбцов)</summary>
            <param name="matrix">Матрица, подвергаемая перестановке столбцов</param>
            <param name="p">Матрица перестановок (столбцов)</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="p"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица перестановок не квадратная</exception>
            <exception cref="T:System.ArgumentException">Число строк матрицы не равно числу столбцов матрицы перестановок</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Permutation_Left_Internal(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:])">
            <summary>Применение матрицы перестановок слева (перестановка строк) без проверок</summary>
            <param name="matrix">Матрица, подвергаемая перестановке строк</param>
            <param name="p">Матрица перестановок (строк)</param>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="p"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Permutation_Right_Internal(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:])">
            <summary>Применение матрицы перестановок справа (перестановка столбцов) без проверок</summary>
            <param name="matrix">Матрица, подвергаемая перестановке столбцов</param>
            <param name="p">Матрица перестановок (столбцов)</param>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="p"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.CreateColArray(MathCore.Complex[])">
            <summary>Создать двумерный массив элементов матрицы-столбца</summary>
            <param name="data">Элементы массива матрицы-столбца</param>
            <returns>Двумерный массив элементов матрицы столбца</returns>
            <exception cref="T:System.ArgumentNullException">Если массив <paramref name="data"/> не определён</exception>
            <exception cref="T:System.ArgumentException">Если массив <paramref name="data"/> имеет длину 0</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.CreateRowArray(MathCore.Complex[])">
            <summary>Создать двумерный массив элементов матрицы-строки</summary>
            <param name="data">Элементы массива матрицы-строки</param>
            <returns>Двумерный массив элементов матрицы строки</returns>
            <exception cref="T:System.ArgumentNullException">Если массив <paramref name="data"/> не определён</exception>
            <exception cref="T:System.ArgumentException">Если массив <paramref name="data"/> имеет длину 0</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetLength(MathCore.Complex[0:,0:],System.Int32@,System.Int32@)">
            <summary>Получить размерность массива матрицы</summary>
            <param name="matrix">Массив элементов матрицы, размеры которого требуется получить</param>
            <param name="N">Число строк матрицы</param>
            <param name="M">Число столбцов (элементов строки) матрицы</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetRowsCount(MathCore.Complex[0:,0:],System.Int32@)">
            <summary>Получить число строк массива матрицы</summary>
            <param name="matrix">Массив элементов матрицы, размеры которого требуется получить</param>
            <param name="N">Число строк матрицы</param>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetColsCount(MathCore.Complex[0:,0:],System.Int32@)">
            <summary>Получить число столбцов (элементов строки) массива матрицы</summary>
            <param name="matrix">Массив элементов матрицы, размеры которого требуется получить</param>
            <param name="M">Число столбцов (элементов строки) матрицы</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetUnitaryArrayMatrix(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param>
            <returns>Квадратный двумерный массив размерности NxN с 1 на главной диагонали</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если размерность матрицы <paramref name="N"/> меньше 1</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.InitializeUnitaryArrayMatrix(MathCore.Complex[0:,0:])">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <returns>Квадратный двумерный массив размерности NxN с 1 на главной диагонали</returns>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetTransvection(MathCore.Complex[0:,0:],System.Int32)">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="i0">Опорная строка</param>
            <returns>Трансвекция матрицы А</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="A"/></exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="A"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если опорная строка <paramref name="i0"/> матрицы <paramref name="A"/> &lt; 0 и &gt; числа строк матрицы</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Transvection(MathCore.Complex[0:,0:],System.Int32,MathCore.Complex[0:,0:])">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="j">Опорный столбец</param>
            <param name="result">Двумерный массив элементов матрицы результата</param>
            <returns>Трансвекция матрицы А</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрицы <paramref name="A"/> и <paramref name="result"/> не заданы</exception>  
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="A"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если опорный столбец <paramref name="j"/> матрицы <paramref name="A"/> меньше 0 или больше числа столбцов матрицы</exception>
            <exception cref="T:System.ArgumentException">В случае если размер матрицы <paramref name="result"/> не совпадает с размером матрицы <paramref name="A"/></exception>                  
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetCol(MathCore.Complex[0:,0:],System.Int32)">
            <summary>Получить столбец матрицы в виде матрицы</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="j">Номер столбца</param>
            <returns>Матрица-столбец, составленная из элементов столбца матрицы c индексом j</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер столбца <paramref name="j"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа столбцов матрицы</exception>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetCol_Array(MathCore.Complex[0:,0:],System.Int32)">
            <summary>Получить столбец матрицы в виде массива</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="j">Номер столбца</param>
            <returns>Массив, составленная из элементов столбца матрицы c индексом <paramref name="j"/></returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер столбца <paramref name="j"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа столбцов матрицы</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetCol_Array(MathCore.Complex[0:,0:],System.Int32,MathCore.Complex[])">
            <summary>Получить столбец матрицы в виде массива</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="j">Номер столбца</param>
            <param name="result">Массив, составленная из элементов столбца матрицы c индексом <paramref name="j"/></param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если массив <paramref name="result"/> не задан</exception>
            <exception cref="T:System.ArgumentException">В случае если размер массива <paramref name="result"/> не соответствует числу строк матрицы</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер столбца <paramref name="j"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа столбцов матрицы</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetRow(MathCore.Complex[0:,0:],System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="i">Номер строки</param>
            <returns>Матрица-строка, составленная из элементов строки матрицы с индексом <paramref name="i"/></returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер строки <paramref name="i"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа строк матрицы</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetRow_Array(MathCore.Complex[0:,0:],System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="i">Номер строки</param>
            <returns>Массив, составленный из элементов строки матрицы с индексом <paramref name="i"/></returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер строки <paramref name="i"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа строк матрицы</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetRow_Array(MathCore.Complex[0:,0:],System.Int32,MathCore.Complex[])">
            <summary>Получить строку матрицы</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="i">Номер строки</param>
            <param name="result">Массив, составленный из элементов строки матрицы с индексом i</param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если массив <paramref name="result"/> не задан</exception>
            <exception cref="T:System.ArgumentException">В случае если размер массива <paramref name="result"/> не соответствует числу столбцов матрицы</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер строки <paramref name="i"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа строк матрицы</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Inverse(MathCore.Complex[0:,0:])">
            <summary>Получить обратную матрицу</summary>
            <param name="matrix">Обращаемая матрица</param>
            <returns>Обратная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.InvalidOperationException">Невозможно найти обратную матрицу для вырожденной матрицы</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Inverse(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:]@)">
            <summary>Получить обратную матрицу</summary>
            <param name="matrix">Обращаемая матрица</param>
            <param name="p">Матрица перестановок</param>
            <returns>Обратная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.InvalidOperationException">Невозможно найти обратную матрицу для вырожденной матрицы</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Размерность массива 0х0</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetSolve(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:],MathCore.Complex[0:,0:]@)">
            <summary>Метод решения СЛАУ A*X=B -&gt; X</summary>
            <param name="matrix">Матрица СЛАУ</param>
            <param name="b">Правая часть СЛАУ</param>
            <param name="p">Матрица перестановок</param>
            <returns>Матрица решения уравнения A*X=B -&gt; X</returns>
            <exception cref="T:System.InvalidOperationException">Невозможно найти обратную матрицу для вырожденной матрицы</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">В случае если матрица системы <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Solve(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:]@,MathCore.Complex[0:,0:]@,System.Boolean)">
            <summary>Метод решения СЛАУ</summary>
            <param name="matrix">Матрица СЛАУ</param>
            <param name="b">Правая часть СЛАУ</param>
            <param name="p">Матрица перестановок</param>
            <param name="clone_b">Работать с копией <paramref name="b"/></param>
            <exception cref="T:System.InvalidOperationException">Невозможно найти обратную матрицу для вырожденной матрицы</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">В случае если матрица системы <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.TrySolve(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:]@,MathCore.Complex[0:,0:]@,System.Boolean)">
            <summary>Попытаться решить СЛАУ</summary>
            <param name="matrix">Матрица СЛАУ</param>
            <param name="b">Правая часть СЛАУ</param>
            <param name="p">Матрица перестановок</param>
            <param name="clone_b">Работать с копией <paramref name="b"/></param>
            <returns>Истина, если решение СЛАУ получено; ложь - если матрица СЛАУ <paramref name="matrix"/> вырождена</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="b"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">В случае если матрица системы <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Inverse(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:])">
            <summary>Получить обратную матрицу</summary>
            <param name="matrix">Матрица, подлежащая обращению</param>
            <param name="result">Обратная матрица</param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="result"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Transpose(MathCore.Complex[0:,0:])">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Transpose(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:])">
            <summary>Транспонирование матрицы</summary>
            <param name="matrix">Исходная матрица</param>
            <param name="result">Транспонированная матрица</param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="result"/> не задана</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetAdjunct(MathCore.Complex[0:,0:],System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер строки <paramref name="n"/> меньше 0, или больше, либо равен числу строк матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер столбца <paramref name="m"/> меньше 0, или больше, либо равен числу столбцов матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.CopyMinor(MathCore.Complex[0:,0:],System.Int32,System.Int32,System.Int32,System.Int32,MathCore.Complex[0:,0:])">
            <summary>Скопировать минор из матрицы в матрицу результата</summary>
            <param name="matrix">Массив элементов исходной матрицы</param>
            <param name="n">Номер строки</param>
            <param name="m">Номер столбца</param>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="result">Минор матрицы</param>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetMinor(MathCore.Complex[0:,0:],System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер строки <paramref name="n"/> меньше 0, или больше, либо равен числу строк матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер столбца <paramref name="m"/> меньше 0, или больше, либо равен числу столбцов матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetMinor(MathCore.Complex[0:,0:],System.Int32,System.Int32,MathCore.Complex[0:,0:])">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <param name="result">Минор элемента матрицы [n,m]</param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер строки <paramref name="n"/> меньше 0, или больше, либо равен числу строк матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер столбца <paramref name="m"/> меньше 0, или больше, либо равен числу столбцов матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentException">В случае если число строк матрицы результата <paramref name="result"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentException">В случае если число столбцов матрицы результата <paramref name="result"/> не равно числу столбцов исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetDeterminant(MathCore.Complex[0:,0:])">
            <summary>Определитель матрицы</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Определитель матрицы</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Swap``1(``0@,``0@)">
            <summary>Поменять значения местами</summary>
            <typeparam name="T">Тип значения</typeparam>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetLUPDecomposition(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:]@,MathCore.Complex[0:,0:]@,MathCore.Complex[0:,0:]@,MathCore.Complex@)">
            <summary>Разложение матрицы на верхне-треугольную и нижне-треугольную</summary>
            <remarks>
            This method is based on the 'LU Decomposition and Its Applications' 
            section of Numerical Recipes in C by William H. Press, Saul A. Teukolsky, William T. 
            Vetterling and Brian P. Flannery,  University of Cambridge Press 1992.  
            </remarks>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="l">Нижне-треугольная матрица</param>
            <param name="u">Верхне-треугольная матрица</param>
            <param name="p">Матрица преобразований P*X = L*U</param>
            <param name="d">Определитель матрицы</param>
            <returns>Истина, если процедура декомпозиции прошла успешно. Ложь, если матрица вырождена</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если размерность матрицы <paramref name="matrix"/> меньше 1</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetLUDecomposition(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:]@,MathCore.Complex[0:,0:]@,MathCore.Complex@)">
            <summary>Разложение матрицы на верхне-треугольную и нижне-треугольную</summary>
            <remarks>
            This method is based on the 'LU Decomposition and Its Applications' 
            section of Numerical Recipes in C by William H. Press, Saul A. Teukolsky, William T. 
            Vetterling and Brian P. Flannery,  University of Cambridge Press 1992.  
            </remarks>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="l">Нижне-треугольная матрица</param>
            <param name="u">Верхне-треугольная матрица</param>
            <param name="d">Определитель матрицы</param>
            <returns>Истина, если процедура декомпозиции прошла успешно. Ложь, если матрица вырождена</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу matrix</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если размерность матрицы N меньше 1</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetLUPDecomposition(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:]@,MathCore.Complex[0:,0:]@,MathCore.Complex@)">
            <summary>Разложение матрицы на верхне-треугольную и нижне-треугольную</summary>
            <remarks>
            This method is based on the 'LU Decomposition and Its Applications' 
            section of Numerical Recipes in C by William H. Press, Saul A. Teukolsky, William T. 
            Vetterling and Brian P. Flannery,  University of Cambridge Press 1992.  
            </remarks>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="c">Матрица с результатами разложения: элементы ниже главной диагонали - матрица L, элементы выше - матрица U</param>
            <param name="p">Массив матрицы перестановок</param>
            <param name="d">Определитель матрицы</param>
            <returns>Истина, если операция выполнена успешно</returns>
            <exception cref="T:System.ArgumentException">Матрица не квадратная</exception>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу matrix</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetLUPDecomposition(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:]@,MathCore.Complex@)">
            <summary>LU-разложение матрицы</summary>
            <param name="matrix">Разлагаемая матрица</param>
            <param name="c">Матрица с результатами разложения: элементы ниже главной диагонали - матрица L, элементы выше - матрица U</param>
            <param name="d">Определитель матрицы</param>
            <returns>Истина, если процедура выполнена успешно</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу matrix</exception>
            <exception cref="T:System.ArgumentException">Матрица не квадратная</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetLUDecomposition(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:]@)">
            <summary>LU-разложение матрицы</summary>
            <param name="matrix">Разлагаемая матрица</param>
            <param name="c">Матрица с результатами разложения: элементы ниже главной диагонали - матрица L, элементы выше - матрица U</param>
            <returns>Истина, если разложение выполнено успешно</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу matrix</exception>
            <exception cref="T:System.ArgumentException">Матрица не квадратная</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.CreatePermutationMatrix(System.Int32[])">
            <summary>Создать матрицу перестановок из массива индексов</summary>
            <param name="indexes">Массив индексов элементов столбцов</param>
            <returns>Матрица перестановок</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetTriangle(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:]@,System.Int32@,MathCore.Complex@)">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="p">Матрица перестановок</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <returns>Треугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetTriangle(MathCore.Complex[0:,0:],System.Int32@,MathCore.Complex@)">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <returns>Треугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetTriangle(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:],System.Int32@,MathCore.Complex@)">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="b">Матрица правой части</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <returns>Треугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetTriangle(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:]@,MathCore.Complex[0:,0:]@,System.Int32@,MathCore.Complex@,System.Boolean)">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="b">Матрица правой части</param>
            <param name="p">Матрица перестановок</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <param name="clone_b">Клонировать матрицу правых частей</param>
            <returns>Треугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Triangulate(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:]@,MathCore.Complex@)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к треугольному виду</param>
            <param name="p">Матрица перестановок</param>
            <param name="d">Определитель матрицы (произведение диагональных элементов)</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Triangulate(MathCore.Complex[0:,0:],MathCore.Complex@)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к треугольному виду</param>
            <param name="d">Определитель матрицы (произведение диагональных элементов)</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Triangulate(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:],MathCore.Complex@)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к треугольному виду</param>
            <param name="b">Присоединённая матрица, над которой выполняются те же операции, что и над <paramref name="matrix"/></param>
            <param name="d">Определитель матрицы (произведение диагональных элементов)</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Triangulate(MathCore.Complex[0:,0:]@,MathCore.Complex[0:,0:],MathCore.Complex@,System.Boolean)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к треугольному виду</param>
            <param name="b">Присоединённая матрица, над которой выполняются те же операции, что и над <paramref name="matrix"/></param>
            <param name="d">Определитель матрицы (произведение диагональных элементов)</param>
            <param name="clone">Клонировать исходную матрицу</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Triangulate(MathCore.Complex[0:,0:]@,MathCore.Complex[0:,0:]@,MathCore.Complex[0:,0:]@,MathCore.Complex@,System.Boolean,System.Boolean)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к треугольному виду</param>
            <param name="b">Присоединённая матрица, над которой выполняются те же операции, что и над <paramref name="matrix"/></param>
            <param name="p">Матрица перестановок</param>
            <param name="d">Определитель матрицы (произведение диагональных элементов)</param>
            <param name="clone_matrix">Клонировать исходную матрицу</param>
            <param name="clone_b">Клонировать присоединённую матрицу</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.AreEquals(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:])">
            <summary>Сравнение двух двумерных массивов элементов матриц</summary>
            <param name="A">Первый массив</param>
            <param name="B">Второй массив</param>
            <returns>Истина, если оба массивы не определены, либо если оба массивы - один и тот же массив, либо если элементы массивов идентичны</returns>
            <exception cref="T:System.ArgumentNullException">matrix is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.AreEquals(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:],System.Double)">
            <summary>Сравнение двух двумерных массивов элементов матриц</summary>
            <param name="A">Первый массив</param>
            <param name="B">Второй массив</param>
            <param name="eps">Точность сравнения</param>
            <returns>Истина, если оба массивы не определены, либо если оба массивы - один и тот же массив, либо если элементы массивов идентичны</returns>
            <exception cref="T:System.ArgumentNullException">matrix is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetMaxRowAbsSum(MathCore.Complex[0:,0:])">
            <summary>Вычисление максимума от сумм абсолютных значений по элементам строк</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Максимальная из сумм абсолютных значений элементов строк</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetMaxColAbsSum(MathCore.Complex[0:,0:])">
            <summary>Вычисление максимума от сумм абсолютных значений по элементам столбцов</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Максимальная из сумм абсолютных значений элементов столбцов</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetRMS(MathCore.Complex[0:,0:])">
            <summary>Вычисление среднеквадратичного значения элементов матрицы</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Среднеквадратичное значение элементов матрицы</returns>
            <exception cref="T:System.ArgumentNullException">matrix is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Sqr(MathCore.Complex)">
            <summary>Квадрат числа</summary>
            <param name="x">Значение, квадрат которого требуется получить</param>
            <returns>Квадрат указанного числа</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GaussSeidelConverge(MathCore.Complex[0:,0:]@,MathCore.Complex[0:,0:]@,System.Double,System.Int32,System.Int32)">
            <summary>Метод проверки сходимости метода Метод Гаусса — Зейделя</summary>
            <remarks>Метод меняет местами матрицы решения текущего и прошлого шагов, если метод Гаусса — Зейделя не сошёлся на текущем шаге</remarks>
            <param name="new_x">Новое полученное решение</param>
            <param name="last_x">Решение, полученное на прошлом шаге метода</param>
            <param name="eps">Требуемая точность решения</param>
            <param name="N">Число строк матрицы решения</param>
            <param name="M">Число столбцов матрицы решения</param>
            <returns>Истина, если метод сошёлся Метод Гаусса — Зейделя</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GaussSeidelSolve(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:],MathCore.Complex[0:,0:],System.Double)">
            <summary>Метод Гаусса — Зейделя решения системы линейных уравнений</summary>
            <param name="matrix">Матрица коэффициентов</param>
            <param name="x">Матрица неизвестных</param>
            <param name="b">Матрица правых частей</param>
            <param name="eps">Требуемая точность</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="x"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="b"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица системы не содержит элементов</exception>
            <exception cref="T:System.ArgumentException">Матрица системы не квадратная</exception>
            <exception cref="T:System.ArgumentException">Число строк массива неизвестных не совпадает с числом строк матрицы системы</exception>
            <exception cref="T:System.ArgumentException">Число строк массива правой части СЛАУ не совпадает с числом строк матрицы системы</exception>
            <exception cref="T:System.ArgumentException">Число столбцов массива правых частей не совпадает с числом столбцов массива неизвестных</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="eps"/> &lt;= <see cref="T:MathCore.Complex"/>.<see cref="F:MathCore.Complex.Epsilon"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.QRDecomposition(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:],MathCore.Complex[0:,0:])">
            <summary>QR-разложение матрицы</summary>
            <param name="matrix">Разлагаемая матрица</param>
            <param name="q">Унитарная матрица (ортогональная) - должна быть передана квадратная матрица nxn != null</param>
            <param name="r">Верхне-треугольная матрица - должна быть передана квадратная матрица nxn != null</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица не содержит элементов</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.QRDecomposition(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:]@,MathCore.Complex[0:,0:]@)">
            <summary>QR-разложение матрицы</summary>
            <param name="matrix">Разлагаемая матрица</param>
            <param name="q">Унитарная матрица (ортогональная) - создаётся квадратная матрица nxn != null</param>
            <param name="r">Верхне-треугольная матрица - создаётся квадратная матрица nxn != null</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица не содержит элементов</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.SVD(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:]@,MathCore.Complex[]@,MathCore.Complex[0:,0:]@)">
            <summary>SVD-разложение</summary>
            <param name="matrix">Разлагаемая матрица</param>
            <param name="u">Матрица левых сингулярных векторов</param>
            <param name="w">Вектор собственных чисел</param>
            <param name="v">Матрица правых сингулярных векторов</param>
            <exception cref="T:System.ArgumentNullException">matrix is <see langword="null"/></exception>
            <exception cref="T:System.InvalidOperationException">Метод не сошёлся за 30 итераций</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.GetUnitaryMatrix(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param><returns>Единичная матрица размерности NxN с 1 на главной диагонали</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.GetTransvection(MathCore.MatrixComplex,System.Int32)">
            <summary>Трансвекция матрицы</summary><param name="A">Трансвецируемая матрица</param><param name="j">Опорный столбец</param>
            <returns>Трансвекция матрицы А</returns>
        </member>
        <member name="F:MathCore.MatrixComplex._N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="F:MathCore.MatrixComplex._M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="F:MathCore.MatrixComplex._Data">
            <summary>Элементы матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixComplex.N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixComplex.M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixComplex.Item(System.Int32,System.Int32)">
            <summary>Элемент матрицы</summary>
            <param name="i">Номер строки (элемента в столбце)</param>
            <param name="j">Номер столбца (элемента в строке)</param>
            <returns>Элемент матрицы</returns>
        </member>
        <member name="P:MathCore.MatrixComplex.Item(System.Int32)">
            <summary>Вектор-столбец</summary><param name="j">Номер столбца</param><returns>Столбец матрицы</returns>
        </member>
        <member name="P:MathCore.MatrixComplex.IsSquare">
            <summary>Матрица является квадратной матрицей</summary>
        </member>
        <member name="P:MathCore.MatrixComplex.IsCol">
            <summary>Матрица является столбцом</summary>
        </member>
        <member name="P:MathCore.MatrixComplex.IsRow">
            <summary>Матрица является строкой</summary>
        </member>
        <member name="P:MathCore.MatrixComplex.IsScalar">
            <summary>Матрица является числом</summary>
        </member>
        <member name="P:MathCore.MatrixComplex.T">
            <summary>Транспонированная матрица</summary>
        </member>
        <member name="P:MathCore.MatrixComplex.Norm_m">
            <summary>Максимум среди абсолютных сумм элементов строк</summary>
        </member>
        <member name="P:MathCore.MatrixComplex.Norm_l">
            <summary>Максимум среди абсолютных сумм элементов столбцов</summary>
        </member>
        <member name="P:MathCore.MatrixComplex.Norm_k">
            <summary>Среднеквадратичное значение элементов матрицы</summary>
        </member>
        <member name="M:MathCore.MatrixComplex.#ctor(System.Int32,System.Int32)">
            <summary>Матрица</summary><param name="N">Число строк</param><param name="M">Число столбцов</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="N"/> &lt; 0 || <paramref name="M"/> &lt; 0</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.#ctor(System.Int32)">
            <summary>Квадратная матрица</summary><param name="N">Размерность</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="N" /> &lt; 0</exception>
        </member>
        <member name="T:MathCore.MatrixComplex.MatrixComplexItemCreator">
            <summary>Метод определения значения элемента матрицы</summary>
            <param name="i">Номер строки</param><param name="j">Номер столбца</param>
            <returns>Значение элемента матрицы M[<paramref name="i"/>, <paramref name="j"/>]</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.#ctor(System.Int32,MathCore.MatrixComplex.MatrixComplexItemCreator)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathCore.MatrixComplex.#ctor(System.Int32,System.Int32,MathCore.MatrixComplex.MatrixComplexItemCreator)">
            <summary>Матрица</summary><param name="N">Число строк</param><param name="M">Число столбцов</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathCore.MatrixComplex.#ctor(MathCore.Complex[0:,0:],System.Boolean)">
            <summary>Инициализация новой матрицы по двумерному массиву её элементов</summary>
            <param name="Data">Двумерный массив элементов матрицы</param>
            <param name="clone">Создать копию данных</param>
        </member>
        <member name="M:MathCore.MatrixComplex.#ctor(System.Collections.Generic.IList{MathCore.Complex},System.Boolean)">
            <summary>Инициализация новой матрицы - столбца/строки</summary>
            <param name="DataCol">Элементы столбца матрицы</param>
            <param name="IsColumn">Создаётся матрица-столбец</param>
        </member>
        <member name="M:MathCore.MatrixComplex.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{MathCore.Complex}})">
            <summary>Инициализация новой матрицы на основе перечисления строк (перечисления элементов строк) </summary>
            <param name="Items">Перечисление строк, состоящих из перечисления элементов строк</param>
        </member>
        <member name="M:MathCore.MatrixComplex.GetElements(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{MathCore.Complex}})">
            <summary>Получить двумерный массив элементов матрицы</summary>
            <param name="ColsItems">Перечисление элементов (по столбцам)</param>
            <returns>Двумерный массив элементов матрицы</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.GetCol(System.Int32)">
            <summary>Получить столбец матрицы</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы номер j</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.GetRow(System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="i">Номер строки</param>
            <returns>Строка матрицы номер i</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.GetTriangle(MathCore.MatrixComplex@,System.Int32@,MathCore.Complex@)">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <param name="P">Матрица перестановок</param>
            <param name="rank">Ранг матрицы</param>
            <param name="D">Определитель</param>
            <returns>Треугольная матрица</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.GetTriangle(MathCore.MatrixComplex@,System.Boolean)">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <param name="B">Присоединённая матрица правой части СЛАУ</param>
            <param name="CloneB">Работать с клоном матрицы <paramref name="B"/></param>
            <returns>Треугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">Если <paramref name="B"/> <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.GetTriangle(MathCore.MatrixComplex@,MathCore.MatrixComplex@,System.Int32@,MathCore.Complex@,System.Boolean)">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <param name="B">Матрица правой части СЛАУ</param>
            <param name="P">Матрица перестановок</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <param name="CloneB">Клонировать матрицу правой части</param>
            <returns>Треугольная матрица</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.GetInverse(MathCore.MatrixComplex@)">
            <summary>Получить обратную матрицу</summary>                                                     
            <param name="P">Матрица перестановок</param>
            <returns>Обратная матрица</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.GetTranspose">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.GetAdjunct(System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.GetMinor(System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.GetDeterminant">
            <summary>Определитель матрицы</summary>
        </member>
        <member name="M:MathCore.MatrixComplex.GetLUDecomposition(MathCore.MatrixComplex@,MathCore.MatrixComplex@,MathCore.MatrixComplex@,MathCore.Complex@)">
            <summary>Разложение матрицы на верхне-треугольную и нижне-треугольную</summary>
            <param name="L">Нижне-треугольная матрица</param>
            <param name="U">Верхне-треугольная матрица</param>
            <param name="P">Матрица преобразований P*X = L*U</param>
            <param name="D">Знак определителя</param>
            <returns>Истина, если разложение выполнено успешно, ложь - если матрица вырожденная</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.GetData">
            <summary>Получить внутренний массив элементов матрицы</summary>
            <returns></returns>
        </member>
        <member name="M:MathCore.MatrixComplex.ToString">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.MatrixComplex.ToStringFormat(System.String,System.String,System.IFormatProvider)">
            <summary>Преобразование матрицы в строку с форматированием</summary>
            <param name="Format">Строка формата вывода чисел</param>
            <param name="Splitter">Разделитель элементов матрицы</param>
            <param name="provider">Механизм форматирования чисел матрицы</param>
            <returns>Строковое представление матрицы</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.MatrixComplex.System#ICloneable#Clone">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.MatrixComplex.MathCore#ICloneable{MathCore#Complex[,]}#Clone">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.MatrixComplex.Clone">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.MatrixComplex.op_Addition(MathCore.MatrixComplex,MathCore.MatrixComplex)">
            <summary>Оператор сложения двух матриц</summary>
            <param name="A">Первое слагаемое</param><param name="B">Второе слагаемое</param><returns>Сумма двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.op_Subtraction(MathCore.MatrixComplex,MathCore.MatrixComplex)">
            <summary>Оператор разности двух матриц</summary>
            <param name="A">Уменьшаемое</param><param name="B">Вычитаемое</param><returns>Разность двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.op_Multiply(MathCore.MatrixComplex,MathCore.MatrixComplex)">
            <summary>Оператор произведения двух матриц</summary>
            <param name="A">Первый сомножитель</param><param name="B">Второй сомножитель</param><returns>Произведение двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.op_Division(MathCore.MatrixComplex,MathCore.MatrixComplex)">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param><param name="B">Делитель</param><returns>Частное двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.op_BitwiseOr(MathCore.MatrixComplex,MathCore.MatrixComplex)">
            <summary>Конкатенация двух матриц (либо по строкам, либо по столбцам)</summary>
            <param name="A">Первое слагаемое</param><param name="B">Второе слагаемое</param><returns>Объединённая матрица</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.op_Implicit(MathCore.Complex)~MathCore.MatrixComplex">
            <summary>Оператор неявного приведения типа вещественного числа двойной точности к типу Матрица порядка 1х1</summary>
            <param name="X">Приводимое число</param><returns>Матрица порядка 1х1</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.Equals(MathCore.Complex[0:,0:])">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.MatrixComplex.Equals(MathCore.MatrixComplex)">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.MatrixComplex.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.MatrixComplex.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:MathCore.MatrixDecimal">
            <summary>Матрица NxM</summary>
            <remarks>
            i (первый индекс) - номер строки, 
            j (второй индекс) - номер столбца
            ------------ j ---------->
            | a11 a12 a13 a14 a15 a16 a1M
            | a21........................
            | a31........................
            | a41.......aij..............
            i a51........................
            | a61........................
            | aN1.....................aNM
            \/
            </remarks>
        </member>
        <member name="M:MathCore.MatrixDecimal.GetUnitaryMatrix(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param>
            <returns>Единичная матрица размерности NxN</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.GetTransvection(MathCore.MatrixDecimal,System.Int32)">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="j">Опорный столбец</param>
            <returns>Трансвекция матрицы А</returns>
        </member>
        <member name="F:MathCore.MatrixDecimal._N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="F:MathCore.MatrixDecimal._M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="F:MathCore.MatrixDecimal._Data">
            <summary>Элементы матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixDecimal.N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixDecimal.M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixDecimal.Item(System.Int32,System.Int32)">
            <summary>Элемент матрицы</summary>
            <param name="i">Номер строки (элемента в столбце)</param>
            <param name="j">Номер столбца (элемента в строке)</param>
            <returns>Элемент матрицы</returns>
        </member>
        <member name="P:MathCore.MatrixDecimal.Item(System.Int32)">
            <summary>Вектор-столбец</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы</returns>
        </member>
        <member name="P:MathCore.MatrixDecimal.IsSquare">
            <summary>Матрица является квадратной матрицей</summary>
        </member>
        <member name="P:MathCore.MatrixDecimal.IsCol">
            <summary>Матрица является столбцом</summary>
        </member>
        <member name="P:MathCore.MatrixDecimal.IsRow">
            <summary>Матрица является строкой</summary>
        </member>
        <member name="P:MathCore.MatrixDecimal.IsDigit">
            <summary>Матрица является числом</summary>
        </member>
        <member name="M:MathCore.MatrixDecimal.#ctor(System.Int32,System.Int32)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
        </member>
        <member name="M:MathCore.MatrixDecimal.#ctor(System.Int32)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
        </member>
        <member name="T:MathCore.MatrixDecimal.MatrixDecimalItemCreator">
            <summary>Метод определения значения элемента матрицы</summary>
            <param name="i">Номер строки</param>
            <param name="j">Номер столбца</param>
            <returns>Значение элемента матрицы M[<paramref name="i"/>, <paramref name="j"/>]</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.#ctor(System.Int32,MathCore.MatrixDecimal.MatrixDecimalItemCreator)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathCore.MatrixDecimal.#ctor(System.Int32,System.Int32,MathCore.MatrixDecimal.MatrixDecimalItemCreator)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathCore.MatrixDecimal.GetCol(System.Int32)">
            <summary>Получить столбец матрицы</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы номер j</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.GetRow(System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="i">Номер строки</param>
            <returns>Строка матрицы номер i</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.GetTriangle">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <returns></returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.GetInverse">
            <summary>Получить обратную матрицу</summary>
            <returns>Обратная матрица</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.GetTranspose">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.GetAdjunct(System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.GetMinor(System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.GetDeterminant">
            <summary>Определитель матрицы</summary>
        </member>
        <member name="M:MathCore.MatrixDecimal.LUDecomposition(System.Decimal[0:,0:],System.Decimal[0:,0:]@,System.Decimal[0:,0:]@,System.Decimal[0:,0:]@)">
            <summary>
            Returns the LU Decomposition of a matrix. 
            the output is: lower triangular matrix L, upper
            triangular matrix U, and permutation matrix P so that
            P*X = L*U.
            In case of an error the error is raised as an exception.
            Note - This method is based on the 'LU Decomposition and Its Applications'
            section of Numerical Recipes in C by William H. Press,
            Saul A. Teukolsky, William T. Vetterling and Brian P. Flannery,
            University of Cambridge Press 1992.  
            </summary>
            <param name="Mat">Array which will be LU Decomposed</param>
            <param name="L">An array where the lower triangular matrix is returned</param>
            <param name="U">An array where the upper triangular matrix is returned</param>
            <param name="P">An array where the permutation matrix is returned</param>
        </member>
        <member name="M:MathCore.MatrixDecimal.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MatrixDecimal.Clone">
            <summary>Клонирование матрицы</summary>
            <returns>Копия текущей матрицы</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.op_Addition(MathCore.MatrixDecimal,MathCore.MatrixDecimal)">
            <summary>Оператор сложения двух матриц</summary>
            <param name="A">Первое слагаемое</param>
            <param name="B">Второе слагаемое</param>
            <returns>Сумма двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.op_Subtraction(MathCore.MatrixDecimal,MathCore.MatrixDecimal)">
            <summary>Оператор разности двух матриц</summary>
            <param name="A">Уменьшаемое</param>
            <param name="B">Вычитаемое</param>
            <returns>Разность двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.op_Multiply(MathCore.MatrixDecimal,MathCore.MatrixDecimal)">
            <summary>Оператор произведения двух матриц</summary>
            <param name="A">Первый сомножитель</param>
            <param name="B">Второй сомножитель</param>
            <returns>Произведение двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.op_Division(MathCore.MatrixDecimal,MathCore.MatrixDecimal)">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param>
            <param name="B">Делитель</param>
            <returns>Частное двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.op_BitwiseOr(MathCore.MatrixDecimal,MathCore.MatrixDecimal)">
            <summary>Конкатенация двух матриц (либо по строкам, либо по столбцам)</summary>
            <param name="A">Первое слагаемое</param>
            <param name="B">Второе слагаемое</param>
            <returns>Объединённая матрица</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.op_Implicit(System.Decimal)~MathCore.MatrixDecimal">
            <summary>Оператор неявного приведения типа вещественного числа двойной точности к типу Матрица порядка 1х1</summary>
            <param name="X">Приводимое число</param><returns>Матрица порядка 1х1</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.System#IEquatable{MathCore#MatrixDecimal}#Equals(MathCore.MatrixDecimal)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MatrixDecimal.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MatrixDecimal.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:MathCore.MatrixFloat">
            <summary>Матрица NxM</summary>
            <remarks>
            i (первый индекс) - номер строки, 
            j (второй индекс) - номер столбца
            ------------ j ---------->
            | a11 a12 a13 a14 a15 a16 a1M
            | a21........................
            | a31........................
            | a41.......aij..............
            i a51........................
            | a61........................
            | aN1.....................aNM
            \/
            </remarks>
        </member>
        <member name="M:MathCore.MatrixFloat.GetUnitaryMatrix(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param>
            <returns>Единичная матрица размерности NxN</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.GetTransvection(MathCore.MatrixFloat,System.Int32)">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="j">Опорный столбец</param>
            <returns>Трансвекция матрицы А</returns>
        </member>
        <member name="F:MathCore.MatrixFloat._N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="F:MathCore.MatrixFloat._M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="F:MathCore.MatrixFloat._Data">
            <summary>Элементы матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixFloat.N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixFloat.M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixFloat.Item(System.Int32,System.Int32)">
            <summary>Элемент матрицы</summary>
            <param name="i">Номер строки (элемента в столбце)</param>
            <param name="j">Номер столбца (элемента в строке)</param>
            <returns>Элемент матрицы</returns>
        </member>
        <member name="P:MathCore.MatrixFloat.Item(System.Int32)">
            <summary>Вектор-столбец</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы</returns>
        </member>
        <member name="P:MathCore.MatrixFloat.IsSquare">
            <summary>Матрица является квадратной матрицей</summary>
        </member>
        <member name="P:MathCore.MatrixFloat.IsCol">
            <summary>Матрица является столбцом</summary>
        </member>
        <member name="P:MathCore.MatrixFloat.IsRow">
            <summary>Матрица является строкой</summary>
        </member>
        <member name="P:MathCore.MatrixFloat.IsDigit">
            <summary>Матрица является числом</summary>
        </member>
        <member name="M:MathCore.MatrixFloat.#ctor(System.Int32,System.Int32)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
        </member>
        <member name="M:MathCore.MatrixFloat.#ctor(System.Int32)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
        </member>
        <member name="T:MathCore.MatrixFloat.MatrixFloatItemCreator">
            <summary>Метод определения значения элемента матрицы</summary>
            <param name="i">Номер строки</param>
            <param name="j">Номер столбца</param>
            <returns>Значение элемента матрицы M[<paramref name="i"/>, <paramref name="j"/>]</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.#ctor(System.Int32,MathCore.MatrixFloat.MatrixFloatItemCreator)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathCore.MatrixFloat.#ctor(System.Int32,System.Int32,MathCore.MatrixFloat.MatrixFloatItemCreator)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathCore.MatrixFloat.GetCol(System.Int32)">
            <summary>Получить столбец матрицы</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы номер j</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.GetRow(System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="i">Номер строки</param>
            <returns>Строка матрицы номер i</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.GetTriangle">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <returns></returns>
        </member>
        <member name="M:MathCore.MatrixFloat.GetInverse">
            <summary>Получить обратную матрицу</summary>
            <returns>Обратная матрица</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.GetTranspose">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.GetAdjunct(System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.GetMinor(System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.GetDeterminant">
            <summary>Определитель матрицы</summary>
        </member>
        <member name="M:MathCore.MatrixFloat.LUDecomposition(System.Single[0:,0:],System.Single[0:,0:]@,System.Single[0:,0:]@,System.Single[0:,0:]@)">
            <summary>
            Returns the LU Decomposition of a matrix. 
            the output is: lower triangular matrix L, upper
            triangular matrix U, and permutation matrix P so that
            P*X = L*U.
            In case of an error the error is raised as an exception.
            Note - This method is based on the 'LU Decomposition and Its Applications'
            section of Numerical Recipes in C by William H. Press,
            Saul A. Teukolsky, William T. Vetterling and Brian P. Flannery,
            University of Cambridge Press 1992.  
            </summary>
            <param name="Mat">Array which will be LU Decomposed</param>
            <param name="L">An array where the lower triangular matrix is returned</param>
            <param name="U">An array where the upper triangular matrix is returned</param>
            <param name="P">An array where the permutation matrix is returned</param>
        </member>
        <member name="M:MathCore.MatrixFloat.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MatrixFloat.Clone">
            <summary>Клонирование матрицы</summary>
            <returns>Копия текущей матрицы</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.op_Addition(MathCore.MatrixFloat,MathCore.MatrixFloat)">
            <summary>Оператор сложения двух матриц</summary>
            <param name="A">Первое слагаемое</param>
            <param name="B">Второе слагаемое</param>
            <returns>Сумма двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.op_Subtraction(MathCore.MatrixFloat,MathCore.MatrixFloat)">
            <summary>Оператор разности двух матриц</summary>
            <param name="A">Уменьшаемое</param>
            <param name="B">Вычитаемое</param>
            <returns>Разность двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.op_Multiply(MathCore.MatrixFloat,MathCore.MatrixFloat)">
            <summary>Оператор произведения двух матриц</summary>
            <param name="A">Первый сомножитель</param>
            <param name="B">Второй сомножитель</param>
            <returns>Произведение двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.op_Division(MathCore.MatrixFloat,MathCore.MatrixFloat)">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param>
            <param name="B">Делитель</param>
            <returns>Частное двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.op_BitwiseOr(MathCore.MatrixFloat,MathCore.MatrixFloat)">
            <summary>Конкатенация двух матриц (либо по строкам, либо по столбцам)</summary>
            <param name="A">Первое слагаемое</param>
            <param name="B">Второе слагаемое</param>
            <returns>Объединённая матрица</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.op_Implicit(System.Single)~MathCore.MatrixFloat">
            <summary>Оператор неявного приведения типа вещественного числа двойной точности к типу Матрица порядка 1х1</summary>
            <param name="X">Приводимое число</param><returns>Матрица порядка 1х1</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MatrixFloat.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:MathCore.MatrixInt">
            <summary>Матрица NxM</summary>
            <remarks>
            i (первый индекс) - номер строки, 
            j (второй индекс) - номер столбца
            ------------ j ---------->
            | a11 a12 a13 a14 a15 a16 a1M
            | a21........................
            | a31........................
            | a41.......aij..............
            i a51........................
            | a61........................
            | aN1.....................aNM
            \/
            </remarks>
        </member>
        <member name="M:MathCore.MatrixInt.GetUnitaryMatrix(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param>
            <returns>Единичная матрица размерности NxN</returns>
        </member>
        <member name="M:MathCore.MatrixInt.GetTransvection(MathCore.MatrixInt,System.Int32)">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="j">Опорный столбец</param>
            <returns>Трансвекция матрицы А</returns>
        </member>
        <member name="F:MathCore.MatrixInt._N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="F:MathCore.MatrixInt._M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="F:MathCore.MatrixInt._Data">
            <summary>Элементы матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixInt.N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixInt.M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixInt.Item(System.Int32,System.Int32)">
            <summary>Элемент матрицы</summary>
            <param name="i">Номер строки (элемента в столбце)</param>
            <param name="j">Номер столбца (элемента в строке)</param>
            <returns>Элемент матрицы</returns>
        </member>
        <member name="P:MathCore.MatrixInt.Item(System.Int32)">
            <summary>Вектор-столбец</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы</returns>
        </member>
        <member name="P:MathCore.MatrixInt.IsSquare">
            <summary>Матрица является квадратной матрицей</summary>
        </member>
        <member name="P:MathCore.MatrixInt.IsCol">
            <summary>Матрица является столбцом</summary>
        </member>
        <member name="P:MathCore.MatrixInt.IsRow">
            <summary>Матрица является строкой</summary>
        </member>
        <member name="P:MathCore.MatrixInt.IsDigit">
            <summary>Матрица является числом</summary>
        </member>
        <member name="M:MathCore.MatrixInt.#ctor(System.Int32,System.Int32)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
        </member>
        <member name="M:MathCore.MatrixInt.#ctor(System.Int32)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
        </member>
        <member name="T:MathCore.MatrixInt.MatrixIntItemCreator">
            <summary>Метод определения значения элемента матрицы</summary>
            <param name="i">Номер строки</param>
            <param name="j">Номер столбца</param>
            <returns>Значение элемента матрицы M[<paramref name="i"/>, <paramref name="j"/>]</returns>
        </member>
        <member name="M:MathCore.MatrixInt.#ctor(System.Int32,MathCore.MatrixInt.MatrixIntItemCreator)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathCore.MatrixInt.#ctor(System.Int32,System.Int32,MathCore.MatrixInt.MatrixIntItemCreator)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathCore.MatrixInt.GetCol(System.Int32)">
            <summary>Получить столбец матрицы</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы номер j</returns>
        </member>
        <member name="M:MathCore.MatrixInt.GetRow(System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="i">Номер строки</param>
            <returns>Строка матрицы номер i</returns>
        </member>
        <member name="M:MathCore.MatrixInt.GetTriangle">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <returns></returns>
        </member>
        <member name="M:MathCore.MatrixInt.GetInverse">
            <summary>Получить обратную матрицу</summary>
            <returns>Обратная матрица</returns>
        </member>
        <member name="M:MathCore.MatrixInt.GetTranspose">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
        </member>
        <member name="M:MathCore.MatrixInt.GetAdjunct(System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
        </member>
        <member name="M:MathCore.MatrixInt.GetMinor(System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
        </member>
        <member name="M:MathCore.MatrixInt.GetDeterminant">
            <summary>Определитель матрицы</summary>
        </member>
        <member name="M:MathCore.MatrixInt.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MatrixInt.Clone">
            <summary>Клонирование матрицы</summary>
            <returns>Копия текущей матрицы</returns>
        </member>
        <member name="M:MathCore.MatrixInt.op_Addition(MathCore.MatrixInt,MathCore.MatrixInt)">
            <summary>Оператор сложения двух матриц</summary>
            <param name="A">Первое слагаемое</param>
            <param name="B">Второе слагаемое</param>
            <returns>Сумма двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixInt.op_Subtraction(MathCore.MatrixInt,MathCore.MatrixInt)">
            <summary>Оператор разности двух матриц</summary>
            <param name="A">Уменьшаемое</param>
            <param name="B">Вычитаемое</param>
            <returns>Разность двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixInt.op_Multiply(MathCore.MatrixInt,MathCore.MatrixInt)">
            <summary>Оператор произведения двух матриц</summary>
            <param name="A">Первый сомножитель</param>
            <param name="B">Второй сомножитель</param>
            <returns>Произведение двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixInt.op_Division(MathCore.MatrixInt,MathCore.MatrixInt)">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param>
            <param name="B">Делитель</param>
            <returns>Частное двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixInt.op_BitwiseOr(MathCore.MatrixInt,MathCore.MatrixInt)">
            <summary>Конкатенация двух матриц (либо по строкам, либо по столбцам)</summary>
            <param name="A">Первое слагаемое</param>
            <param name="B">Второе слагаемое</param>
            <returns>Объединённая матрица</returns>
        </member>
        <member name="M:MathCore.MatrixInt.op_Implicit(System.Int32)~MathCore.MatrixInt">
            <summary>Оператор неявного приведения типа вещественного числа двойной точности к типу Матрица порядка 1х1</summary>
            <param name="X">Приводимое число</param><returns>Матрица порядка 1х1</returns>
        </member>
        <member name="M:MathCore.MatrixInt.System#IEquatable{MathCore#MatrixInt}#Equals(MathCore.MatrixInt)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MatrixInt.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MatrixInt.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:MathCore.MatrixLong">
            <summary>Матрица NxM</summary>
            <remarks>
            ------------ j ---------->
            | a11 a12 a13 a14 a15 a16 a1M
            | a21........................
            | a31........................
            | a41.......aij..............
            i a51........................
            | a61........................
            | aN1.....................aNM
            \/
            </remarks>
        </member>
        <member name="M:MathCore.MatrixLong.GetUnitaryMatrix(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param>
            <returns>Единичная матрица размерности NxN</returns>
        </member>
        <member name="M:MathCore.MatrixLong.GetTransvection(MathCore.MatrixLong,System.Int32)">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="j">Опорный столбец</param>
            <returns>Трансвекция матрицы А</returns>
        </member>
        <member name="F:MathCore.MatrixLong._N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="F:MathCore.MatrixLong._M">
            <summary>Число столбцов матриц</summary>
        </member>
        <member name="F:MathCore.MatrixLong._Data">
            <summary>Элементы матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixLong.N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixLong.M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixLong.Item(System.Int32,System.Int32)">
            <summary>Элемент матрицы</summary>
            <param name="i">Номер строки (элемента в столбце)</param>
            <param name="j">Номер столбца (элемента в строке)</param>
            <returns>Элемент матрицы</returns>
        </member>
        <member name="P:MathCore.MatrixLong.Item(System.Int32)">
            <summary>Вектор-столбец</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы</returns>
        </member>
        <member name="P:MathCore.MatrixLong.IsSquare">
            <summary>Матрица является квадратной матрицей</summary>
        </member>
        <member name="P:MathCore.MatrixLong.IsCol">
            <summary>Матрица является столбцом</summary>
        </member>
        <member name="P:MathCore.MatrixLong.IsRow">
            <summary>Матрица является строкой</summary>
        </member>
        <member name="P:MathCore.MatrixLong.IsDigit">
            <summary>Матрица является числом</summary>
        </member>
        <member name="M:MathCore.MatrixLong.#ctor(System.Int32,System.Int32)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
        </member>
        <member name="M:MathCore.MatrixLong.#ctor(System.Int32)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
        </member>
        <member name="M:MathCore.MatrixLong.#ctor(System.Int32,System.Func{System.Int32,System.Int32,System.Int64})">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathCore.MatrixLong.#ctor(System.Int32,System.Int32,System.Func{System.Int32,System.Int32,System.Int64})">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathCore.MatrixLong.GetCol(System.Int32)">
            <summary>Получить столбец матрицы</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы номер j</returns>
        </member>
        <member name="M:MathCore.MatrixLong.GetRow(System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="i">Номер строки</param>
            <returns>Строка матрицы номер i</returns>
        </member>
        <member name="M:MathCore.MatrixLong.GetTriangle">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <returns></returns>
        </member>
        <member name="M:MathCore.MatrixLong.GetInverse">
            <summary>Получить обратную матрицу</summary>
            <returns>Обратная матрица</returns>
        </member>
        <member name="M:MathCore.MatrixLong.GetTranspose">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
        </member>
        <member name="M:MathCore.MatrixLong.GetAdjunct(System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
        </member>
        <member name="M:MathCore.MatrixLong.GetMinor(System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
        </member>
        <member name="M:MathCore.MatrixLong.GetDeterminant">
            <summary>Определитель матрицы</summary>
        </member>
        <member name="M:MathCore.MatrixLong.LUDecomposition(System.Int64[0:,0:],System.Int64[0:,0:]@,System.Int64[0:,0:]@,System.Int64[0:,0:]@)">
            <summary>
            Returns the LU Decomposition of a matrix. 
            the output is: lower triangular matrix L, upper
            triangular matrix U, and permutation matrix P so that
            P*X = L*U.
            In case of an error the error is raised as an exception.
            Note: This method is based on the 'LU Decomposition and Its Applications'
            section of Numerical Recipes in C by William H. Press,
            Saul A. Teukolsky, William T. Vetterling and Brian P. Flannery,
            University of Cambridge Press 1992.  
            </summary>
            <param name="Mat">Array which will be LU Decomposed</param>
            <param name="L">An array where the lower triangular matrix is returned</param>
            <param name="U">An array where the upper triangular matrix is returned</param>
            <param name="P">An array where the permutation matrix is returned</param>
        </member>
        <member name="M:MathCore.MatrixLong.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MatrixLong.Clone">
            <summary>Клонирование матрицы</summary>
            <returns>Копия текущей матрицы</returns>
        </member>
        <member name="M:MathCore.MatrixLong.op_Addition(MathCore.MatrixLong,MathCore.MatrixLong)">
            <summary>Оператор сложения двух матриц</summary>
            <param name="A">Первое слагаемое</param>
            <param name="B">Второе слагаемое</param>
            <returns>Сумма двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixLong.op_Subtraction(MathCore.MatrixLong,MathCore.MatrixLong)">
            <summary>Оператор разности двух матриц</summary>
            <param name="A">Уменьшаемое</param>
            <param name="B">Вычитаемое</param>
            <returns>Разность двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixLong.op_Multiply(MathCore.MatrixLong,MathCore.MatrixLong)">
            <summary>Оператор произведения двух матриц</summary>
            <param name="A">Первый сомножитель</param>
            <param name="B">Второй сомножитель</param>
            <returns>Произведение двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixLong.op_Division(MathCore.MatrixLong,MathCore.MatrixLong)">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param>
            <param name="B">Делитель</param>
            <returns>Частное двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixLong.op_BitwiseOr(MathCore.MatrixLong,MathCore.MatrixLong)">
            <summary>Конкатенация двух матриц (либо по строкам, либо по столбцам)</summary>
            <param name="A">Первое слагаемое</param>
            <param name="B">Второе слагаемое</param>
            <returns>Объединённая матрица</returns>
        </member>
        <member name="M:MathCore.MatrixLong.op_Implicit(System.Int64)~MathCore.MatrixLong">
            <summary>
            Оператор неявного приведения типа вещественного числа двойной точности к типу 
            Матрица порядка 1х1
            </summary>
            <param name="X">Приводимое число</param>
            <returns>Матрица порядка 1х1</returns>
        </member>
        <member name="M:MathCore.MatrixLong.System#IEquatable{MathCore#MatrixLong}#Equals(MathCore.MatrixLong)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MatrixLong.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MatrixLong.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Monads.WorkFlow.ActionWork">
            <summary>Работа, выполняющая действие</summary>
        </member>
        <member name="F:MathCore.Monads.WorkFlow.ActionWork._WorkAction">
            <summary>Действие, выполняемое работой</summary>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.ActionWork.#ctor(System.Action,MathCore.Monads.WorkFlow.Work)">
            <summary>Инициализация нового работы на основе действия</summary>
            <param name="WorkAction">Действие, выполняемое в рамках работы</param>
            <param name="BaseWork">Базовая работа</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.ActionWork.Execute(MathCore.Monads.WorkFlow.IWorkResult)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Monads.WorkFlow.ConstValueWork`1">
            <summary>Работа, возвращающая указанное константное значение</summary>
            <typeparam name="T">Тип возвращаемого работой значения</typeparam>
        </member>
        <member name="P:MathCore.Monads.WorkFlow.ConstValueWork`1.Value">
            <summary>Значение, возвращаемое работой</summary>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.ConstValueWork`1.#ctor(`0,MathCore.Monads.WorkFlow.Work)">
            <summary>Инициализация новой работы, возвращающей константное значение</summary>
            <param name="Value">Значение, которое будет возвращать работа</param>
            <param name="BaseWork">Базовая работа</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.ConstValueWork`1.Execute(MathCore.Monads.WorkFlow.IWorkResult)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Monads.WorkFlow.FunctionWork`1">
            <summary>Работа, выполняющая указанную функцию</summary>
            <typeparam name="T">Тип значения функции</typeparam>
        </member>
        <member name="F:MathCore.Monads.WorkFlow.FunctionWork`1._WorkFunction">
            <summary>Функция, выполняемая в рамках работы</summary>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.FunctionWork`1.#ctor(System.Func{`0},MathCore.Monads.WorkFlow.Work)">
            <summary>Инициализация новой работы, выполняющей указанную функцию</summary>
            <param name="WorkFunction">Функция, выполняемая работой</param>
            <param name="BaseWork">Базовая работа</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.FunctionWork`1.Execute(MathCore.Monads.WorkFlow.IWorkResult)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Monads.WorkFlow.IWorkResult">
            <summary>Результат выполнения работы</summary>
        </member>
        <member name="P:MathCore.Monads.WorkFlow.IWorkResult.Error">
            <summary>Ошибка, которая произошла в ходе выполнения работы</summary>
        </member>
        <member name="P:MathCore.Monads.WorkFlow.IWorkResult.Success">
            <summary>Признак того, что работа завершилась успешно</summary>
        </member>
        <member name="P:MathCore.Monads.WorkFlow.IWorkResult.Failure">
            <summary>Признак того, что работа завершилась провалом</summary>
        </member>
        <member name="T:MathCore.Monads.WorkFlow.IWorkResult`1">
            <summary>Результат выполнения работы со значением</summary>
            <typeparam name="T">Тип результата, доступного после выполнения работы</typeparam>
        </member>
        <member name="P:MathCore.Monads.WorkFlow.IWorkResult`1.Result">
            <summary>Результат выполнения работы</summary>
        </member>
        <member name="T:MathCore.Monads.WorkFlow.IWorkResult`2">
            <summary>Результат выполнения параметрической работы</summary>
            <typeparam name="TParameter">Тип параметра работы</typeparam>
            <typeparam name="T">Тип значения, доступного по завершении работы</typeparam>
        </member>
        <member name="P:MathCore.Monads.WorkFlow.IWorkResult`2.Parameter">
            <summary>Параметр, с которым работа была выполнена</summary>
        </member>
        <member name="T:MathCore.Monads.WorkFlow.Work`2">
            <summary>Работа, выполняющая преобразование данных указанным методом</summary>
            <typeparam name="TParameter">Тип сходных данных для преобразования</typeparam>
            <typeparam name="TResult">Тип результата преобразования</typeparam>
        </member>
        <member name="F:MathCore.Monads.WorkFlow.Work`2._WorkFunction">
            <summary>Функция преобразования значения, выполняемая в рамках работы</summary>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`2.#ctor(System.Func{`0,`1},MathCore.Monads.WorkFlow.Work)">
            <summary>Внутренняя инициализация новой работы по преобразованию значения на основе указанной функции</summary>
            <param name="WorkFunction">Функция, преобразующая значение</param>
            <param name="BaseWork">Базовая работа, являющаяся источником аргумента функции</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`2.#ctor(System.Func{`0,`1},MathCore.Monads.WorkFlow.Work{`0})">
            <summary>Инициализация новой работы по преобразованию значения на основе указанной функции</summary>
            <param name="WorkFunction">Функция, преобразующая значение</param>
            <param name="BaseWork">Базовая работа, являющаяся источником аргумента функции</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`2.Execute(MathCore.Monads.WorkFlow.IWorkResult)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`2.Execute">
            <summary>Выполнение работы</summary>
            <returns>Результат выполнения работы, содержавший исходные данные и полученное значение</returns>
        </member>
        <member name="T:MathCore.Monads.WorkFlow.Work`1">
            <summary>Работа, возвращающая значение</summary>
            <typeparam name="T">Тип результата работы</typeparam>
        </member>
        <member name="T:MathCore.Monads.WorkFlow.Work`1.FunctionWorkIfSuccess`2">
            <summary>Работа по преобразованию значения, выполняемая в случае, если предыдущая работа была выполнена успешно</summary>
            <typeparam name="TParameter">Тип исходных данных преобразования</typeparam>
            <typeparam name="TResult">Тип результата</typeparam>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`1.FunctionWorkIfSuccess`2.#ctor(System.Func{`1,`2},MathCore.Monads.WorkFlow.Work{`1})">
            <summary>Инициализация новой работы по преобразованию значения, выполняемой в случае если предыдущая работа была выполнена успешно</summary>
            <param name="WorkFunction">Метод преобразования значения</param>
            <param name="BaseWork">Предыдущая работа, формирующая исходные данные для текущей выполняемой работы</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`1.FunctionWorkIfSuccess`2.Execute(MathCore.Monads.WorkFlow.IWorkResult)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Monads.WorkFlow.Work`1.ActionWork`1">
            <summary>Работа, выполняемая над результатом предыдущей работы</summary>
            <typeparam name="TParameter">Тип результата предыдущей работы</typeparam>
        </member>
        <member name="F:MathCore.Monads.WorkFlow.Work`1.ActionWork`1._WorkAction">
            <summary>Действие, выполняемое над результатом предыдущей работы</summary>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`1.ActionWork`1.#ctor(System.Action{`1},MathCore.Monads.WorkFlow.Work{`1})">
            <summary>Инициализация новой работы, выполняющей действие над результатом выполнения предыдущей работы</summary>
            <param name="WorkAction">Действие, выполняемое над результатом предыдущей работы</param>
            <param name="BaseWork">Предыдущая работа</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`1.ActionWork`1.Execute(MathCore.Monads.WorkFlow.IWorkResult)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`1.#ctor(MathCore.Monads.WorkFlow.Work)">
            <summary>Инициализация новой работы</summary><param name="BaseWork">объект базовой работы</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`1.Execute">
            <summary>Выполнение работы</summary><returns>Результат работы</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`1.Invoke(System.Action{`0})">
            <summary>Действие, выполняемое в любом случае для результата предыдущей работы</summary>
            <param name="action">Выполняемое действие</param>
            <returns>Работа, выполняющая действие для результата выполнения предыдущей работы</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`1.Get``1(System.Func{`0,``0})">
            <summary>Работа, в результате которой формируется результат</summary>
            <typeparam name="TResult">Тип результата работы</typeparam>
            <param name="function">Функция, выполняемая в рамках работы над параметром, получаемым от предыдущей работы</param>
            <returns>Работа по получению результата</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`1.GetIfSuccess``1(System.Func{`0,``0})">
            <summary>Выполнение преобразования в случае если предыдущая работа выполнена успешно</summary>
            <typeparam name="TResult">Результат преобразования</typeparam>
            <param name="function">Метод преобразования значения</param>
            <returns>Работа по преобразованию значения, выполняемая в случае, если предыдущая работа выполнена успешно</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`1.GetIfFailure(System.Func{System.Exception,`0})">
            <summary>Добавление обработчика исключительных ситуаций</summary>
            <param name="ErrorHandler">Функция, получающая в качестве параметра исключение и на его основе формирующая значение функции</param>
            <returns>Работа по обработке исключений, возникающих на предыдущих этапах выполнения работы</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`1.op_Implicit(MathCore.Monads.WorkFlow.Work{`0})~`0">
            <summary>Оператор неявного преобразования типа <see cref="T:MathCore.Monads.WorkFlow.Work`1"/> к типу <typeparamref name="T"/></summary>
            <param name="work">Работа с типизированным результатом <see cref="T:MathCore.Monads.WorkFlow.Work`1"/></param>
            <returns>Результат выполнения работы типа <typeparamref name="T"/></returns>
        </member>
        <member name="T:MathCore.Monads.WorkFlow.Work">
            <summary>Класс-оболочка для выполняемой работы</summary>
        </member>
        <member name="T:MathCore.Monads.WorkFlow.Work.ActionWorkIfSuccess">
            <summary>Работа на основе действия, выполняемая лишь в том случае, если базовая работа выполнилась успешно</summary>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.ActionWorkIfSuccess.#ctor(System.Action,MathCore.Monads.WorkFlow.Work)">
            <summary>Инициализация новой работы, выполняемой в случае успешного выполнения предыдущей работы</summary>
            <param name="WorkAction">Действие, выполняемое в рамках работы</param>
            <param name="BaseWork">Базовая работа</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.ActionWorkIfSuccess.Execute(MathCore.Monads.WorkFlow.IWorkResult)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Monads.WorkFlow.Work.ActionWorkIfFailure">
            <summary>Работа на основе действия, выполняемая лишь в том случае, если базовая работа выполнилась с ошибкой</summary>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.ActionWorkIfFailure.#ctor(System.Action,MathCore.Monads.WorkFlow.Work)">
            <summary>Инициализация новой работы, выполняемой в случае ошибочного выполнения предыдущей работы</summary>
            <param name="WorkAction">Действие, выполняемое в рамках работы</param>
            <param name="BaseWork">Базовая работа</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.ActionWorkIfFailure.Execute(MathCore.Monads.WorkFlow.IWorkResult)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Monads.WorkFlow.Work.ExceptionActionHandler">
            <summary>Работа по обработке ошибок</summary>
        </member>
        <member name="F:MathCore.Monads.WorkFlow.Work.ExceptionActionHandler._ErrorHandler">
            <summary>Действие-обработчик исключения</summary>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.ExceptionActionHandler.#ctor(System.Action{System.Exception},MathCore.Monads.WorkFlow.Work)">
            <summary>Инициализация новой работы по обработке ошибок</summary>
            <param name="ErrorHandler">Действие-обработчик ошибок</param>
            <param name="BaseWork">Базовая работа</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.ExceptionActionHandler.Execute(MathCore.Monads.WorkFlow.IWorkResult)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Monads.WorkFlow.Work.FunctionWorkIfSuccess`1">
            <summary>Работа, возвращающая результат выполнения функции в случае если предыдущая работа завершилась успешно</summary>
            <typeparam name="T">Тип значения функции</typeparam>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.FunctionWorkIfSuccess`1.#ctor(System.Func{`0},MathCore.Monads.WorkFlow.Work)">
            <summary>Инициализация новой работы, возвращающей значение функции в случае если предыдущая работа завершилась успешно</summary>
            <param name="WorkFunction">Функция, выполняемая в рамках работы</param>
            <param name="BaseWork">Базовая работа</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.FunctionWorkIfSuccess`1.Execute(MathCore.Monads.WorkFlow.IWorkResult)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Monads.WorkFlow.Work.FunctionWorkIfFailure`1">
            <summary>Работа по преобразованию значения, выполняемая в случае, если предыдущая работа завершилась исключением</summary>
            <typeparam name="T">Тип значения</typeparam>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.FunctionWorkIfFailure`1.#ctor(System.Func{`0},MathCore.Monads.WorkFlow.Work)">
            <summary>Инициализация новой работы, выполняемой в случае неудачи предыдущей работы</summary>
            <param name="WorkFunction">Функция - генератор значения</param>
            <param name="BaseWork">Базовая работа</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.FunctionWorkIfFailure`1.Execute(MathCore.Monads.WorkFlow.IWorkResult)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Monads.WorkFlow.Work.ExceptionFunctionHandler`1">
            <summary>Работа по обработке ошибок</summary><typeparam name="T">Тип исключительной ситуации</typeparam>
        </member>
        <member name="F:MathCore.Monads.WorkFlow.Work.ExceptionFunctionHandler`1._ErrorHandler">
            <summary>Функция-обработчик исключения</summary>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.ExceptionFunctionHandler`1.#ctor(System.Func{System.Exception,`0},MathCore.Monads.WorkFlow.Work{`0})">
            <summary>Инициализация новой работы по обработке ошибок</summary>
            <param name="ErrorHandler">Функция-обработчик ошибок</param>
            <param name="BaseWork">Базовая работа</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.ExceptionFunctionHandler`1.Execute(MathCore.Monads.WorkFlow.IWorkResult)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.BeginInvoke(System.Action)">
            <summary>Начало работы на основе делегата действия</summary>
            <param name="WorkAction">Делегат, на основе которого формируется работа</param>
            <returns>Работа, выполняющая указанный делегат</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.BeginGet``1(System.Func{``0})">
            <summary>Начало работы с указанной функцией</summary>
            <typeparam name="T">Тип значения, возвращаемого функцией</typeparam>
            <param name="WorkFunction">Функция, выполняемая работой</param>
            <returns>Работа, выполняющая указанную функцию, возвращающую значение</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.With``1(``0)">
            <summary>Фиксированное исходное значение для начала работы</summary>
            <typeparam name="T">Тип значения</typeparam>
            <param name="value">Исходное, используемое в дальнейшем, значение</param>
            <returns>Работа, результатом которой является указанное значение</returns>
        </member>
        <member name="F:MathCore.Monads.WorkFlow.Work._BaseWork">
            <summary>Базовая работа</summary>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.#ctor(MathCore.Monads.WorkFlow.Work)">
            <summary>Инициализация нового работы</summary><param name="BaseWork">Базовая работа</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.Execute(MathCore.Monads.WorkFlow.IWorkResult)">
            <summary>Выполнить действие текущей работы</summary>
            <param name="BaseResult">Результат выполнения предыдущей работы</param>
            <returns>Результат выполнения действия</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.Execute">
            <summary>Выполнить работу</summary>
            <returns>Результат выполнения работы</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.Invoke(System.Action)">
            <summary>Действие, выполняемое в любом случае</summary>
            <param name="action">Выполняемое действие</param>
            <returns>Сформированная работа, выполняемая в любом случае</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.InvokeIfSuccess(System.Action)">
            <summary>Действие, выполняемое в случае успеха предыдущего действия</summary>
            <param name="action">Выполняемое действие</param>
            <returns>Сформированная работа, выполняемая в случае успеха предыдущего действия</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.InvokeIfFailure(System.Action)">
            <summary>Работа, которую надо выполнить в случае, если предыдущая работа завершилась с ошибкой</summary>
            <param name="action">Действие, выполняемое в случае неудачи предыдущего действия</param>
            <returns>Сформированная работа, выполняемая в случае неудачи предыдущего действия</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.InvokeIfFailure(System.Action{System.Exception})">
            <summary>Действие, выполняемое в случае неудачи предыдущего действия</summary>
            <param name="ErrorHandler">Обработчик ошибки</param>
            <returns>Сформированная работа, выполняемая в случае неудачи предыдущего действия</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.Get``1(System.Func{``0})">
            <summary>Выполнение функции в любом случае</summary>
            <typeparam name="T">Тип значения функции</typeparam>
            <param name="function">Функция, выполняемая в рамках работы</param>
            <returns>Работа, выполняющая функцию, возвращающую значение</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.GetIfSuccess``1(System.Func{``0})">
            <summary>Выполнение функции в случае если предыдущая работа завершилась успешно</summary>
            <typeparam name="T">Тип результата функции</typeparam>
            <param name="function">Выполняемая функция</param>
            <returns>Работа, выполняющая функцию в случае если предыдущая работа завершилась успешно</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.GetIfFailure``1(System.Func{``0})">
            <summary>Работа, выполняемая в случае если функция завершилась ошибкой</summary>
            <typeparam name="T">Тип значения функции</typeparam>
            <param name="function">Функция, выполняемая в случае неудачи</param>
            <returns>Работа, выполняющая функцию в случае неудачи предыдущей работы</returns>
        </member>
        <member name="T:MathCore.Monads.WorkFlow.WorkResult">
            <summary>Результат выполнения работы</summary>
        </member>
        <member name="P:MathCore.Monads.WorkFlow.WorkResult.Error">
            <inheritdoc />
        </member>
        <member name="P:MathCore.Monads.WorkFlow.WorkResult.Success">
            <inheritdoc />
        </member>
        <member name="P:MathCore.Monads.WorkFlow.WorkResult.Failure">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Monads.WorkFlow.WorkResult.#ctor(System.Exception,System.Exception)">
            <summary>Инициализация нового результата выполнения работы</summary>
            <param name="PrevError">Ошибка предыдущего процесса выполнения работы</param>
            <param name="CurrentError">Ошибка текущего процесса выполнения работы</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.WorkResult.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Monads.WorkFlow.WorkResult.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Monads.WorkFlow.WorkResult`1">
            <summary>Результат выполнения работы со значением</summary>
            <typeparam name="T">Тип результата, доступного после выполнения работы</typeparam>
        </member>
        <member name="P:MathCore.Monads.WorkFlow.WorkResult`1.Error">
            <inheritdoc />
        </member>
        <member name="P:MathCore.Monads.WorkFlow.WorkResult`1.Success">
            <inheritdoc />
        </member>
        <member name="P:MathCore.Monads.WorkFlow.WorkResult`1.Failure">
            <inheritdoc />
        </member>
        <member name="P:MathCore.Monads.WorkFlow.WorkResult`1.Result">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Monads.WorkFlow.WorkResult`1.#ctor(`0,System.Exception)">
            <summary>Инициализация нового результата выполнения работы</summary>
            <param name="Result">Результат выполнения работы</param>
            <param name="PrevError">Ошибка предыдущего процесса выполнения работы</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.WorkResult`1.#ctor(System.Exception,System.Exception)">
            <summary>Инициализация нового результата выполнения работы</summary>
            <param name="PrevError">Ошибка предыдущего процесса выполнения работы</param>
            <param name="CurrentError">Ошибка текущего процесса выполнения работы</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.WorkResult`1.Equals(MathCore.Monads.WorkFlow.WorkResult{`0})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Monads.WorkFlow.WorkResult`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Monads.WorkFlow.WorkResult`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Monads.WorkFlow.WorkResult`2">
            <summary>Результат выполнения параметрической работы</summary>
            <typeparam name="TParameter">Тип параметра работы</typeparam>
            <typeparam name="T">Тип значения, доступного по завершении работы</typeparam>
        </member>
        <member name="P:MathCore.Monads.WorkFlow.WorkResult`2.Error">
            <inheritdoc />
        </member>
        <member name="P:MathCore.Monads.WorkFlow.WorkResult`2.Success">
            <inheritdoc />
        </member>
        <member name="P:MathCore.Monads.WorkFlow.WorkResult`2.Failure">
            <inheritdoc />
        </member>
        <member name="P:MathCore.Monads.WorkFlow.WorkResult`2.Parameter">
            <inheritdoc />
        </member>
        <member name="P:MathCore.Monads.WorkFlow.WorkResult`2.Result">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Monads.WorkFlow.WorkResult`2.#ctor(System.Exception)">
            <summary>Инициализация нового результата выполнения работы</summary>
            <param name="PrevError">Ошибка предыдущего процесса выполнения работы</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.WorkResult`2.#ctor(`0,`1,System.Exception)">
            <summary>Инициализация нового результата выполнения работы</summary>
            <param name="Parameter">Параметр текущего процесса выполнения работы</param>
            <param name="Result">Результат выполнения работы</param>
            <param name="PrevError">Ошибка предыдущего процесса выполнения работы</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.WorkResult`2.#ctor(`0,System.Exception,System.Exception)">
            <summary>Инициализация нового результата выполнения работы</summary>
            <param name="Parameter">Параметр текущего процесса выполнения работы</param>
            <param name="PrevError">Ошибка предыдущего процесса выполнения работы</param>
            <param name="CurrentError">Ошибка текущего процесса выполнения работы</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.WorkResult`2.Equals(MathCore.Monads.WorkFlow.WorkResult{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Monads.WorkFlow.WorkResult`2.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Monads.WorkFlow.WorkResult`2.GetHashCode">
            <inheritdoc />
        </member>
        <member name="F:MathCore.Optimization.ParticleSwarm.Swarm._Inertia">
            <summary>Вес инерции</summary>
        </member>
        <member name="F:MathCore.Optimization.ParticleSwarm.Swarm._LocalWeight">
            <summary>Коэффициент локального веса</summary>
        </member>
        <member name="P:MathCore.Optimization.ParticleSwarm.Swarm.LocalWeight">
            <summary>Коэффициент стремления точки к своему собственному лучшему значению</summary>
        </member>
        <member name="F:MathCore.Optimization.ParticleSwarm.Swarm._GlobalWeight">
            <summary>Коэффициент стремления всех точек к лучшему значению</summary>
        </member>
        <member name="P:MathCore.Optimization.ParticleSwarm.Swarm.GlobalWeight">
            <summary>Коэффициент стремления всех точек к лучшему значению</summary>
        </member>
        <member name="F:MathCore.Optimization.ParticleSwarm.Swarm1D._Inertia">
            <summary>Вес инерции</summary>
        </member>
        <member name="F:MathCore.Optimization.ParticleSwarm.Swarm1D._LocalWeight">
            <summary>Коэффициент локального веса</summary>
        </member>
        <member name="P:MathCore.Optimization.ParticleSwarm.Swarm1D.LocalWeight">
            <summary>Коэффициент стремления точки к своему собственному лучшему значению</summary>
        </member>
        <member name="F:MathCore.Optimization.ParticleSwarm.Swarm1D._GlobalWeight">
            <summary>Коэффициент стремления всех точек к лучшему значению</summary>
        </member>
        <member name="P:MathCore.Optimization.ParticleSwarm.Swarm1D.GlobalWeight">
            <summary>Коэффициент стремления всех точек к лучшему значению</summary>
        </member>
        <member name="T:MathCore.Optimization.ParticleSwarm.Swarm2D">
            <summary>Рой двумерных частиц</summary>
        </member>
        <member name="F:MathCore.Optimization.ParticleSwarm.Swarm2D._Inertia">
            <summary>Вес инерции</summary>
        </member>
        <member name="F:MathCore.Optimization.ParticleSwarm.Swarm2D._LocalWeight">
            <summary>Коэффициент локального веса</summary>
        </member>
        <member name="P:MathCore.Optimization.ParticleSwarm.Swarm2D.LocalWeight">
            <summary>Коэффициент стремления точки к своему собственному лучшему значению</summary>
        </member>
        <member name="F:MathCore.Optimization.ParticleSwarm.Swarm2D._GlobalWeight">
            <summary>Коэффициент стремления всех точек к лучшему значению</summary>
        </member>
        <member name="P:MathCore.Optimization.ParticleSwarm.Swarm2D.GlobalWeight">
            <summary>Коэффициент стремления всех точек к лучшему значению</summary>
        </member>
        <member name="T:MathCore.Optimization.ParticleSwarm.Swarm2D.Particle2D">
            <summary>Частица</summary>
        </member>
        <member name="F:MathCore.Optimization.ParticleSwarm.Swarm2D._ParticleCount">
            <summary>Размер роя</summary>
        </member>
        <member name="T:MathCore.Polynom">
            <summary>
            Полином степени N-1
             a[0]+a[1]*x+a[2]*x^2+...+a[N-1]*x^(N-1)+a[N-1]*x^(N-1)
            где N - число элементов массива коэффициентов
            Нулевой элемент массива при нулевой степени члена полинома 
            </summary>
        </member>
        <member name="T:MathCore.Polynom.Array">
            <summary>Операции над коэффициентами полинома, в представлении массива значений</summary>
        </member>
        <member name="M:MathCore.Polynom.Array.GetValue(System.Double,System.Double[])">
            <summary>Рассчитать значение полинома</summary>
            <param name="x">Аргумент полинома</param>
            <param name="A">Массив коэффициентов полинома</param>
            <returns>Значение полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetValue(MathCore.Complex,System.Double[])">
            <summary>Рассчитать комплексное значение полинома</summary>
            <param name="z">Аргумент полинома</param>
            <param name="A">Массив коэффициентов полинома</param>
            <returns>Комплексное значение полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetValue(MathCore.Complex,MathCore.Complex[])">
            <summary>Рассчитать комплексное значение полинома с комплексными коэффициентами</summary>
            <param name="z">Комплексный аргумент полинома</param>
            <param name="Z">Массив комплексных коэффициентов полинома</param>
            <returns>Комплексное значение полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetValue(System.Double,System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Рассчитать значение полинома</summary>
            <param name="x">Аргумент полинома</param>
            <param name="A">Массив коэффициентов полинома</param>
            <returns>Значение полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetValue(MathCore.Complex,System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Рассчитать комплексное значение полинома</summary>
            <param name="z">Аргумент полинома</param>
            <param name="A">Массив коэффициентов полинома</param>
            <returns>Комплексное значение полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetCoefficients(System.Double[])">
            <summary>Преобразовать массив корней полинома в коэффициенты при степенях</summary>
            <param name="Root">Корни полинома</param>
            <returns>Коэффициенты при степенях</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetCoefficientsInverted(System.Double[])">
            <summary>Преобразовать массив корней полинома в коэффициенты при обратных степенях</summary>
            <param name="Root">Корни полинома</param>
            <returns>Коэффициенты при обратных степенях</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetCoefficients(MathCore.Complex[])">
            <summary>Преобразовать массив корней полинома в коэффициенты при степенях</summary>
            <param name="Root">Корни полинома</param>
            <returns>Коэффициенты при степенях</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetCoefficientsInverted(MathCore.Complex[])">
            <summary>Преобразовать массив корней полинома в коэффициенты при обратных степенях</summary>
            <param name="Root">Корни полинома</param>
            <returns>Коэффициенты при обратных степенях</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetDifferential(System.Double[],System.Int32)">
            <summary>Дифференциал полинома</summary>
            <param name="p">Массив коэффициентов полинома</param>
            <param name="Order">Порядок дифференцирования</param>
            <returns>Массив коэффициентов полинома - дифференциала</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetDifferential(MathCore.Complex[],System.Int32)">
            <summary>Дифференциал полинома</summary>
            <param name="p">Массив комплексных коэффициентов полинома</param>
            <param name="Order">Порядок дифференцирования</param>
            <returns>Массив комплексных коэффициентов полинома - дифференциала</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetIntegral(System.Double[],System.Double)">
            <summary>Интеграл полинома</summary>
            <param name="p">Массив коэффициентов полинома</param>
            <param name="C">Константа интегрирования</param>
            <returns>Массив коэффициентов полинома - интеграла</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetIntegral(MathCore.Complex[],MathCore.Complex)">
            <summary>Интеграл полинома</summary>
            <param name="p">Массив комплексных коэффициентов полинома</param>
            <param name="C">Константа интегрирования</param>
            <returns>Массив комплексных коэффициентов полинома - интеграла</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.Sum(System.Double[],System.Double[])">
            <summary>Суммирование полиномов</summary>
            <param name="p">Коэффициенты полинома - первого слагаемого</param>
            <param name="q">Коэффициенты полинома - первого слагаемого</param>
            <returns>Коэффициенты полинома - суммы</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.Subtract(System.Double[],System.Double[])">
            <summary>Разность полиномов</summary>
            <param name="p">Коэффициенты полинома - первого уменьшаемого</param>
            <param name="q">Коэффициенты полинома - первого вычитаемого</param>
            <returns>Коэффициенты полинома - разности</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.Divide(System.Double[],System.Double[],System.Double[]@,System.Double[]@)">
            <summary>Деление полиномов</summary>
            <param name="dividend">Коэффициенты полинома - делимое</param>
            <param name="divisor">Коэффициенты полинома - делитель</param>
            <param name="quotient">Коэффициенты полинома - частного</param>
            <param name="remainder">Коэффициенты полинома - остаток от деления</param>
            <returns>Коэффициенты полинома - частное</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.Multiply(System.Double[],System.Double[])">
            <summary>Умножение полиномов</summary>
            <param name="p">Коэффициенты полинома - первый сомножитель</param>
            <param name="q">Коэффициенты полинома - второй сомножитель</param>
            <returns>Коэффициенты полинома - произведение</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.Add(System.Double[],System.Double)">
            <summary>Сложение полинома с вещественным числом</summary>
            <param name="p">Коэффициенты полинома</param>
            <param name="x">Вещественное число</param>
            <returns>Коэффициенты полинома - суммы</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.Subtract(System.Double[],System.Double)">
            <summary>Вычитание вещественного числа из полинома</summary>
            <param name="p">Коэффициенты полинома</param>
            <param name="x">Вещественное число</param>
            <returns>Коэффициенты полинома - разности</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.Subtract(System.Double,System.Double[])">
            <summary>Вычитание полинома из вещественного числа</summary>
            <param name="p">Коэффициенты полинома</param>
            <param name="x">Вещественное число</param>
            <returns>Коэффициенты полинома - разности</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.Negate(System.Double[])">
            <summary>Отрицание полинома</summary>
            <param name="p">Коэффициенты полинома</param>
            <returns>Коэффициенты полинома Q(x) = 0 - P(x)</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.Multiply(System.Double[],System.Double)">
            <summary>Умножение полинома на вещественное число</summary>
            <param name="p">Коэффициенты полинома</param>
            <param name="x">Вещественное число</param>
            <returns>Коэффициенты полинома - произведения</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.Divide(System.Double[],System.Double)">
            <summary>Деление полинома на вещественное число</summary>
            <param name="p">Коэффициенты полинома</param>
            <param name="x">Вещественное число</param>
            <returns>Коэффициенты полинома - частного</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.DivideScalar(System.Double,System.Double[])">
            <summary>Скалярное деление полинома на вещественное число</summary>
            <param name="p">Коэффициенты полинома</param>
            <param name="x">Вещественное число</param>
            <returns>Коэффициенты полинома - частного</returns>
        </member>
        <member name="T:MathCore.Polynom.PolynomDivisionResult">
            <summary>Результат деления полиномов</summary>
        </member>
        <member name="F:MathCore.Polynom.PolynomDivisionResult.Result">
            <summary>Частное полиномов</summary>
        </member>
        <member name="F:MathCore.Polynom.PolynomDivisionResult.Remainder">
            <summary>Остаток деления полиномов</summary>
        </member>
        <member name="F:MathCore.Polynom.PolynomDivisionResult.Divisor">
            <summary>Полином - делитель</summary>
        </member>
        <member name="M:MathCore.Polynom.PolynomDivisionResult.#ctor(MathCore.Polynom,MathCore.Polynom,MathCore.Polynom)">
            <summary>Инициализация результата деления полиномов</summary>
            <param name="Divisor"></param>
            <param name="Result">Частное</param>
            <param name="Remainder">Остаток от деления</param>
        </member>
        <member name="M:MathCore.Polynom.PolynomDivisionResult.Value(System.Double)">
            <summary>Значение результата деления полиномов</summary>
            <param name="x">Аргумент</param>
            <returns>Результат вычисления значения результата деления полиномов</returns>
        </member>
        <member name="M:MathCore.Polynom.PolynomDivisionResult.GetFunction">
            <summary>Получить функцию</summary>
            <returns>Функция вычисления значения результата деления полиномов</returns>
        </member>
        <member name="M:MathCore.Polynom.PolynomDivisionResult.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Polynom.PolynomDivisionResult.op_Implicit(MathCore.Polynom.PolynomDivisionResult)~MathCore.Polynom">
            <summary>Оператор неявного преобразования результата деления полиномов в полином результата</summary>
            <param name="Result">Результат деления полиномов</param>
            <returns>Частное</returns>
        </member>
        <member name="M:MathCore.Polynom.Random(System.Int32,System.Double,System.Double)">
            <summary>Случайный полином</summary>
            <param name="Power">Степень полинома</param>
            <param name="Ma">Математическое ожидание коэффициентов полинома</param>
            <param name="Da">Дисперсия коэффициентов полинома</param>
            <returns>Случайный полином</returns>
        </member>
        <member name="M:MathCore.Polynom.FromCoefficients(System.Double[])">
            <summary>Создание нового полинома из массива его коэффициентов</summary>
            <param name="a">Массив коэффициентов полинома</param>
            <returns>Полином, созданный на основе массива его коэффициентов</returns>
        </member>
        <member name="M:MathCore.Polynom.FromRoots(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Создание нового полинома на основе его корней</summary>
            <param name="roots">Корни полинома</param>
            <returns>Полином, собранный из массива корней</returns>
        </member>
        <member name="M:MathCore.Polynom.FromRoots(System.Double[])">
            <summary>Получить полином из корней полинома</summary>
            <param name="Root">Корни полинома</param>
            <returns>Полином с указанными корнями</returns>
        </member>
        <member name="F:MathCore.Polynom._a">
            <summary>Коэффициенты при степенях</summary>
            <remarks>a[0]+a[1]*x+a[2]*x^2+...+a[N-1]*x^(N-1)+a[N-1]*x^(N-1)</remarks>
        </member>
        <member name="P:MathCore.Polynom.Coefficients">
            <summary>
            Коэффициенты при степенях
              a[0]+a[1]*x+a[2]*x^2+...+a[N-1]*x^(N-1)+a[N-1]*x^(N-1)
            </summary>
        </member>
        <member name="P:MathCore.Polynom.Power">
            <summary>Степень полинома = число коэффициентов - 1</summary>
        </member>
        <member name="P:MathCore.Polynom.Length">
            <summary>Длина полинома - число коэффициентов</summary>
        </member>
        <member name="P:MathCore.Polynom.Item(System.Int32)">
            <summary>
             Коэффициент при степени <paramref name="n"/>, где <paramref name="n"/> принадлежит [0; <see cref="P:MathCore.Polynom.Power"/>]
             <see cref="P:MathCore.Polynom.Power"/> = <see cref="P:MathCore.Polynom.Length"/> - 1
             </summary>
            <param name="n">Степень a[0]+a[1]*x+a[2]*x^2+...<b>+a[<paramref name="n"/>]*x^<paramref name="n"/>+</b>...+a[N-1]*x^(N-1)+a[N-1]*x^(N-1)</param>
        </member>
        <member name="M:MathCore.Polynom.#ctor(System.Double[])">
            <summary>Полином степени N, нулевой элемент массива a[0] при младшей степени x^0</summary>
            <param name="a">a[0]+a[1]*x+a[2]*x^2+...+a[N-1]*x^(N-1)+a[N-1]*x^(N-1)</param>
        </member>
        <member name="M:MathCore.Polynom.#ctor(System.Collections.Generic.IEnumerable{System.Double})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Polynom.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Polynom.Value(System.Double)">
            <summary>Получить значение полинома</summary>
            <param name="x">Аргумент</param>
            <returns>Значение полинома в точке x</returns>
        </member>
        <member name="M:MathCore.Polynom.Value(MathCore.Complex)">
            <summary>Вычислить комплексное значение полинома</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Комплексное значение полинома в точке</returns>
        </member>
        <member name="M:MathCore.Polynom.GetFunction">
            <summary>Получить функцию полинома</summary>
            <returns>Функция полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.GetComplexFunction">
            <summary>Получить комплексную функцию полинома</summary>
            <returns>Комплексная функция полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.DivideTo(MathCore.Polynom,MathCore.Polynom@)">
            <summary>Выполнить операцию деления полинома на полином</summary>
            <param name="Divisor">Полином - делимое</param>
            <param name="Remainder">Полином - делитель</param>
            <returns>Полином - частное</returns>
        </member>
        <member name="M:MathCore.Polynom.ToMathString">
            <summary>Представить полином в виде математической записи в степенной форме</summary>
            <returns>Строковое представление полинома в степенной форме</returns>
        </member>
        <member name="M:MathCore.Polynom.GetDifferential(System.Int32)">
            <summary>Дифференцирование полинома</summary>
            <param name="Order">Порядок дифференциала</param>
            <returns>Полином - результат дифференцирования</returns>
        </member>
        <member name="M:MathCore.Polynom.GetIntegral(System.Double)">
            <summary>Интегрирование полинома</summary>
            <param name="C">Константа интегрирования</param>
            <returns>Полином - результат интегрирования полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.GetInversed">
            <summary>Вычислить обратный полином</summary>
            <returns>Полином, являющийся обратным к текущим</returns>
        </member>
        <member name="M:MathCore.Polynom.ScalePolynom(System.Double)">
            <summary>Масштабирование полинома</summary>
            <param name="c">Коэффициент масштабирования полинома</param>
            <returns>Отмасштабированный полином</returns>
        </member>
        <member name="M:MathCore.Polynom.Substitute(MathCore.Polynom)">
            <summary>Подстановка полинома x' = P(x) в полином Q(x')=Q(P(x))</summary>
            <param name="P">Полином - подстановка</param>
            <returns>Полином - результат подстановки</returns>
        </member>
        <member name="M:MathCore.Polynom.Equals(MathCore.Polynom)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Polynom.Clone">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Polynom.System#ICloneable#Clone">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Polynom.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Polynom.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Polynom.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Polynom.System#Collections#Generic#IEnumerable{System#Double}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Polynom.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Polynom.ToString(System.String)">
            <summary>Строковое представление полинома с форматированием</summary>
            <param name="Format">Строка форматирования</param>
            <returns>Форматированное представление полинома</returns>
        </member>
        <member name="T:MathCore.Polynom.Expression">
            <summary>Класс операций над полиномом, связанных с деревьями выражений</summary>
        </member>
        <member name="M:MathCore.Polynom.Expression.GetExpression(System.Double[])">
            <summary>Построение дерева выражения на основе коэффициентов полинома</summary>
            <param name="A">Коэффициенты полинома</param>
            <returns>Дерево выражения, представляющее собой метод вычисления значения полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.Expression.GetExpressionComplex(System.Double[])">
            <summary>Построение дерева комплексного выражения на основе коэффициентов полинома</summary>
            <param name="A">Коэффициенты полинома</param>
            <returns>Дерево выражения, представляющее собой метод вычисления комплексного значения полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.Expression.GetExpression(MathCore.Complex[])">
            <summary>Построение дерева комплексного выражения на основе комплексных коэффициентов полинома</summary>
            <param name="A">Комплексные коэффициенты полинома</param>
            <returns>Дерево выражения, представляющее собой метод вычисления комплексного значения полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.GetExpression">
            <summary>Получение дерева выражения полинома</summary>
            <returns>Дерево выражения полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.GetExpressionComplex">
            <summary>Получение дерева выражения полинома</summary>
            <returns>Дерево выражения полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.op_Implicit(MathCore.Polynom)~System.Func{System.Double,System.Double}">
            <summary>Явное приведение типов полинома к делегату функции преобразования double->double</summary>
            <param name="P">Полином</param>
            <returns>Делегат функции преобразования</returns>
        </member>
        <member name="M:MathCore.Polynom.op_Implicit(MathCore.Polynom)~System.Func{MathCore.Complex,MathCore.Complex}">
            <summary>Явное приведение типов полинома к делегату комплексной функции преобразования Complex->Complex</summary>
            <param name="P">Полином</param>
            <returns>Делегат комплексной функции преобразования</returns>
        </member>
        <member name="M:MathCore.Polynom.op_Addition(MathCore.Polynom,MathCore.Polynom)">
            <summary>Оператор сложения двух полиномов</summary>
            <param name="P">Первое слагаемое</param>
            <param name="Q">Второе слагаемое</param>
            <returns>Сумма полиномов</returns>
        </member>
        <member name="M:MathCore.Polynom.op_UnaryNegation(MathCore.Polynom)">
            <summary>
            Оператор отрицания полинома (изменяет знак всех коэффициентов на обратной). Эквивалентно умножению полинома на -1
            </summary>
            <param name="P">Отрицаемый полином</param>
            <returns>Полином Q = -P</returns>
        </member>
        <member name="M:MathCore.Polynom.op_Subtraction(MathCore.Polynom,MathCore.Polynom)">
            <summary>Оператор вычитания полинома Q из полинома P</summary>
            <param name="P">Уменьшаемое</param>
            <param name="Q">Вычитаемое</param>
            <returns>Разность</returns>
        </member>
        <member name="M:MathCore.Polynom.op_Multiply(MathCore.Polynom,MathCore.Polynom)">
            <summary>Оператор произведения полинома Q и полинома P</summary>
            <param name="P">Первый сомножитель</param>
            <param name="Q">Второй сомножитель</param>
            <returns>Произведение полиномов</returns>
        </member>
        <member name="M:MathCore.Polynom.op_Division(MathCore.Polynom,MathCore.Polynom)">
            <summary>Оператор деления двух полиномов</summary>
            <param name="p">Полином делимого</param>
            <param name="q">Полином делителя</param>
            <returns>Результат деления полиномов, включающий частное и остаток от деления</returns>
        </member>
        <member name="M:MathCore.Polynom.op_Multiply(MathCore.Polynom,System.Double)">
            <summary>Умножение полинома на вещественное число</summary>
            <param name="P">Полином</param>
            <param name="q">Вещественное число</param>
            <returns>Полином - результат умножения исходного полинома на вещественное число</returns>
        </member>
        <member name="M:MathCore.Polynom.op_Multiply(System.Double,MathCore.Polynom)">
            <summary>Умножение полинома на вещественное число</summary>
            <param name="p">Вещественное число</param>
            <param name="Q">Полином</param>
            <returns>Полином - результат умножения исходного полинома на вещественное число</returns>
        </member>
        <member name="M:MathCore.Polynom.op_Division(MathCore.Polynom,System.Double)">
            <summary>Деление полинома на вещественное число</summary>
            <param name="P">Полином</param>
            <param name="q">Вещественное число</param>
            <returns>Полином - результат деления исходного полинома на вещественное число</returns>
        </member>
        <member name="M:MathCore.Polynom.op_Explicit(MathCore.Polynom)~System.Double[]">
            <summary>Оператор неявного приведения типа полинома в массив вещественных значений коэффициентов</summary>
            <param name="p">Полином</param>
            <returns>Массив значений коэффициентов</returns>
        </member>
        <member name="M:MathCore.Polynom.op_Implicit(System.Double)~MathCore.Polynom">
            <summary>Оператор приведения типа вещественного числа к типу полинома</summary>
            <param name="a">Вещественное число</param>
        </member>
        <member name="M:MathCore.Polynom.op_Implicit(System.Single)~MathCore.Polynom">
            <summary>Оператор приведения типа вещественного числа к типу полинома</summary>
            <param name="a">Вещественное число</param>
        </member>
        <member name="M:MathCore.Polynom.op_Implicit(System.Int32)~MathCore.Polynom">
            <summary>Оператор приведения типа целого числа к типу полинома</summary>
            <param name="a">Целое число</param>
        </member>
        <member name="M:MathCore.Polynom.op_Implicit(System.Int16)~MathCore.Polynom">
            <summary>Оператор приведения типа целого числа к типу полинома</summary>
            <param name="a">Целое число</param>
        </member>
        <member name="M:MathCore.PrecisionTimer.#ctor">
            <exception cref="T:System.PlatformNotSupportedException">В случае если платформа не Win32NT</exception>
        </member>
        <member name="M:MathCore.PrecisionTimer.Initialize">
            <exception cref="T:System.PlatformNotSupportedException">В случае если платформа не Win32NT</exception>
        </member>
        <member name="T:MathCore.PrimeNumbers">
            <summary>Алгоритмы для Простых чисел</summary>
        </member>
        <member name="M:MathCore.PrimeNumbers.GetNumbersTo(System.Int32)">
            <summary>Поиск простых чисел с использованием алгоритма "Решето Эратосфен"</summary>
            <param name="n">Предельное значение до которого (включительно) осуществляется поиск</param>
            <returns>Перечисление найденных простых чисел</returns>
        </member>
        <member name="T:MathCore.Reflection.AnimatedDoubleProperty`1">
            <summary>Анимация вещественного свойства</summary>
            <typeparam name="TObject">Тип объекта, анимацию свойства которого требуется выполнить</typeparam>
        </member>
        <member name="M:MathCore.Reflection.AnimatedDoubleProperty`1.#ctor(`0,System.String,System.Int32,System.Int32,System.Func{System.Int32,System.Int32,System.Double},System.Boolean)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Reflection.AnimatedDoubleProperty`1"/></summary>
            <param name="o">Объект, свойство которого анимируется</param>
            <param name="Name">Имя анимируемого свойства</param>
            <param name="Samples">Число шагов анимации</param>
            <param name="Timeout">Временной интервал анимации</param>
            <param name="Translator">Функция, вычисляющая очередное значение свойства на основе номера шага анимации и числа шагов</param>
            <param name="Private">Искать приватное свойство?</param>
        </member>
        <member name="T:MathCore.Reflection.AnimatedIntProperty`1">
            <summary>Анимация целочисленного свойства</summary>
            <typeparam name="TObject">Тип объекта, анимацию свойства которого требуется выполнить</typeparam>
        </member>
        <member name="M:MathCore.Reflection.AnimatedIntProperty`1.#ctor(`0,System.String,System.Int32,System.Int32,System.Func{System.Int32,System.Int32,System.Int32},System.Boolean)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Reflection.AnimatedIntProperty`1"/></summary>
            <param name="o">Объект, свойство которого анимируется</param>
            <param name="Name">Имя анимируемого свойства</param>
            <param name="Samples">Число шагов анимации</param>
            <param name="Timeout">Временной интервал анимации</param>
            <param name="Translator">Функция, вычисляющая очередное значение свойства на основе номера шага анимации и числа шагов</param>
            <param name="Private">Искать приватное свойство?</param>
        </member>
        <member name="T:MathCore.Reflection.AnimatedProperty`2">
            <summary>Анимированное свойство</summary>
            <typeparam name="TObject">Тип объекта, свойство которого требуется анимировать</typeparam>
            <typeparam name="TValue">Тип значения анимируемого свойства</typeparam>
        </member>
        <member name="F:MathCore.Reflection.AnimatedProperty`2._Samples">
            <summary>Число шагов анимации</summary>
        </member>
        <member name="F:MathCore.Reflection.AnimatedProperty`2._Timeout">
            <summary>Интервал времени анимации в секундах</summary>
        </member>
        <member name="F:MathCore.Reflection.AnimatedProperty`2._Translator">
            <summary>Функция, вычисляющая очередное значение свойства на основе номера шага анимации и числа шагов</summary>
        </member>
        <member name="F:MathCore.Reflection.AnimatedProperty`2._Enabled">
            <summary>Признак активности анимации</summary>
        </member>
        <member name="F:MathCore.Reflection.AnimatedProperty`2._Thread">
            <summary>поток в котором будет происходить изменение значений свойства</summary>
        </member>
        <member name="F:MathCore.Reflection.AnimatedProperty`2._Priority">
            <summary>Приоритет потока анимации</summary>
        </member>
        <member name="P:MathCore.Reflection.AnimatedProperty`2.Enable">
            <summary>Анимация включена</summary>
        </member>
        <member name="P:MathCore.Reflection.AnimatedProperty`2.Priority">
            <summary>Приоритет потока анимации</summary>
        </member>
        <member name="P:MathCore.Reflection.AnimatedProperty`2.Repeat">
            <summary>Повторять анимацию в цикле?</summary>
        </member>
        <member name="P:MathCore.Reflection.AnimatedProperty`2.AutoReverse">
            <summary>По завершении прямого хода анимации выполнять обратный</summary>
        </member>
        <member name="M:MathCore.Reflection.AnimatedProperty`2.#ctor(`0,System.String,System.Int32,System.Int32,System.Func{System.Int32,System.Int32,`1},System.Boolean)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Reflection.AnimatedIntProperty`1"/></summary>
            <param name="o">Объект, свойство которого анимируется</param>
            <param name="Name">Имя анимируемого свойства</param>
            <param name="Samples">Число шагов анимации</param>
            <param name="Timeout">Временной интервал анимации</param>
            <param name="Translator">Функция, вычисляющая очередное значение свойства на основе номера шага анимации и числа шагов</param>
            <param name="Private">Искать приватное свойство?</param>
        </member>
        <member name="M:MathCore.Reflection.AnimatedProperty`2.Start">
            <summary>Запуск анимации</summary>
        </member>
        <member name="M:MathCore.Reflection.AnimatedProperty`2.Stop">
            <summary>Остановка анимации</summary>
        </member>
        <member name="M:MathCore.Reflection.AnimatedProperty`2.Do">
            <summary>Метод, Выполняющий анимацию свойства</summary>
        </member>
        <member name="T:MathCore.Annotations.CanBeNullAttribute">
            <summary>
            Indicates that the value of the marked element could be <c>null</c> sometimes,
            so the check for <c>null</c> is necessary before its usage
            </summary>
            <example><code>
            [CanBeNull] public object Test() { return null; }
            public void UseTest() {
              var p = Test();
              var s = p.ToString(); // Warning: Possible 'System.NullReferenceException'
            }
            </code></example>
        </member>
        <member name="T:MathCore.Annotations.NotNullAttribute">
            <summary>
            Indicates that the value of the marked element could never be <c>null</c>
            </summary>
            <example><code>
            [NotNull] public object Foo() {
              return null; // Warning: Possible 'null' assignment
            }
            </code></example>
        </member>
        <member name="T:MathCore.Annotations.ItemNotNullAttribute">
            <summary>
            Can be applied to symbols of types derived from IEnumerable as well as to symbols of Task
            and Lazy classes to indicate that the value of a collection item, of the Task.Result property
            or of the Lazy.Value property can never be null.
            </summary>
            <example><code>
            public void Foo([ItemNotNull]List&lt;string&gt; books)
            {
              foreach (var book in books) {
                if (book != null) // Warning: Expression is always true
                 Console.WriteLine(book.ToUpper());
              }
            }
            </code></example>
        </member>
        <member name="T:MathCore.Annotations.ItemCanBeNullAttribute">
            <summary>
            Can be applied to symbols of types derived from IEnumerable as well as to symbols of Task
            and Lazy classes to indicate that the value of a collection item, of the Task.Result property
            or of the Lazy.Value property can be null.
            </summary>
            <example><code>
            public void Foo([ItemCanBeNull]List&lt;string&gt; books)
            {
              foreach (var book in books)
              {
                // Warning: Possible 'System.NullReferenceException'
                Console.WriteLine(book.ToUpper());
              }
            }
            </code></example>
        </member>
        <member name="T:MathCore.Annotations.StringFormatMethodAttribute">
            <summary>
            Indicates that the marked method builds string by format pattern and (optional) arguments.
            Parameter, which contains format string, should be given in constructor. The format string
            should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>-like form
            </summary>
            <example><code>
            [StringFormatMethod("message")]
            public void ShowError(string message, params object[] args) { /* do something */ }
            public void Foo() {
              ShowError("Failed: {0}"); // Warning: Non-existing argument in format string
            }
            </code></example>
        </member>
        <member name="M:MathCore.Annotations.StringFormatMethodAttribute.#ctor(System.String)">
            <param name="formatParameterName">
            Specifies which parameter of an annotated method should be treated as format-string
            </param>
        </member>
        <member name="T:MathCore.Annotations.InvokerParameterNameAttribute">
            <summary>
            Indicates that the function argument should be string literal and match one
            of the parameters of the caller function. For example, ReSharper annotates
            the parameter of <see cref="T:System.ArgumentNullException"/>
            </summary>
            <example><code>
            public void Foo(string param) {
              if (param is null)
                throw new ArgumentNullException("par"); // Warning: Cannot resolve symbol
            }
            </code></example>
        </member>
        <member name="T:MathCore.Annotations.NotifyPropertyChangedInvocatorAttribute">
             <summary>
             Indicates that the method is contained in a type that implements
             <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> interface
             and this method is used to notify that some property value changed
             </summary>
             <remarks>
             The method should be non-static and conform to one of the supported signatures:
             <list>
             <item><c>NotifyChanged(string)</c></item>
             <item><c>NotifyChanged(params string[])</c></item>
             <item><c>NotifyChanged{T}(Expression{Func{T}})</c></item>
             <item><c>NotifyChanged{T,U}(Expression{Func{T,U}})</c></item>
             <item><c>SetProperty{T}(ref T, T, string)</c></item>
             </list>
             </remarks>
             <example><code>
             public class Foo : INotifyPropertyChanged {
               public event PropertyChangedEventHandler PropertyChanged;
               [NotifyPropertyChangedInvocator]
               protected virtual void NotifyChanged(string propertyName) { ... }
            
               private string _name;
               public string Name {
                 get { return _name; }
                 set { _name = value; NotifyChanged("LastName"); /* Warning */ }
               }
             }
             </code>
             Examples of generated notifications:
             <list>
             <item><c>NotifyChanged("Property")</c></item>
             <item><c>NotifyChanged(() =&gt; Property)</c></item>
             <item><c>NotifyChanged((VM x) =&gt; x.Property)</c></item>
             <item><c>SetProperty(ref myField, value, "Property")</c></item>
             </list>
             </example>
        </member>
        <member name="T:MathCore.Annotations.ContractAnnotationAttribute">
            <summary>
            Describes dependency between method input and output
            </summary>
            <syntax>
            <p>Function Definition Table syntax:</p>
            <list>
            <item>FDT      ::= FDTRow [;FDTRow]*</item>
            <item>FDTRow   ::= Input =&gt; Output | Output &lt;= Input</item>
            <item>Input    ::= ParameterName: Value [, Input]*</item>
            <item>Output   ::= [ParameterName: Value]* {halt|stop|void|nothing|Value}</item>
            <item>Value    ::= true | false | null | notnull | canbenull</item>
            </list>
            If method has single input parameter, it's name could be omitted.<br/>
            Using <c>halt</c> (or <c>void</c>/<c>nothing</c>, which is the same)
            for method output means that the methos doesn't return normally.<br/>
            <c>canbenull</c> annotation is only applicable for output parameters.<br/>
            You can use multiple <c>[ContractAnnotation]</c> for each FDT row,
            or use single attribute with rows separated by semicolon.<br/>
            </syntax>
            <examples><list>
            <item><code>
            [ContractAnnotation("=> halt")]
            public void TerminationMethod()
            </code></item>
            <item><code>
            [ContractAnnotation("halt &lt;= condition: false")]
            public void Assert(bool condition, string text) // regular assertion method
            </code></item>
            <item><code>
            [ContractAnnotation("s:null => true")]
            public bool IsNullOrEmpty(string s) // string.IsNullOrEmpty()
            </code></item>
            <item><code>
            // A method that returns null if the parameter is null, and not null if the parameter is not null
            [ContractAnnotation("null => null; notnull => notnull")]
            public object Transform(object data) 
            </code></item>
            <item><code>
            [ContractAnnotation("s:null=>false; =>true,result:notnull; =>false, result:null")]
            public bool TryParse(string s, out Person result)
            </code></item>
            </list></examples>
        </member>
        <member name="T:MathCore.Annotations.LocalizationRequiredAttribute">
            <summary>
            Indicates that marked element should be localized or not
            </summary>
            <example><code>
            [LocalizationRequiredAttribute(true)]
            public class Foo {
              private string str = "my string"; // Warning: Localizable string
            }
            </code></example>
        </member>
        <member name="T:MathCore.Annotations.CannotApplyEqualityOperatorAttribute">
            <summary>
            Indicates that the value of the marked type (or its derivatives)
            cannot be compared using '==' or '!=' operators and <c>Equals()</c>
            should be used instead. However, using '==' or '!=' for comparison
            with <c>null</c> is always permitted.
            </summary>
            <example><code>
            [CannotApplyEqualityOperator]
            class NoEquality { }
            class UsesNoEquality {
              public void Test() {
                var ca1 = new NoEquality();
                var ca2 = new NoEquality();
                if (ca1 != null) { // OK
                  bool condition = ca1 == ca2; // Warning
                }
              }
            }
            </code></example>
        </member>
        <member name="T:MathCore.Annotations.BaseTypeRequiredAttribute">
            <summary>
            When applied to a target attribute, specifies a requirement for any type marked
            with the target attribute to implement or inherit specific type or types.
            </summary>
            <example><code>
            [BaseTypeRequired(typeof(IComponent)] // Specify requirement
            public class ComponentAttribute : Attribute { }
            [Component] // ComponentAttribute requires implementing IComponent interface
            public class MyComponent : IComponent { }
            </code></example>
        </member>
        <member name="T:MathCore.Annotations.UsedImplicitlyAttribute">
            <summary>
            Indicates that the marked symbol is used implicitly
            (e.g. via reflection, in external library), so this symbol
            will not be marked as unused (as well as by other usage inspections)
            </summary>
        </member>
        <member name="T:MathCore.Annotations.MeansImplicitUseAttribute">
            <summary>
            Should be used on attributes and causes ReSharper
            to not mark symbols marked with such attributes as unused
            (as well as by other usage inspections)
            </summary>
        </member>
        <member name="F:MathCore.Annotations.ImplicitUseKindFlags.Access">
            <summary>Only entity marked with attribute considered used</summary>
        </member>
        <member name="F:MathCore.Annotations.ImplicitUseKindFlags.Assign">
            <summary>Indicates implicit assignment to a member</summary>
        </member>
        <member name="F:MathCore.Annotations.ImplicitUseKindFlags.InstantiatedWithFixedConstructorSignature">
            <summary>
            Indicates implicit instantiation of a type with fixed constructor signature.
            That means any unused constructor parameters won't be reported as such.
            </summary>
        </member>
        <member name="F:MathCore.Annotations.ImplicitUseKindFlags.InstantiatedNoFixedConstructorSignature">
            <summary>Indicates implicit instantiation of a type</summary>
        </member>
        <member name="T:MathCore.Annotations.ImplicitUseTargetFlags">
            <summary>
            Specify what is considered used implicitly
            when marked with <see cref="T:MathCore.Annotations.MeansImplicitUseAttribute"/>
            or <see cref="T:MathCore.Annotations.UsedImplicitlyAttribute"/>
            </summary>
        </member>
        <member name="F:MathCore.Annotations.ImplicitUseTargetFlags.Members">
            <summary>Members of entity marked with attribute are considered used</summary>
        </member>
        <member name="F:MathCore.Annotations.ImplicitUseTargetFlags.WithMembers">
            <summary>Entity marked with attribute and all its members considered used</summary>
        </member>
        <member name="T:MathCore.Annotations.PublicAPIAttribute">
            <summary>
            This attribute is intended to mark publicly available API
            which should not be removed and so is treated as used
            </summary>
        </member>
        <member name="T:MathCore.Annotations.InstantHandleAttribute">
            <summary>
            Tells code analysis engine if the parameter is completely handled
            when the invoked method is on stack. If the parameter is a delegate,
            indicates that delegate is executed while the method is executed.
            If the parameter is an enumerable, indicates that it is enumerated
            while the method is executed
            </summary>
        </member>
        <member name="T:MathCore.Annotations.PathReferenceAttribute">
            <summary>
            Indicates that a parameter is a path to a file or a folder
            within a web project. Path can be relative or absolute,
            starting from web root (~)
            </summary>
        </member>
        <member name="T:MathCore.Annotations.AspMvcActionAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC action. If applied to a method, the MVC action name is calculated
            implicitly from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:MathCore.Annotations.AspMvcAreaAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC area.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:MathCore.Annotations.AspMvcControllerAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that
            the parameter is an MVC controller. If applied to a method,
            the MVC controller name is calculated implicitly from the context.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String, String)</c>
            </summary>
        </member>
        <member name="T:MathCore.Annotations.AspMvcMasterAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC Master.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(String, String)</c>
            </summary>
        </member>
        <member name="T:MathCore.Annotations.AspMvcModelTypeAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC model type.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(String, Object)</c>
            </summary>
        </member>
        <member name="T:MathCore.Annotations.AspMvcPartialViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that
            the parameter is an MVC partial view. If applied to a method,
            the MVC partial view name is calculated implicitly from the context.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.RenderPartialExtensions.RenderPartial(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:MathCore.Annotations.AspMvcPressuresViewErrorAttribute">
            <summary>
            ASP.NET MVC attribute. Allows disabling all inspections
            for MVC views within a class or a method.
            </summary>
        </member>
        <member name="T:MathCore.Annotations.AspMvcDisplayTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC display template.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.Mvc.Html.DisplayExtensions.DisplayForModel(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:MathCore.Annotations.AspMvcEditorTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC editor template.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.EditorExtensions.EditorForModel(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:MathCore.Annotations.AspMvcTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC template.
            Use this attribute for custom wrappers similar to
            <c>System.ComponentModel.DataAnnotations.UIHintAttribute(System.String)</c>
            </summary>
        </member>
        <member name="T:MathCore.Annotations.AspMvcViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view. If applied to a method, the MVC view name is calculated implicitly
            from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(Object)</c>
            </summary>
        </member>
        <member name="T:MathCore.Annotations.AspMvcActionSelectorAttribute">
            <summary>
            ASP.NET MVC attribute. When applied to a parameter of an attribute,
            indicates that this parameter is an MVC action name
            </summary>
            <example><code>
            [ActionName("Foo")]
            public ActionResult Login(string returnUrl) {
              ViewBag.ReturnUrl = Url.Action("Foo"); // OK
              return RedirectToAction("Bar"); // Error: Cannot resolve action
            }
            </code></example>
        </member>
        <member name="T:MathCore.Annotations.RazorSectionAttribute">
            <summary>
            Razor attribute. Indicates that a parameter or a method is a Razor section.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.WebPages.WebPageBase.RenderSection(String)</c>
            </summary>
        </member>
        <member name="T:MathCore.SpecialFunctions.Bessel">
            <summary>Класс функций Бесселя</summary>
        </member>
        <member name="M:MathCore.SpecialFunctions.Bessel.J0(System.Double)">
            <summary>Функция Бесселя 0 порядка</summary>
            <param name="x">Аргумент</param>
            <returns>Значение функции Бесселя нулевого порядка</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.Bessel.J1(System.Double)">
            <summary>Функция Бесселя 1 порядка</summary>
            <param name="x">Аргумент функции</param>
            <returns>Значение функции Бесселя первого порядка</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.Bessel.Jn(System.Int32,System.Double)">
            <summary>Функция Бесселя n порядка</summary>
            <param name="n">Порядок функции Бесселя</param>
            <param name="x">Аргумент Функции Бесселя</param>
            <returns>Значение функции Бесселя n порядка</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.Bessel.Y0(System.Double)">
            <summary>Функция Бесселя второго типа, нулевого порядка</summary>
            <param name="x">Аргумент функции Бесселя второго типа, нулевого порядка</param>
            <returns>Значение функции Бесселя второго типа, нулевого порядка</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.Bessel.Y1(System.Double)">
            <summary>Функция Бесселя второго типа, первого порядка</summary>
            <param name="x">Аргумент функции Бесселя второго типа, первого порядка</param>
            <returns>Значение функции Бесселя второго типа, первого порядка</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.Bessel.Yn(System.Int32,System.Double)">
            <summary>Функция Бесселя второго типа, n порядка</summary>
            <param name="n">Порядок функции Бесселя второго типа</param>
            <param name="x">Аргумент функции Бесселя второго типа, n порядка</param>
            <returns>Значение функции Бесселя второго типа, n порядка</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.Bessel.I0(System.Double)">
            <summary>Модифицированная функция Бесселя нулевого порядка </summary>
            <param name="x">Аргумент модифицированной функции Бесселя нулевого порядка</param>
            <returns>Значение модифицированной функции Бесселя нулевого порядка</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.Bessel.I1(System.Double)">
            <summary>Модифицированная функция Бесселя первого порядка </summary>
            <param name="x">Аргумент модифицированной функции Бесселя первого порядка</param>
            <returns>Значение модифицированной функции Бесселя первого порядка</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.Bessel.K0(System.Double)">
            <summary>Модифицированная функция Бесселя второго типа, нулевого порядка </summary>
            <param name="x">Аргумент модифицированной функции Бесселя второго типа, нулевого порядка</param>
            <returns>Значение модифицированной функции Бесселя второго типа, нулевого порядка</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.Bessel.K1(System.Double)">
            <summary>Модифицированная функция Бесселя второго типа, первого порядка </summary>
            <param name="x">Аргумент модифицированной функции Бесселя второго типа, первого порядка</param>
            <returns>Значение модифицированной функции Бесселя второго типа, первого порядка</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">x меньше 0</exception>
        </member>
        <member name="M:MathCore.SpecialFunctions.Bessel.Kn(System.Int32,System.Double)">
            <summary>Модифицированная функция Бесселя второго типа, n порядка </summary>
            <param name="n">Порядок модифицированной функции Бесселя второго типа</param>
            <param name="x">Аргумент модифицированной функции Бесселя второго типа, n порядка</param>
            <returns>Значение модифицированной функции Бесселя второго типа, n порядка</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">при x меньше, либо = 0</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">|n| больше 31</exception>
            <exception cref="T:System.OverflowException"></exception>
        </member>
        <member name="F:MathCore.SpecialFunctions.Eps">
            <summary>Точность алгоритмов 5e-16</summary>
        </member>
        <member name="M:MathCore.SpecialFunctions.BinomialCoefficient(System.Int32,System.Int32)">
            <summary>Биномиальный коэффициент</summary>
            <param name="n">Показатель степени бинома</param>
            <param name="k">Индекс коэффициента</param>
            <returns>Биномиальный коэффициент (n, k)</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.KroneckerDelta(System.Int32,System.Int32)">
            <summary>Символ Кронекера δ(i,j) = 1 - если i = j, и = 0 - если i ≠ j</summary>
            <param name="i">Индекс</param><param name="j">Индекс</param>
            <returns>1 - если i = j, и = 0 - если i ≠ j</returns>
        </member>
        <member name="T:MathCore.SpecialFunctions.Distribution.Normal">
            <summary>Нормальное распределение</summary>
        </member>
        <member name="M:MathCore.SpecialFunctions.Distribution.Normal.ErrorFunction(System.Double)">
            <summary>Интеграл от exp{-t^2} от нуля до x / .5 sqrt(pi)</summary>
            <param name="x">Аргумент функции нормального распределения</param>
            <returns>Значение нормального распределения</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.Distribution.Student.QuantileHi2(System.Double,System.Int32)">
            <summary>Квантиль Хи-квадрат</summary>
             /// <param name="alpha">Квантиль [0..1]</param>
            <param name="n">Число степеней свободы</param>
            <returns>Квантиль</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.Distribution.Student.QuantileHi2Approximation(System.Double,System.Int32)">
            <summary>Квантиль Хи-квадрат (Аппроксимация Корниша-Фишера)</summary>
            <remarks>http://ru.wikipedia.org/wiki/Квантили_распределения_хи-квадрат</remarks>
            <remarks>https://projecteuclid.org/download/pdf_1/euclid.aoms/1177730982</remarks>
            <param name="alpha">Квантиль [0..1]</param>
            <param name="n">Число степеней свободы</param>
            <returns>Квантиль</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.EllipticJacobi.FullEllipticIntegral(System.Double)">
            <summary>Полный эллиптический интеграл</summary>
            <param name="k">Параметр интегрирования от 0 до 1</param>
            <returns></returns>
        </member>
        <member name="T:MathCore.SpecialFunctions.Gamma">
            <summary>Гамма-функция</summary>
        </member>
        <member name="T:MathCore.Statistic.Distributions">
            <summary>Распределения</summary>
        </member>
        <member name="M:MathCore.Statistic.Distributions.Hi2(System.Int32,System.Double)">
            <summary>Распределение Хи-квадрат</summary>
            <param name="k">Число степеней свободы</param>
            <param name="x">Аргумент</param>
            <returns>Значение плотности вероятности</returns>
        </member>
        <member name="M:MathCore.Statistic.Distributions.Uniform(System.Double,System.Double)">
            <summary>Равномерное распределение</summary>
            <param name="a">Минимальное значение</param>
            <param name="b">Максимальное значение</param>
            <returns>Функция равномерного распределения в заданном интервале</returns>
        </member>
        <member name="M:MathCore.Statistic.Distributions.Uniform(System.Double,System.Double,System.Double)">
            <summary>Равномерное распределение</summary>
            <param name="x">Аргумент</param>
            <param name="a">Минимальное значение</param>
            <param name="b">Максимальное значение</param>
            <returns>Значение равномерного распределения в заданной точке</returns>
        </member>
        <member name="M:MathCore.Statistic.Distributions.Rayleigh(System.Double)">
            <summary>Распределение Рэлея http://ru.wikipedia.org/wiki/Распределение_Рэлея</summary>
            <param name="sigma">Параметр масштаба</param>
            <returns>Функция распределения для заданного масштаба</returns>
        </member>
        <member name="M:MathCore.Statistic.Distributions.Rayleigh(System.Double,System.Double)">
            <summary>Распределение Рэлея http://ru.wikipedia.org/wiki/Распределение_Рэлея</summary>
            <param name="x">Аргумент</param>
            <param name="sigma">Параметр масштаба</param>
            <returns>Значение распределения</returns>
        </member>
        <member name="T:MathCore.Statistic.Histogram">
            <summary>Гистограмма</summary>
        </member>
        <member name="F:MathCore.Statistic.RandomNumbers.PolyformRandomGenerator.__Normal_A">
            <summary>area under rectangle</summary>
        </member>
        <member name="F:MathCore.Statistic.RandomNumbers.PolyformRandomGenerator.A">
            <summary>area under rectangle</summary>
        </member>
        <member name="M:MathCore.Statistic.RandomNumbers.PolyformRandomGenerator.Cauchy(System.Double,System.Double)">
            <summary>Случайная величина с распределением Коши</summary>
            <param name="x0"></param>
            <param name="gamma"></param>
            <returns></returns>
        </member>
        <member name="T:MathCore.Statistic.RandomNumbers.RandomGenerator">
            <summary>Генератор случайных чисел</summary>
        </member>
        <member name="F:MathCore.Statistic.RandomNumbers.RandomGenerator.SystemRandomGenerator">
            <summary>Датчик случайных чисел с равномерным распределением</summary>
        </member>
        <member name="F:MathCore.Statistic.RandomNumbers.RandomGenerator._Sigma">
            <summary>Дисперсия</summary>
        </member>
        <member name="F:MathCore.Statistic.RandomNumbers.RandomGenerator._Mu">
            <summary>Математическое ожидание</summary>
        </member>
        <member name="P:MathCore.Statistic.RandomNumbers.RandomGenerator.Sigma">
            <summary>Дисперсия</summary>
        </member>
        <member name="P:MathCore.Statistic.RandomNumbers.RandomGenerator.Mu">
            <summary>Математическое ожидание</summary>
        </member>
        <member name="P:MathCore.Statistic.RandomNumbers.RandomGenerator.Value">
            <summary>Случайное значение</summary>
        </member>
        <member name="M:MathCore.Statistic.RandomNumbers.RandomGenerator.GetValue">
            <summary>Новое случайное число</summary><returns>Случайное число</returns>
        </member>
        <member name="T:MathCore.Statistic.RandomNumbers.UniformRandomGenerator">
            <summary>Генератор случайных чисел с равномерным распределением</summary>
        </member>
        <member name="T:MathCore.Threading.MaxConcurrencySynchronizationContext">
            <summary>Контекст синхронизации с максимально допустимой степенью параллелизма</summary>
        </member>
        <member name="F:MathCore.Threading.MaxConcurrencySynchronizationContext._Semaphore">
            <summary>Семафор, ограничивающий число выполняемых задач</summary>
        </member>
        <member name="M:MathCore.Threading.MaxConcurrencySynchronizationContext.#ctor(System.Int32)">
            <summary>Инициализация нового контекста синхронизации с ограничением числа параллельно выполняемых задач</summary>
            <param name="MaxConcurrencyLevel">Максимальное число выполняемых в контексте задач</param>
        </member>
        <member name="M:MathCore.Threading.MaxConcurrencySynchronizationContext.OnSemaphoreReleased(System.Threading.Tasks.Task,System.Object)">
            <summary>Метод, вызываемый при освобождении семафора</summary>
            <param name="SemaphoreWaitTask">Задача ожидания освобождения семафора</param>
            <param name="CallState">Массив с параметрами продолжения, хранящий в первом параметре делегат, который надо вызвать, а во втором - параметр вызова делегата</param>
        </member>
        <member name="M:MathCore.Threading.MaxConcurrencySynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Threading.MaxConcurrencySynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.TimeInterval">
            <summary>Интервальный предикат</summary>
        </member>
        <member name="F:MathCore.TimeInterval._MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="F:MathCore.TimeInterval._MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="F:MathCore.TimeInterval._Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="F:MathCore.TimeInterval._Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="P:MathCore.TimeInterval.MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="P:MathCore.TimeInterval.MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="P:MathCore.TimeInterval.Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="P:MathCore.TimeInterval.Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="P:MathCore.TimeInterval.Length">
            <summary>Протяжённость интервала</summary>
        </member>
        <member name="M:MathCore.TimeInterval.#ctor(System.TimeSpan)">
            <summary>Интервал</summary>
            <param name="Max">Верхняя граница интервала</param>
        </member>
        <member name="M:MathCore.TimeInterval.#ctor(System.TimeSpan,System.TimeSpan)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верхняя граница интервала</param>
        </member>
        <member name="M:MathCore.TimeInterval.#ctor(System.TimeSpan,System.TimeSpan,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="IncludeLimits">Включать пределы?</param>
        </member>
        <member name="M:MathCore.TimeInterval.#ctor(System.TimeSpan,System.Boolean,System.TimeSpan,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="MinInclude">Включена ли нижняя граница интервала?</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="MaxInclude">Включена ли верхняя граница интервала</param>
        </member>
        <member name="M:MathCore.TimeInterval.Check(System.TimeSpan)">
            <summary>Проверка на вхождение в интервал</summary>
            <param name="X">Проверяемая величина</param>
            <returns>Истина, если величина входит в интервал</returns>
        </member>
        <member name="M:MathCore.TimeInterval.IsInclude(MathCore.TimeInterval)">
            <summary>
            Проверка вхождения интервала в интервал
            </summary>
            <param name="I">Проверяемый интервал</param>
            <returns>Истина, если проверяемый интервал входит</returns>
        </member>
        <member name="M:MathCore.TimeInterval.op_Implicit(MathCore.TimeInterval)~System.Predicate{System.TimeSpan}">
            <summary>Оператор неявного приведения типа к предикату</summary>
            <param name="I">Интервал</param>
            <returns>Предикат от вещественного типа двойной точности</returns>
        </member>
        <member name="M:MathCore.TimeInterval.op_ExclusiveOr(System.TimeSpan,MathCore.TimeInterval)">
            <summary>Оператор проверки на вхождение величины в интервал</summary>
            <param name="x">Проверяемая величина</param>
            <param name="I">Интервал</param>
            <returns>Истина, если величина внутри интервала</returns>
        </member>
        <member name="M:MathCore.TimeInterval.op_ExclusiveOr(MathCore.TimeInterval,System.TimeSpan)">
            <summary>Оператор проверки на вхождение величины в интервал</summary>
            <param name="X">Проверяемая величина</param>
            <param name="I">Интервал</param>
            <returns>Истина, если величина внутри интервала</returns>
        </member>
        <member name="T:MathCore.DateTimeInterval">
            <summary>Интервальный предикат</summary>
        </member>
        <member name="F:MathCore.DateTimeInterval._MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="F:MathCore.DateTimeInterval._MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="F:MathCore.DateTimeInterval._Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="F:MathCore.DateTimeInterval._Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="P:MathCore.DateTimeInterval.MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="P:MathCore.DateTimeInterval.MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="P:MathCore.DateTimeInterval.Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="P:MathCore.DateTimeInterval.Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="P:MathCore.DateTimeInterval.Length">
            <summary>Протяжённость интервала</summary>
        </member>
        <member name="M:MathCore.DateTimeInterval.#ctor(System.DateTime)">
            <summary>Интервал</summary>
            <param name="Max">Верхняя граница интервала</param>
        </member>
        <member name="M:MathCore.DateTimeInterval.#ctor(System.DateTime,System.DateTime)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верхняя граница интервала</param>
        </member>
        <member name="M:MathCore.DateTimeInterval.#ctor(System.DateTime,System.DateTime,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="IncludeLimits">Включать пределы?</param>
        </member>
        <member name="M:MathCore.DateTimeInterval.#ctor(System.DateTime,System.Boolean,System.DateTime)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="MinInclude">Включена ли нижняя граница интервала?</param>
            <param name="Max">Верхняя граница интервала</param>
        </member>
        <member name="M:MathCore.DateTimeInterval.#ctor(System.DateTime,System.Boolean,System.DateTime,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="MinInclude">Включена ли нижняя граница интервала?</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="MaxInclude">Включена ли верхняя граница интервала</param>
        </member>
        <member name="M:MathCore.DateTimeInterval.Check(System.DateTime)">
            <summary>Проверка на вхождение в интервал</summary>
            <param name="X">Проверяемая величина</param>
            <returns></returns>
        </member>
        <member name="M:MathCore.DateTimeInterval.op_Implicit(MathCore.DateTimeInterval)~System.Predicate{System.DateTime}">
            <summary>Оператор неявного приведения типа к предикату</summary>
            <param name="I">Интервал</param>
            <returns>Предикат от вещественного типа двойной точности</returns>
        </member>
        <member name="M:MathCore.DateTimeInterval.op_ExclusiveOr(System.DateTime,MathCore.DateTimeInterval)">
            <summary>Оператор проверки на вхождение величины в интервал</summary>
            <param name="x">Проверяемая величина</param>
            <param name="I">Интервал</param>
            <returns>Истина, если величина внутри интервала</returns>
        </member>
        <member name="M:MathCore.DateTimeInterval.op_ExclusiveOr(MathCore.DateTimeInterval,System.DateTime)">
            <summary>Оператор проверки на вхождение величины в интервал</summary>
            <param name="X">Проверяемая величина</param>
            <param name="I">Интервал</param>
            <returns>Истина, если величина внутри интервала</returns>
        </member>
        <member name="T:MathCore.TimeoutEvent`1">
            <summary>Класс задержки реакции на событие</summary>
            <typeparam name="TEventArgs">Тип аргумента события</typeparam>
        </member>
        <member name="M:MathCore.TimeoutEvent`1.Subscribe(System.Int32,System.EventHandler{`0},System.EventHandler{`0})">
            <summary>Метод подписки на событие</summary>
            <param name="Timeout">Таймаут</param>
            <param name="OnTimeout">Метод обработки первичного вызова события</param>
            <param name="OnInvoke">Метод обработки вторичного события</param>
            <returns>Обработчик исходного события</returns>
        </member>
        <member name="F:MathCore.TimeoutEvent`1.__Infinite">
            <summary>Константа бесконечного периода ожидания</summary>
        </member>
        <member name="T:MathCore.TimeoutEvent`1.Info">
            <summary>Аргумент события</summary>
        </member>
        <member name="P:MathCore.TimeoutEvent`1.Info.EventSender">
            <summary>Источник сходного события</summary>
        </member>
        <member name="P:MathCore.TimeoutEvent`1.Info.E">
            <summary>Аргумент исходного события</summary>
        </member>
        <member name="M:MathCore.TimeoutEvent`1.Info.#ctor(System.Object,`0)">
            <summary>Аргумент события</summary>
            <param name="EventSender">Источник исходного события</param>
            <param name="e">Аргумент исходного события</param>
        </member>
        <member name="E:MathCore.TimeoutEvent`1.Invoked">
            <summary>Первичная генерация события</summary>
        </member>
        <member name="M:MathCore.TimeoutEvent`1.OnInvoked(MathCore.TimeoutEvent{`0}.Info)">
            <summary>Метод первичной генерации события <see cref="E:MathCore.TimeoutEvent`1.Invoked"/></summary>
            <param name="e">Аргумент первичного вызова события</param>
        </member>
        <member name="E:MathCore.TimeoutEvent`1.AfterTimeout">
            <summary>Событие, возникающее после последнего вызова метода <see cref="M:MathCore.TimeoutEvent`1.Invoke(System.Object,`0)"/> через период времени <see cref="P:MathCore.TimeoutEvent`1.Timeout"/></summary>
        </member>
        <member name="M:MathCore.TimeoutEvent`1.OnAfterTimeout(MathCore.TimeoutEvent{`0}.Info)">
            <summary>Метод генерации события <see cref="E:MathCore.TimeoutEvent`1.AfterTimeout"/></summary>
            <param name="e">Аргумент события</param>
        </member>
        <member name="F:MathCore.TimeoutEvent`1._Timer">
            <summary>Таймер</summary>
        </member>
        <member name="F:MathCore.TimeoutEvent`1._Timeout">
            <summary>Период времени таймаута</summary>
        </member>
        <member name="F:MathCore.TimeoutEvent`1._LastCallTime">
            <summary>Время последнего вызова</summary>
        </member>
        <member name="F:MathCore.TimeoutEvent`1._InProcess">
            <summary>Признак ожидания таймаута события</summary>
        </member>
        <member name="F:MathCore.TimeoutEvent`1._LastEventArgs">
            <summary>Аргумент последнего вызова метода <see cref="M:MathCore.TimeoutEvent`1.Invoke(System.Object,`0)"/></summary>
        </member>
        <member name="F:MathCore.TimeoutEvent`1._NeedAbort">
            <summary>Признак ожидания отмены генерации события <see cref="E:MathCore.TimeoutEvent`1.AfterTimeout"/></summary>
        </member>
        <member name="P:MathCore.TimeoutEvent`1.Timeout">
            <summary>Задержка во времени генерации события <see cref="E:MathCore.TimeoutEvent`1.AfterTimeout"/> в миллисекундах</summary>
        </member>
        <member name="P:MathCore.TimeoutEvent`1.LastCallTime">
            <summary>Время последнего вызова метода <see cref="M:MathCore.TimeoutEvent`1.Invoke(System.Object,`0)"/></summary>
        </member>
        <member name="P:MathCore.TimeoutEvent`1.InProcess">
            <summary>Признак ожидания генерации события <see cref="E:MathCore.TimeoutEvent`1.Invoked"/></summary>
        </member>
        <member name="P:MathCore.TimeoutEvent`1.NeedAbort">
            <summary>Признак отмены генерации соития <see cref="E:MathCore.TimeoutEvent`1.AfterTimeout"/></summary>
        </member>
        <member name="M:MathCore.TimeoutEvent`1.#ctor(System.Int32)">
            <summary>Инициализация нового объекта задержки генерации события</summary>
            <param name="Timeout">Временная задержка в миллисекундах</param>
        </member>
        <member name="M:MathCore.TimeoutEvent`1.#ctor(System.Int32,System.EventHandler{`0})">
            <summary>Инициализация нового объекта задержки генерации события</summary>
            <param name="Timeout">Временная задержка в миллисекундах</param>
            <param name="OnTimeout">Метод вторичной обработки события</param>
        </member>
        <member name="M:MathCore.TimeoutEvent`1.#ctor(System.Int32,System.EventHandler{`0},System.EventHandler{`0})">
            <summary>Инициализация нового объекта задержки генерации события</summary>
            <param name="Timeout">Временная задержка в миллисекундах</param>
            <param name="OnTimeout">Метод вторичной обработки события</param>
            <param name="OnInvoke">Метод первичной обработки события</param>
        </member>
        <member name="M:MathCore.TimeoutEvent`1.OnTimer(System.Object)">
            <summary>Метод обработки события таймера</summary>
            <param name="State">Состояние таймера</param>
        </member>
        <member name="M:MathCore.TimeoutEvent`1.Invoke(System.Object,`0)">
            <summary>Метод генерации события</summary>
            <param name="EventSender">Источник события</param>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:MathCore.TimeoutEvent`1.Abort">
            <summary>Отмена реакции на событие</summary>
        </member>
        <member name="T:MathCore.Time.TimeCounter">
            <summary>Измеритель времени</summary>
        </member>
        <member name="F:MathCore.Time.TimeCounter._Started">
            <summary>Флаг состояния</summary>
        </member>
        <member name="F:MathCore.Time.TimeCounter._LockObject">
            <summary>Объект межпотоковой синхронизации</summary>
        </member>
        <member name="P:MathCore.Time.TimeCounter.IsStarted">
            <summary>Состояние измерителя</summary>
        </member>
        <member name="P:MathCore.Time.TimeCounter.TotalTime">
            <summary>Прошло времени</summary>
        </member>
        <member name="M:MathCore.Time.TimeCounter.Start">
            <summary>Запуск</summary>
        </member>
        <member name="M:MathCore.Time.TimeCounter.Stop">
            <summary>Остановка</summary>
        </member>
        <member name="M:MathCore.Time.TimeCounter.Reset">
            <summary>Сброс измерителя</summary>
        </member>
        <member name="T:MathCore.Trees.ITreeItem`1">
            <summary>Элемент двусвязного дерева</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:MathCore.Trees.ITreeItem`1.Parent">
            <summary>Родительский узел</summary>
        </member>
        <member name="P:MathCore.Trees.ITreeItem`1.Child">
            <summary>Дочерний узел</summary>
        </member>
        <member name="P:MathCore.Trees.ITreeItem`1.Prev">
            <summary>Предыдущий узел уровня</summary>
        </member>
        <member name="P:MathCore.Trees.ITreeItem`1.Next">
            <summary>Следующий узел дерева</summary>
        </member>
        <member name="T:MathCore.Trees.ITreeItemEx">
            <summary>Методы-расширения интерфейса элемента двусвязного дерева</summary>
        </member>
        <member name="T:MathCore.Trees.ITreeItemEx.OrderWalkType">
            <summary>Тип обхода узлов дерева</summary>
        </member>
        <member name="F:MathCore.Trees.ITreeItemEx.OrderWalkType.CurrentChildNext">
            <summary>(К-Л-П) Сначала текущий узел в уровне, затем все дочерние узлы текущего, затем следующий узел уровня</summary>
        </member>
        <member name="F:MathCore.Trees.ITreeItemEx.OrderWalkType.CurrentNextChild">
            <summary>(К-П-Л) Сначала текущий узел в уровне, затем все узлы текущего уровня, затем дочерний узел</summary>
        </member>
        <member name="F:MathCore.Trees.ITreeItemEx.OrderWalkType.ChildCurrentNext">
            <summary>(Л-К-П) Сначала дочерние узлы текущего узла, затем текущий узел, потом все оставшиеся узлы текущего уровня</summary>
        </member>
        <member name="F:MathCore.Trees.ITreeItemEx.OrderWalkType.NextCurrentChild">
            <summary>(П-К-Л) Сначала все остальные узлы текущего уровня, затем текущий узел, потом все дочерние узлы текущего узла</summary>
        </member>
        <member name="F:MathCore.Trees.ITreeItemEx.OrderWalkType.ChildNextCurrent">
            <summary>(Л-П-К) Сначала все дочерние узлы текущего узла, затем все узлы текущего уровня, в конце текущий узел</summary>
        </member>
        <member name="F:MathCore.Trees.ITreeItemEx.OrderWalkType.NextChildCurrent">
            <summary>(П-Л-К) Сначала все узлы текущего уровня, затем все дочерние узлы текущего узла, В конце сам текущий узел</summary>
        </member>
        <member name="T:MathCore.Trees.ITreeItemEx.TreeLevelItem`1">
            <summary>Представление узла дерева</summary>
            <typeparam name="T">Тип значения узла</typeparam>
        </member>
        <member name="P:MathCore.Trees.ITreeItemEx.TreeLevelItem`1.Item">
            <summary>Значение узла</summary>
        </member>
        <member name="P:MathCore.Trees.ITreeItemEx.TreeLevelItem`1.Level">
            <summary>Уровень узла в дереве</summary>
        </member>
        <member name="M:MathCore.Trees.ITreeItemEx.TreeLevelItem`1.#ctor(`0,System.Int32)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Trees.ITreeItemEx.TreeLevelItem`1"/></summary>
            <param name="Item">Значение узла</param>
            <param name="Level">Уровень узла</param>
        </member>
        <member name="M:MathCore.Trees.ITreeItemEx.TreeLevelItem`1.Equals(MathCore.Trees.ITreeItemEx.TreeLevelItem{`0})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Trees.ITreeItemEx.TreeLevelItem`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Trees.ITreeItemEx.TreeLevelItem`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Trees.ITreeItemEx.TreeLevelItem`1.op_Equality(MathCore.Trees.ITreeItemEx.TreeLevelItem{`0},MathCore.Trees.ITreeItemEx.TreeLevelItem{`0})">
            <summary>Оператор определения равенства между двумя экземплярам <see cref="T:MathCore.Trees.ITreeItemEx.TreeLevelItem`1"/></summary>
            <returns>Истина, если свойства экземпляров равны</returns>
        </member>
        <member name="M:MathCore.Trees.ITreeItemEx.TreeLevelItem`1.op_Inequality(MathCore.Trees.ITreeItemEx.TreeLevelItem{`0},MathCore.Trees.ITreeItemEx.TreeLevelItem{`0})">
            <summary>Оператор определения неравенства между двумя экземплярам <see cref="T:MathCore.Trees.ITreeItemEx.TreeLevelItem`1"/></summary>
            <returns>Истина, если хотя бы одно свойство экземпляров отличается</returns>
        </member>
        <member name="M:MathCore.Trees.ITreeItemEx.GetRootItem``1(``0)">
            <summary>Определение корня дерева</summary>
            <typeparam name="T">Тип элемента, являющегося классом и определяющего интерфейс элемента дерева</typeparam>
            <param name="Item">Объект с интерфейсом элемента дерева</param>
            <returns>Корневой объект дерева объектов</returns>
        </member>
        <member name="M:MathCore.Trees.ITreeItemEx.OrderWalk``1(``0,MathCore.Trees.ITreeItemEx.OrderWalkType,System.Int32)">
            <summary>Обход элементов поддерева начиная с текущего в порядке: текущий, дочерний, следующий по уровню</summary>
            <typeparam name="T">Тип элемента, являющегося классом и определяющего интерфейс элемента дерева</typeparam>
            <param name="Item">Объект с интерфейсом элемента дерева</param>
            <param name="WalkType">Тип обхода</param>
            <param name="Level">Уровень дерева</param>
            <returns>Последовательность элементов дерева</returns>
        </member>
        <member name="M:MathCore.Trees.ITreeItemEx.GetParents``1(``0)">
            <summary>Получить все родительские элементы</summary>
            <typeparam name="T">Тип элемента, являющегося классом и определяющего интерфейс элемента дерева</typeparam>
            <param name="Item">Объект с интерфейсом элемента дерева</param>
            <returns>Массив элементов родительских узлов дерева</returns>
        </member>
        <member name="M:MathCore.Trees.ITreeItemEx.GetLevelItems``1(``0)">
            <summary>Получить все элементы дочернего уровня поддерева</summary>
            <typeparam name="T">Тип элемента, являющегося классом и определяющего интерфейс элемента дерева</typeparam>
            <param name="Item">Объект с интерфейсом элемента дерева</param>
            <returns>Массив элементов текущего уровня дерева</returns>
        </member>
        <member name="M:MathCore.Trees.ITreeItemEx.GetChilds``1(``0)">
            <summary>Получить все дочерние элементы поддерева</summary>
            <typeparam name="T">Тип элемента, являющегося классом и определяющего интерфейс элемента дерева</typeparam>
            <param name="Item">Объект с интерфейсом элемента дерева</param>
            <returns>Массив элементов дочерних узлов</returns>
        </member>
        <member name="P:MathCore.Trees.Tree`1.Count">
            <summary>Число элементов</summary>
        </member>
        <member name="P:MathCore.Trees.Tree`1.Item(System.Int32)">
            <summary>Индексатор объекта</summary><param name="index">Индекс</param>
        </member>
        <member name="P:MathCore.Trees.Tree`1.MathCore#IIndexable{System#Int32,MathCore#Trees#ITree{T}}#Item(System.Int32)">
            <summary>Индексатор объекта</summary><param name="index">Индекс</param>
        </member>
        <member name="P:MathCore.Trees.Tree`1.MathCore#IIndexableWrite{System#Int32,MathCore#Trees#ITree{T}}#Item(System.Int32)">
            <summary>Индексатор объекта только для записи</summary><param name="index">Индекс</param>
        </member>
        <member name="P:MathCore.Trees.Tree`1.MathCore#IIndexableRead{System#Int32,MathCore#Trees#ITree{T}}#Item(System.Int32)">
            <summary>Индексатор объекта только для чтения</summary>
            <param name="index">Индекс</param>
        </member>
        <member name="M:MathCore.Trees.Tree`1.System#Collections#Generic#IEnumerable{MathCore#Trees#ITree{T}}#GetEnumerator">
            <summary>Возвращает перечислитель, выполняющий перебор элементов в коллекции.</summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.IEnumerator`1"/>, который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:MathCore.Trees.Tree`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Возвращает перечислитель, который осуществляет перебор элементов коллекции.</summary>
            <returns>
            Объект <see cref="T:System.Collections.IEnumerator"/>, который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:MathCore.TypeConverter`2.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.UsingDisposableObject`1">
            <summary>Класс-обёртка для inline-доступа к свойствам созданного объекта, наследующего интерфейс IDisposable</summary>
            <typeparam name="T">Тип используемого объекта, наследующего интерфейс IDisposable</typeparam>
        </member>
        <member name="M:MathCore.UsingDisposableObject`1.#ctor(`0)">
            <summary>Новая обёртка для используемого объекта</summary>
            <param name="Obj">Используемый объект</param>
        </member>
        <member name="M:MathCore.UsingDisposableObject`1.GetValue``1(System.Func{`0,``0})">
            <summary>Получить значение от объекта</summary>
            <typeparam name="TValue">Тип значения, получаемого от объекта</typeparam>
            <param name="f">Метод получения значения</param>
            <returns>Значение, полученное от объекта указанным методом</returns>
        </member>
        <member name="T:MathCore.UsingObject`1">
            <summary>Оболочка, обеспечивающая освобождение ресурсов указанным методом для указанного объекта</summary>
            <typeparam name="T">Тип объекта, с которым работает оболочка</typeparam>
        </member>
        <member name="F:MathCore.UsingObject`1._Obj">
            <summary>Используемый объект</summary>
        </member>
        <member name="F:MathCore.UsingObject`1._Disposer">
            <summary>Метод освобождения ресурсов</summary>
        </member>
        <member name="P:MathCore.UsingObject`1.Object">
            <summary>Используемый объект</summary>
        </member>
        <member name="M:MathCore.UsingObject`1.#ctor(`0,System.Action{`0})">
            <summary>Упаковка объекта в оболочку с указанием метода освобождения ресурсов, занимаемых указанным объектом</summary>
            <param name="obj">Уничтожаемый объект</param>
            <param name="Disposer">Метод освобождения ресурсов</param>
        </member>
        <member name="M:MathCore.UsingObject`1.Dispose">
            <summary>Разрушение обёртки, влекущее разрушение используемого объекта</summary>
        </member>
        <member name="M:MathCore.UsingObject`1.op_Implicit(MathCore.UsingObject{`0})~`0">
            <summary>Оператор неявного приведения типов</summary>
            <param name="obj">Объект-оболочка</param>
            <returns>Внутренний объект</returns>
        </member>
        <member name="T:MathCore.ValuedInterval`1">
            <summary>Интервал вещественных значений двойной точности</summary>
        </member>
        <member name="M:MathCore.ValuedInterval`1.Comparer_Length(MathCore.ValuedInterval{`0},MathCore.ValuedInterval{`0})">
            <summary>Метод сравнения двух интервалов</summary>
            <param name="a">Первый сравниваемый интервал</param>
            <param name="b">Второй сравниваемый интервал</param>
            <returns>1 - если первый интервал больше второго, -1 - если первый интервал меньше второго, 0 - если интервалы равны</returns>
        </member>
        <member name="F:MathCore.ValuedInterval`1._MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="F:MathCore.ValuedInterval`1._MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="F:MathCore.ValuedInterval`1._Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="F:MathCore.ValuedInterval`1._Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="P:MathCore.ValuedInterval`1.MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="P:MathCore.ValuedInterval`1.MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="P:MathCore.ValuedInterval`1.Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="P:MathCore.ValuedInterval`1.Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="P:MathCore.ValuedInterval`1.Length">
            <summary>Длина интервала</summary>
        </member>
        <member name="P:MathCore.ValuedInterval`1.Middle">
            <summary>Середина интервала</summary>
        </member>
        <member name="M:MathCore.ValuedInterval`1.#ctor(System.Double,System.Double,`0)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="Value">Значение</param>
        </member>
        <member name="M:MathCore.ValuedInterval`1.#ctor(System.Double,System.Double,System.Boolean,`0)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="IncludeLimits">Включать пределы?</param>
            <param name="Value">Значение</param>
        </member>
        <member name="M:MathCore.ValuedInterval`1.#ctor(System.Double,System.Boolean,System.Double,System.Boolean,`0)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="MinInclude">Включена ли нижняя граница интервала?</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="MaxInclude">Включена ли верхняя граница интервала</param>
            <param name="Value">Значение</param>
        </member>
        <member name="M:MathCore.ValuedInterval`1.Check(System.Double)">
            <summary>Проверка на вхождение значения в интервал</summary>
            <param name="value">Проверяемое значение</param>
            <returns>Истина, если значение входит в интервал</returns>
        </member>
        <member name="M:MathCore.ValuedInterval`1.ToString(System.String,System.IFormatProvider)">
            <summary>Форматирует значение текущего экземпляра с использованием заданного формата.</summary>
            <returns>Объект <see cref="T:System.String"/> содержит значение текущего экземпляра в заданном формате.</returns>
            <param name="Format">
            Объект <see cref="T:System.String"/>, задающий используемый формат.— или — 
            Значение null для использования формата по умолчанию, определенного для типа реализации 
            <see cref="T:System.IFormattable"/>. 
            </param>
            <param name="FormatProvider">
            Объект <see cref="T:System.IFormatProvider"/>, используемый для форматирования значения.— или — 
            Значение null для получения сведений о форматировании чисел на основе текущего значения параметра языкового 
            стандарта операционной системы. 
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:MathCore.Values.AbstractSetOf`1">
            <summary>Абстрактное множество элементов</summary>
            <typeparam name="T">Тип элементов множества</typeparam>
        </member>
        <member name="P:MathCore.Values.AbstractSetOf`1.Power">
            <summary>Мощность множества</summary>
        </member>
        <member name="M:MathCore.Values.AbstractSetOf`1.Add(`0)">
            <summary>Добавить элемент в множество</summary>
            <param name="Value">Добавляемый элемент</param>
            <returns>Истина, если элемент был добавлен в множество и ложь, если элемент уже присутствует в множестве</returns>
        </member>
        <member name="M:MathCore.Values.AbstractSetOf`1.Contains(`0)">
            <summary>Признак вхождения элемента в множество</summary>
            <param name="value">Проверяемый элемент</param>
            <returns>Истина, если элемент принадлежит множеству</returns>
        </member>
        <member name="M:MathCore.Values.AbstractSetOf`1.NotContains(`0)">
            <summary>Признак того, что элемент не входит в множество</summary>
            <param name="value">Проверяемый элемент</param>
            <returns>Истина, если элемент не принадлежит множеству</returns>
        </member>
        <member name="M:MathCore.Values.AbstractSetOf`1.GetEnumerator">
            <summary>Получить перечислитель множества</summary>
            <returns>Перечислитель множества</returns>
        </member>
        <member name="M:MathCore.Values.AbstractSetOf`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Получить перечислитель множества</summary>
            <returns>Перечислитель множества</returns>
        </member>
        <member name="T:MathCore.Values.AverageValue">
            <summary>Скользящее среднее</summary>
        </member>
        <member name="F:MathCore.Values.AverageValue._N">
            <summary>Номер итерации усреднения</summary>
        </member>
        <member name="F:MathCore.Values.AverageValue._Value">
            <summary>Текущее значение усредняемой величины</summary>
        </member>
        <member name="F:MathCore.Values.AverageValue._StartValue">
            <summary>Начальное значение</summary>
        </member>
        <member name="F:MathCore.Values.AverageValue._Length">
            <summary>Размер окна усреднения</summary>
        </member>
        <member name="P:MathCore.Values.AverageValue.StartValue">
            <summary>Начальное значение</summary>
        </member>
        <member name="P:MathCore.Values.AverageValue.Length">
            <summary>Размер окна усреднения</summary>
        </member>
        <member name="P:MathCore.Values.AverageValue.Value">
            <summary>Текущее значение усредняемой величины</summary>
        </member>
        <member name="P:MathCore.Values.AverageValue.Dispersion">
            <summary>Дисперсия значений</summary>
        </member>
        <member name="P:MathCore.Values.AverageValue.ValuesCount">
            <summary>Количество точек усреднения</summary>
        </member>
        <member name="M:MathCore.Values.AverageValue.#ctor(System.Int32)">
            <summary>Инициализация нового скользящего среднего</summary>
            <param name="Length">Размер окна усреднения</param>
        </member>
        <member name="M:MathCore.Values.AverageValue.#ctor(System.Double)">
            <summary>Инициализация нового скользящего среднего</summary>
            <param name="StartValue">Начальное значение для усреднения</param>
        </member>
        <member name="M:MathCore.Values.AverageValue.#ctor(System.Double,System.Int32)">
            <summary>Инициализация нового скользящего среднего</summary>
            <param name="StartValue">Начальное значение</param>
            <param name="Length">Размер окна усреднения</param>
        </member>
        <member name="M:MathCore.Values.AverageValue.AddValue(System.Double)">
            <summary>Добавить значение к усреднению</summary>
            <param name="value">Добавляемое значение</param>
        </member>
        <member name="M:MathCore.Values.AverageValue.Reset">
            <summary>Сбросить состояние</summary>
        </member>
        <member name="M:MathCore.Values.AverageValue.ToString">
            <summary>Преобразование в строку</summary>
            <returns>Текстовое представление</returns>
        </member>
        <member name="M:MathCore.Values.AverageValue.ToString(System.String)">
            <summary>Преобразование в строку с форматированием</summary>
            <param name="Format">Формат</param>
            <returns>Текстовое представление</returns>
        </member>
        <member name="M:MathCore.Values.AverageValue.op_Implicit(MathCore.Values.AverageValue)~System.Double">
            <summary>Оператор неявного приведения к типу вещественного числа</summary>
            <param name="Value">Усредняемое значение</param>
        </member>
        <member name="M:MathCore.Values.AverageValue.op_Implicit(System.Double)~MathCore.Values.AverageValue">
            <summary>Оператор неявного приведения вещественного числа к скользящему среднему</summary>
            <param name="Data">Вещественное число</param>
        </member>
        <member name="M:MathCore.Values.AverageValue.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Новая усредняемая величина</summary>
            <param name="info">Сериализационная информация</param>
            <param name="context">Контекст сериализации</param>
        </member>
        <member name="M:MathCore.Values.AverageValue.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.AverageValue.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Получить состояние объекта</summary>
            <param name="info">Объект сериализации</param>
            <param name="context">Контекст операции сериализации</param>
            <exception cref="T:System.ArgumentNullException">Если <paramref name="info"/> is null</exception>
        </member>
        <member name="T:MathCore.Values.CSV">
            <summary>Файл текстовых данных, разделённых запятой</summary>
        </member>
        <member name="T:MathCore.Values.CSV.Item">
            <summary>Элемент данных</summary>
        </member>
        <member name="F:MathCore.Values.CSV.Item._Header">
            <summary>Элементы заголовка</summary>
        </member>
        <member name="F:MathCore.Values.CSV.Item._Items">
            <summary>Элементы данных</summary>
        </member>
        <member name="P:MathCore.Values.CSV.Item.Item(System.Int32)">
            <summary>Требуемый элемент данных по указанному индексу</summary>
            <param name="index">Индекс элемента данных</param>
            <returns>Элемент данных по указанному индексу</returns>
        </member>
        <member name="P:MathCore.Values.CSV.Item.Item(System.String)">
            <summary>Требуемый элемент данных по указанному имени заголовка столбца</summary>
            <param name="key">Имя столбца заголовка</param>
            <returns>Требуемый элемент данных</returns>
        </member>
        <member name="P:MathCore.Values.CSV.Item.ItemsCount">
            <summary>Количество элементов данных</summary>
        </member>
        <member name="M:MathCore.Values.CSV.Item.#ctor(System.String[],System.String[])">
            <summary>Новый элемент данных</summary>
            <param name="Header">Названия столбцов</param>
            <param name="Items">Элементы данных</param>
        </member>
        <member name="M:MathCore.Values.CSV.Item.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.CSV.Item.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.CSV.Item.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="F:MathCore.Values.CSV._FileName">
            <summary>Имя файла</summary>
        </member>
        <member name="F:MathCore.Values.CSV._Separator">
            <summary>Символ-разделитель</summary>
        </member>
        <member name="F:MathCore.Values.CSV._SkipFirstLines">
            <summary>Количество пропускаемых первых строк файла</summary>
        </member>
        <member name="F:MathCore.Values.CSV._HeaderLine">
            <summary>Считывать строку заголовков</summary>
        </member>
        <member name="F:MathCore.Values.CSV._SkipEmptyLines">
            <summary>Пропускать пустые строки</summary>
        </member>
        <member name="F:MathCore.Values.CSV._Encoding">
            <summary>Кодировка файла</summary>
        </member>
        <member name="M:MathCore.Values.CSV.#ctor(System.String,System.Char,System.Int32,System.Boolean,System.Boolean,System.Text.Encoding)">
            <summary>Новый файл данных, разделённых запятой</summary>
            <param name="FileName">Имя файла данных</param>
            <param name="Separator">Символ-разделитель</param>
            <param name="SkipFirstLines">Количество пропускаемых строк в начале файла</param>
            <param name="HeaderLine">Считывать ли заголовок</param>
            <param name="SkipEmptyLines">Пропускать пустые строки</param>
            <param name="Encoding">Кодировка файла (если не указана, используется <see cref="P:System.Text.Encoding.UTF8"/>)</param>
        </member>
        <member name="M:MathCore.Values.CSV.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.CSV.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Values.IResettable">
            <summary>Объект, позволяющий осуществлять сброс своего состояния</summary>
        </member>
        <member name="M:MathCore.Values.IResettable.Reset">
            <summary>Сброс состояния</summary>
        </member>
        <member name="T:MathCore.Values.IValue`1">
            <summary>Объект, позволяющий читать и устанавливать значение</summary>
            <typeparam name="T">Тип значения объекта</typeparam>
        </member>
        <member name="P:MathCore.Values.IValue`1.Value">
            <summary>Значение объекта</summary>
        </member>
        <member name="T:MathCore.Values.IValueRead`1">
            <summary>Объект, обладающий значением</summary>
            <typeparam name="T">Тип значения объекта</typeparam>
        </member>
        <member name="P:MathCore.Values.IValueRead`1.Value">
            <summary>Значение объекта</summary>
        </member>
        <member name="T:MathCore.Values.IValueWrite`1">
            <summary>Объект, позволяющий определять значение</summary>
            <typeparam name="T">Тип значений объекта</typeparam>
        </member>
        <member name="P:MathCore.Values.IValueWrite`1.Value">
            <summary>Значение объекта</summary>
        </member>
        <member name="T:MathCore.Values.LazyValue`1">
            <summary>"Ленивое" значение</summary>
            <typeparam name="T">Тип значения</typeparam>
        </member>
        <member name="F:MathCore.Values.LazyValue`1._Initializator">
            <summary>Инициализатор значения</summary>
        </member>
        <member name="F:MathCore.Values.LazyValue`1._Value">
            <summary>Значение</summary>
        </member>
        <member name="F:MathCore.Values.LazyValue`1._LockObject">
            <summary>Объект кросспоточной блокировки</summary>
        </member>
        <member name="F:MathCore.Values.LazyValue`1._Initialized">
            <summary>Флаг инициализации</summary>
        </member>
        <member name="P:MathCore.Values.LazyValue`1.Initialized">
            <summary>Признак инициализации</summary>
        </member>
        <member name="P:MathCore.Values.LazyValue`1.Value">
            <summary>Значение</summary>
        </member>
        <member name="M:MathCore.Values.LazyValue`1.#ctor(System.Func{`0})">
            <summary>Создание нового "ленивого" значения</summary>
            <param name="Initializer">Инициализатор значения</param>
        </member>
        <member name="M:MathCore.Values.LazyValue`1.Initialize(System.Func{`0})">
            <summary>Инициализация "ленивого" значения</summary>
            <param name="Initializer">Инициализатор</param>
        </member>
        <member name="M:MathCore.Values.LazyValue`1.System#IInitializable#Initialize">
            <summary>Вызов метода инициализации для интерфейса <see cref="T:System.IInitializable"/></summary>
        </member>
        <member name="M:MathCore.Values.LazyValue`1.Reset">
            <summary>Сброс состояния</summary>
        </member>
        <member name="M:MathCore.Values.LazyValue`1.op_Implicit(MathCore.Values.LazyValue{`0})~`0">
            <summary>Оператор неявного преобразования "ленивого" значения в обычное</summary>
            <param name="value">"Ленивое" значение</param>
            <returns>Обычное значение, получаемое при вычислении "ленивого" значения</returns>
        </member>
        <member name="M:MathCore.Values.LazyValue`1.op_Implicit(System.Func{`0})~MathCore.Values.LazyValue{`0}">
            <summary>Оператор неявного преобразования метода инициализации в "ленивое значение"</summary>
            <param name="Initializer">Метод инициализации "ленивого" значения</param>
            <returns>"Ленивое" значение с указанным методом инициализации</returns>
        </member>
        <member name="T:MathCore.Values.LinearQueue`1">
            <summary>Очередь с линейным доступом</summary>
            <typeparam name="T">Тип элементов очереди</typeparam>
        </member>
        <member name="T:MathCore.Values.MaxValue">
            <summary>Максимальное значение</summary>
        </member>
        <member name="P:MathCore.Values.MaxValue.Value">
            <summary>Минимальное значение</summary>
        </member>
        <member name="M:MathCore.Values.MaxValue.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Values.MaxValue"/></summary>
        </member>
        <member name="M:MathCore.Values.MaxValue.#ctor(System.Double)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Values.MaxValue"/></summary>
            <param name="StartValue">Начальное значение</param>
        </member>
        <member name="M:MathCore.Values.MaxValue.Add(System.Double)">
            <summary>Добавить новое значение</summary>
            <param name="value">Добавляемое значение</param>
            <returns>Максимальное значение из всех добавленных</returns>
        </member>
        <member name="M:MathCore.Values.MaxValue.AddValue(System.Double)">
            <summary>Добавить новое значение</summary>
            <param name="value">Добавляемое значение</param>
            <returns>Истина, если добавляемое значение является максимальным</returns>
        </member>
        <member name="M:MathCore.Values.MaxValue.Reset">
            <summary>Сбросить состояние минимального значения</summary>
        </member>
        <member name="M:MathCore.Values.MaxValue.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.MaxValue.ToString(System.String,System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.MaxValue.ToString(System.String)">
            <summary>Возвращает форматированную строку значения </summary>
            <param name="FormatString">Формат значения</param>
            <returns>Форматированная строка значения</returns>
        </member>
        <member name="M:MathCore.Values.MaxValue.op_Implicit(MathCore.Values.MaxValue)~System.Double">
            <summary>Оператор неявного приведения типа <see cref="T:MathCore.Values.MaxValue"/> к <see cref="T:System.Double"/></summary>
            <param name="MaxValue">Максимальное значение значение</param>
        </member>
        <member name="T:MathCore.Values.MinMaxValue">
            <summary>Объект, отслеживающий минимальное и максимальное значение входящей величины</summary>
        </member>
        <member name="F:MathCore.Values.MinMaxValue._Min">
            <summary>Минимальное значение</summary>
        </member>
        <member name="F:MathCore.Values.MinMaxValue._Max">
            <summary>Максимальное значение</summary>
        </member>
        <member name="P:MathCore.Values.MinMaxValue.Min">
            <summary>Минимальное значение</summary>
        </member>
        <member name="P:MathCore.Values.MinMaxValue.Max">
            <summary>Максимальное значение</summary>
        </member>
        <member name="P:MathCore.Values.MinMaxValue.Interval">
            <summary>Интервал значений</summary>
        </member>
        <member name="M:MathCore.Values.MinMaxValue.Reset">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.MinMaxValue.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.MinMaxValue.ToString(System.String,System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Values.MinValue">
            <summary>Минимальное значение</summary>
        </member>
        <member name="P:MathCore.Values.MinValue.Value">
            <summary>Минимальное значение</summary>
        </member>
        <member name="M:MathCore.Values.MinValue.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Values.MinValue"/></summary>
        </member>
        <member name="M:MathCore.Values.MinValue.#ctor(System.Double)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Values.MinValue"/></summary>
            <param name="StartValue">Начальное значение</param>
        </member>
        <member name="M:MathCore.Values.MinValue.Add(System.Double)">
            <summary>Добавить новое значение</summary>
            <param name="value">Добавляемое значение</param>
            <returns>Минимальный элемент из всех добавленных</returns>
        </member>
        <member name="M:MathCore.Values.MinValue.AddValue(System.Double)">
            <summary>Добавить новое значение</summary>
            <param name="value">Добавляемое значение</param>
            <returns>Истина, если добавляемое значение является минимальным</returns>
        </member>
        <member name="M:MathCore.Values.MinValue.Reset">
            <summary>Сбросить состояние минимального значения</summary>
        </member>
        <member name="M:MathCore.Values.MinValue.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.MinValue.ToString(System.String,System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.MinValue.ToString(System.String)">
            <summary>Возвращает форматированную строку значения </summary>
            <param name="FormatString">Формат значения</param>
            <returns>Форматированная строка значения</returns>
        </member>
        <member name="M:MathCore.Values.MinValue.op_Implicit(MathCore.Values.MinValue)~System.Double">
            <summary>Оператор неявного приведения типа <see cref="T:MathCore.Values.MinValue"/> к <see cref="T:System.Double"/></summary>
            <param name="MinValue">Минимальное значение</param>
        </member>
        <member name="M:MathCore.Values.NumberedValues`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Values.ObjectSelector`1">
            <summary>Система псевдопараллельного потокового доступа к значению ряда источников объектов</summary>
            <typeparam name="T">Тип объектов в источниках</typeparam>
            <example>
            Примером использования может быть способ последовательного выбора данных из ряда потоков чтения 
            с выбором последовательности данных, выводимых в общий поток.
            void Test()
            {
               //Используем уничтожаемую группу объектов
              using(var readers = new DisposableGroup&lt;StreamReader&gt;(//Объекты чтения из потока
                      Directory.GetFiles(@"c:\", "*.txt").Select(f => new StreamReader(f))))  //для всех файлов C:\*.txt
              {
                var rnd = new Random();                                         //Генератор случайных чисел
                var o_selector = new ObjectSelector&lt;string&gt;(                     //Создаём объект выбора строк
                            SS => rnd.Next(readers.Count),                      //Очередная строка из случайного файла
                            () => readers.All(r => !r.EndOfStream),             //Признак возможности чтения - ни один из потоков не закончен
                            readers.Select(r => (Func&lt;string&gt;)(r.ReadLine)));   //Инициализатор - метод, возвращающий строку из файла
                while(o_selector.CanRead) Console.Write(o_selector.Value);        //Читаем всё построчно в консоль
              }
            }
            </example>
        </member>
        <member name="F:MathCore.Values.ObjectSelector`1._Selector">
            <summary>Метод выбора одного из значений ряда источников объектов</summary>
        </member>
        <member name="F:MathCore.Values.ObjectSelector`1._Values">
            <summary>Массив "ленивых" значений, используемых в качестве генераторов объектов </summary>
        </member>
        <member name="F:MathCore.Values.ObjectSelector`1._CanRead">
            <summary>Метод, определяющий возможность чтения данных из источников</summary>
        </member>
        <member name="P:MathCore.Values.ObjectSelector`1.Value">
            <summary>Очередное значение из вектора генераторов значений</summary>
        </member>
        <member name="P:MathCore.Values.ObjectSelector`1.CanRead">
            <summary>Признак возможности чтения объекта</summary>
        </member>
        <member name="M:MathCore.Values.ObjectSelector`1.#ctor(System.Func{`0[],System.Int32},System.Func{System.Boolean},System.Func{`0}[])">
            <summary>Новый генератор последовательности объектов из источника параллельных значений</summary>
            <param name="Selector">Метод выбора значения</param>
            <param name="CanRead">Метод определения возможности чтения значения</param>
            <param name="Generator">Массив генераторов объектов "ленивых" значений</param>
        </member>
        <member name="M:MathCore.Values.ObjectSelector`1.#ctor(System.Func{`0[],System.Int32},System.Func{System.Boolean},System.Collections.Generic.IEnumerable{System.Func{`0}})">
            <summary>Новый генератор последовательности объектов из источника параллельных значений</summary>
            <param name="Selector">Метод выбора значения</param>
            <param name="CanRead">Метод определения возможности чтения значения</param>
            <param name="GeneratorsEnum">Массив генераторов объектов "ленивых" значений</param>
        </member>
        <member name="T:MathCore.Values.Set`1">
            <summary>Множество элементов</summary>
            <typeparam name="T">Тип данных множества</typeparam>
        </member>
        <member name="P:MathCore.Values.Set`1.Power">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.Set`1.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Values.Set`1"/></summary>
        </member>
        <member name="M:MathCore.Values.Set`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Values.Set`1"/></summary>
            <param name="comparer">Объект, осуществляющий сравнение элементов множества</param>
        </member>
        <member name="M:MathCore.Values.Set`1.Add(`0)">
            <summary>Добавить элемент в множество</summary>
            <param name="Value">Добавляемый элемент</param>
            <returns>Истина, если элемент был успешно добавлен и ложь, если элемент уже присутствует в множестве</returns>
        </member>
        <member name="M:MathCore.Values.Set`1.Contains(`0)">
            <summary>Проверка на вхождение элемента в множество</summary>
            <param name="Value">Проверяемый элемент</param>
            <returns>Истина, если элемент входит в множество</returns>
        </member>
        <member name="M:MathCore.Values.Set`1.Add(`0,System.Int32)">
            <summary>Добавить элемент в множество</summary>
            <param name="Value">Добавляемый элемент</param>
            <param name="Hash">Хеш-код элемента</param>
        </member>
        <member name="M:MathCore.Values.Set`1.Remove(`0)">
            <summary>Удаление элемента из множества</summary>
            <param name="Value">Удаляемый элемент</param>
            <returns>Истина, если элемент присутствовал в множестве и был оттуда удалён</returns>
        </member>
        <member name="M:MathCore.Values.Set`1.Resize">
            <summary>Подгон размера хранилища</summary>
        </member>
        <member name="M:MathCore.Values.Set`1.GetHashCodeOf(`0)">
            <summary>Получить хещ-код элемента</summary>
            <param name="Value">Элемент, хеш-код которого требуется получить</param>
            <returns>Рассчитанный хеш-код элемента</returns>
        </member>
        <member name="M:MathCore.Values.Set`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Values.SetOf`1">
            <summary>Множество объектов типа <typeparamref name="T"/></summary>
            <typeparam name="T">Тип элементов множества</typeparam>
            <summary>Множество</summary>
            <typeparam name="T">Тип элементов множества</typeparam>
        </member>
        <member name="P:MathCore.Values.SetOf`1.Mixed">
            <summary>Перемешивать содержимое при выдаче массива элементов</summary>
        </member>
        <member name="F:MathCore.Values.SetOf`1._List">
            <summary>Список элементов</summary>
        </member>
        <member name="P:MathCore.Values.SetOf`1.Power">
            <summary>Мощность множества</summary>
        </member>
        <member name="M:MathCore.Values.SetOf`1.#ctor">
            <summary>Новое множество элементов</summary>
        </member>
        <member name="M:MathCore.Values.SetOf`1.#ctor(System.Int32)">
            <summary>Новое множество элементов</summary>
            <param name="Capacity">Ёмкость множества</param>
        </member>
        <member name="M:MathCore.Values.SetOf`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>Новое множество элементов</summary>
            <param name="collection">Коллекция элементов</param>
        </member>
        <member name="M:MathCore.Values.SetOf`1.#ctor(`0[])">
            <summary>Новое множество элементов</summary>
            <param name="element">Элементы множества</param>
        </member>
        <member name="M:MathCore.Values.SetOf`1.ToList">
            <summary>Преобразование в список</summary>
            <returns>Список элементов</returns>
        </member>
        <member name="M:MathCore.Values.SetOf`1.ToArray">
            <summary>Преобразование множества элементов в массив</summary>
            <returns>Массив элементов</returns>
        </member>
        <member name="M:MathCore.Values.SetOf`1.Clone">
            <summary>Клонирование множества элементов</summary>
            <returns></returns>
        </member>
        <member name="M:MathCore.Values.SetOf`1.Equals(MathCore.Values.SetOf{`0})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.SetOf`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.SetOf`1.GetEnumerator">
            <summary>Возвращает перечислитель, выполняющий перебор элементов в коллекции.</summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.IEnumerator`1"/>, который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:MathCore.Values.SetOf`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Возвращает перечислитель, который осуществляет перебор элементов коллекции.</summary>
            <returns>
            Объект <see cref="T:System.Collections.IEnumerator"/>, который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:MathCore.Values.SetOf`1.Add(`0)">
            <summary>Добавляет элемент в интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <param name="item">Объект, добавляемый в интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения.</exception>
        </member>
        <member name="M:MathCore.Values.SetOf`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.SetOf`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.SetOf`1.Contains(`0)">
            <inheritdoc cref="T:System.Collections.Generic.ICollection`1" />
        </member>
        <member name="M:MathCore.Values.SetOf`1.System#Collections#Generic#ICollection{T}#CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.SetOf`1.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="P:MathCore.Values.SetOf`1.System#Collections#Generic#ICollection{T}#Count">
            <inheritdoc />
        </member>
        <member name="P:MathCore.Values.SetOf`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Values.StatisticValue">
            <summary>Статистическая информация о значении</summary>
        </member>
        <member name="F:MathCore.Values.StatisticValue._Average">
            <summary>Среднее значение</summary>
        </member>
        <member name="F:MathCore.Values.StatisticValue._Average2">
            <summary>Среднее значение квадрата величины</summary>
        </member>
        <member name="F:MathCore.Values.StatisticValue._MinMax">
            <summary>Диапазон значений</summary>
        </member>
        <member name="P:MathCore.Values.StatisticValue.M">
            <summary>Математическое ожидание величины</summary>
        </member>
        <member name="P:MathCore.Values.StatisticValue.D">
            <summary>Дисперсия</summary>
        </member>
        <member name="P:MathCore.Values.StatisticValue.MinMax">
            <summary>Интервал значений, в который попадает величина</summary>
        </member>
        <member name="P:MathCore.Values.StatisticValue.Count">
            <summary>Размер выборки</summary>
        </member>
        <member name="M:MathCore.Values.StatisticValue.#ctor(System.Int32)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Values.StatisticValue"/></summary>
            <param name="Length">Требуемый размер выборки</param>
        </member>
        <member name="M:MathCore.Values.StatisticValue.AddValue(System.Double)">
            <summary>Добавить значение к оценке статистики</summary>
            <param name="x">Добавляемое значение</param>
        </member>
        <member name="M:MathCore.Values.StatisticValue.AddEnumerable(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Добавить перечисление объектов к оценке статистики</summary>
            <param name="collection">Добавляемая последовательность значений</param>
        </member>
        <member name="M:MathCore.Values.StatisticValue.Reset">
            <summary>Сбросить состояние оценки</summary>
        </member>
        <member name="M:MathCore.Values.StatisticValue.ToString">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Values.StreamDataSpeedValue">
            <summary>Измеритель скорости потока данных</summary>
        </member>
        <member name="F:MathCore.Values.StreamDataSpeedValue.__DataNames">
            <summary>Названия скоростей</summary>
        </member>
        <member name="P:MathCore.Values.StreamDataSpeedValue.Now">
            <summary>Текущее время</summary>
        </member>
        <member name="F:MathCore.Values.StreamDataSpeedValue._AverageValue">
            <summary>Значение, усреднённое во времени</summary>
        </member>
        <member name="F:MathCore.Values.StreamDataSpeedValue._DataStream">
            <summary>Поток данных</summary>
        </member>
        <member name="F:MathCore.Values.StreamDataSpeedValue._LastPosition">
            <summary>Последнее положение в потоке денных</summary>
        </member>
        <member name="F:MathCore.Values.StreamDataSpeedValue._LastTime">
            <summary>Последнее время</summary>
        </member>
        <member name="F:MathCore.Values.StreamDataSpeedValue._Round">
            <summary>Количество знаков после запятой в строковом представлении</summary>
        </member>
        <member name="F:MathCore.Values.StreamDataSpeedValue._LastSpeedValue">
            <summary>Последнее зафиксированное значение скорости</summary>
        </member>
        <member name="F:MathCore.Values.StreamDataSpeedValue._SpeedCheckTimeout">
            <summary>Минимально допустимый интервал времени в секундах для проверки значения скорости</summary>
        </member>
        <member name="P:MathCore.Values.StreamDataSpeedValue.Round">
            <summary>Количество знаков после запятой в строковом представлении</summary>
        </member>
        <member name="P:MathCore.Values.StreamDataSpeedValue.Value">
            <summary>Мгновенное значение скорости</summary>
        </member>
        <member name="P:MathCore.Values.StreamDataSpeedValue.AverageValue">
            <summary>Усреднённое значение скорости</summary>
        </member>
        <member name="P:MathCore.Values.StreamDataSpeedValue.SpeedStr">
            <summary>Строковое представление скорости</summary>
        </member>
        <member name="P:MathCore.Values.StreamDataSpeedValue.AverageTau">
            <summary>Постоянная времени усреднения </summary>
        </member>
        <member name="P:MathCore.Values.StreamDataSpeedValue.SpeedCheckTimeout">
            <summary>Минимально допустимый интервал времени проверки скорости</summary>
        </member>
        <member name="M:MathCore.Values.StreamDataSpeedValue.#ctor(System.IO.Stream)">
            <summary>Новый измеритель скорости потока данных</summary>
            <param name="DataStream">Поток данных для измерения</param>
            <exception cref="T:System.ArgumentNullException">Исключение возникает при нулевой ссылке на поток данных</exception>
        </member>
        <member name="M:MathCore.Values.StreamDataSpeedValue.Reset">
            <summary>Сброс измерителя: установка стартового значения положения в потоке, сброс усреднителя</summary>
        </member>
        <member name="M:MathCore.Values.StreamDataSpeedValue.CheckSpeed">
            <summary>Получить измерение скорости</summary>
            <returns>Мгновенная измеренная скорость перемещения в потоке</returns>
        </member>
        <member name="M:MathCore.Values.StreamDataSpeedValue.op_Implicit(MathCore.Values.StreamDataSpeedValue)~System.Double">
            <summary>Неявное преобразование измерителя скорости к значению скорости (усреднённому)</summary>
            <param name="speed">Измеритель скорости</param>
            <returns>Значение скорости</returns>
        </member>
        <member name="M:MathCore.Values.TimeAverage2Value.Add(System.Double)">
            <summary>Добавить значение</summary><param name="value">Значение</param>
        </member>
        <member name="T:MathCore.Values.TimeAverageValue">
            <summary>Усредняемая по времени величина</summary>
        </member>
        <member name="F:MathCore.Values.TimeAverageValue._LastTime">
            <summary>Последнее время доступа</summary>
        </member>
        <member name="F:MathCore.Values.TimeAverageValue._Tau">
            <summary>Постоянная времени усреднения</summary>
        </member>
        <member name="P:MathCore.Values.TimeAverageValue.Tau">
            <summary>Постоянная времени</summary>
        </member>
        <member name="P:MathCore.Values.TimeAverageValue.Value">
            <summary>Значение</summary>
        </member>
        <member name="P:MathCore.Values.TimeAverageValue.Initialized">
            <summary>Признак инициализации</summary>
        </member>
        <member name="M:MathCore.Values.TimeAverageValue.#ctor(System.Double)">
            <summary>Усредняемая по времени величина</summary>
            <param name="tau">Постоянная времени усреднения >= 0</param>
        </member>
        <member name="M:MathCore.Values.TimeAverageValue.#ctor(System.Double,System.Double)">
            <summary>Усредняемая по времени величина</summary>
            <param name="Value">Начальное значение</param><param name="tau">постоянная времени >= 0</param>
        </member>
        <member name="M:MathCore.Values.TimeAverageValue.Add(System.Double)">
            <summary>Добавить значение</summary>
            <param name="value">Значение</param>
        </member>
        <member name="M:MathCore.Values.TimeAverageValue.Reset">
            <summary>Сброс состояния</summary>
        </member>
        <member name="T:MathCore.Vectors.Basis2D">
            <summary>Двумерный базис</summary>
        </member>
        <member name="F:MathCore.Vectors.Basis2D.Euclid">
            <summary>Базис Евклидова пространства</summary>
        </member>
        <member name="M:MathCore.Vectors.Basis2D.Rotate(System.Double,System.Boolean)">
            <summary>Базис поворота вектора на заданный угол</summary>
            <param name="Angle">Угол поворота пространства</param>
            <param name="Positive">Направление поворота по часовой стрелке</param>
            <returns>Базис, осуществляющий поворот вектора в пространстве на указанный угол</returns>
        </member>
        <member name="M:MathCore.Vectors.Basis2D.Scale(System.Double,System.Double)">
            <summary>Базис масштабирования вектора по осям</summary>
            <param name="kx">Коэффициент масштабирования вдоль оси OX</param>
            <param name="ky">Коэффициент масштабирования вдоль оси OY</param>
            <returns>Базис, осуществляющий масштабирования вектора по осям</returns>
        </member>
        <member name="F:MathCore.Vectors.Basis2D._xx">
            <summary>Элемент X[0,0]</summary>
        </member>
        <member name="P:MathCore.Vectors.Basis2D.xx">
            <summary>Элемент X[0,0]</summary>
        </member>
        <member name="F:MathCore.Vectors.Basis2D._xy">
            <summary>Элемент X[0,1]</summary>
        </member>
        <member name="P:MathCore.Vectors.Basis2D.xy">
            <summary>Элемент X[0,1]</summary>
        </member>
        <member name="F:MathCore.Vectors.Basis2D._yx">
            <summary>Элемент X[1,0]</summary>
        </member>
        <member name="P:MathCore.Vectors.Basis2D.yx">
            <summary>Элемент X[1,0]</summary>
        </member>
        <member name="F:MathCore.Vectors.Basis2D._yy">
            <summary>Элемент X[1,1]</summary>
        </member>
        <member name="P:MathCore.Vectors.Basis2D.yy">
            <summary>Элемент X[1,1]</summary>
        </member>
        <member name="M:MathCore.Vectors.Basis2D.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Vectors.Basis2D"/></summary>
            <param name="xx">Элемент X[0,0]</param>
            <param name="xy">Элемент X[0,1]</param>
            <param name="yx">Элемент X[1,0]</param>
            <param name="yy">Элемент X[1,1]</param>
        </member>
        <member name="M:MathCore.Vectors.Basis2D.op_Implicit(MathCore.Vectors.Basis2D@)~MathCore.Matrix">
            <summary>Оператор неявного преобразования базиса в матрицу 2х2</summary>
        </member>
        <member name="M:MathCore.Vectors.Basis2D.op_Explicit(MathCore.Matrix@)~MathCore.Vectors.Basis2D">
            <summary>Оператор явного преобразования матрицы 2х2 в двумерный базис</summary>
        </member>
        <member name="M:MathCore.Vectors.Basis2D.Equals(MathCore.Vectors.Basis2D)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Basis2D.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Basis2D.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Basis2D.op_Equality(MathCore.Vectors.Basis2D,MathCore.Vectors.Basis2D)">
            <summary>Оператор равенства двух базисов</summary>
        </member>
        <member name="M:MathCore.Vectors.Basis2D.op_Inequality(MathCore.Vectors.Basis2D,MathCore.Vectors.Basis2D)">
            <summary>Оператор неравенства двух базисов</summary>
        </member>
        <member name="T:MathCore.Vectors.Basis3D">
            <summary>Базис трёхмерного пространства</summary>
        </member>
        <member name="F:MathCore.Vectors.Basis3D.Euclid">
            <summary>Базис Евклидова пространства</summary>
        </member>
        <member name="M:MathCore.Vectors.Basis3D.Scale(System.Double,System.Double,System.Double)">
            <summary>Базис масштабирования по осям</summary>
            <param name="kx">Коэффициент масштабирования вдоль оси OX</param>
            <param name="ky">Коэффициент масштабирования вдоль оси OY</param>
            <param name="kz">Коэффициент масштабирования вдоль оси OZ</param>
            <returns>Базис масштабирования вдоль основных осей</returns>
        </member>
        <member name="M:MathCore.Vectors.Basis3D.RotateOX(System.Double,System.Boolean)">
            <summary>Базис поворота вокруг оси OX</summary>
            <param name="Angle">Угол поворота</param>
            <param name="Positive">Направление - по часовой стрелке</param>
            <returns>Базис поворота вокруг оси OX</returns>
        </member>
        <member name="M:MathCore.Vectors.Basis3D.RotateOY(System.Double,System.Boolean)">
            <summary>Базис поворота вокруг оси OY</summary>
            <param name="Angle">Угол поворота</param>
            <param name="Positive">Направление - по часовой стрелке</param>
            <returns>Базис поворота вокруг оси OY</returns>
        </member>
        <member name="M:MathCore.Vectors.Basis3D.RotateOZ(System.Double,System.Boolean)">
            <summary>Базис поворота вокруг оси OZ</summary>
            <param name="Angle">Угол поворота</param>
            <param name="Positive">Направление - по часовой стрелке</param>
            <returns>Базис поворота вокруг оси OZ</returns>
        </member>
        <member name="M:MathCore.Vectors.Basis3D.Rotate(System.Double,System.Double,System.Double)">
            <summary>Базис поворота на углы Эйлера</summary>
            <param name="alpha">Угол поворота вокруг оси OX</param>
            <param name="beta">Угол поворота вокруг оси OY</param>
            <param name="gamma">Угол поворота вокруг оси OZ</param>
            <returns></returns>
        </member>
        <member name="M:MathCore.Vectors.Basis3D.Rotate(MathCore.Vectors.Vector3D@,System.Double)">
            <summary>Базис сдвига и поворота на заданный угол</summary>
            <param name="v">Вектор сдвига</param>
            <param name="theta">Угол места поворота</param>
            <returns>Базис сдвига и поворота</returns>
        </member>
        <member name="P:MathCore.Vectors.Basis3D.xx">
            <summary>Элемент [0,0]</summary>
        </member>
        <member name="P:MathCore.Vectors.Basis3D.xy">
            <summary>Элемент [0,1]</summary>
        </member>
        <member name="P:MathCore.Vectors.Basis3D.xz">
            <summary>Элемент [0,2]</summary>
        </member>
        <member name="P:MathCore.Vectors.Basis3D.yx">
            <summary>Элемент [1,0]</summary>
        </member>
        <member name="P:MathCore.Vectors.Basis3D.yy">
            <summary>Элемент [1,1]</summary>
        </member>
        <member name="P:MathCore.Vectors.Basis3D.yz">
            <summary>Элемент [1,2]</summary>
        </member>
        <member name="P:MathCore.Vectors.Basis3D.zx">
            <summary>Элемент [2,0]</summary>
        </member>
        <member name="P:MathCore.Vectors.Basis3D.zy">
            <summary>Элемент [2,1]</summary>
        </member>
        <member name="P:MathCore.Vectors.Basis3D.zz">
            <summary>Элемент [2,2]</summary>
        </member>
        <member name="M:MathCore.Vectors.Basis3D.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Vectors.Basis3D"/></summary>
            <param name="xx">Элемент X[0,0]</param>
            <param name="xy">Элемент X[0,1]</param>
            <param name="xz">Элемент X[0,2]</param>
            <param name="yx">Элемент X[1,0]</param>
            <param name="yy">Элемент X[1,1]</param>
            <param name="yz">Элемент X[1,2]</param>
            <param name="zx">Элемент X[2,0]</param>
            <param name="zy">Элемент X[2,1]</param>
            <param name="zz">Элемент X[2,2]</param>
        </member>
        <member name="M:MathCore.Vectors.Basis3D.op_Implicit(MathCore.Vectors.Basis3D@)~MathCore.Matrix">
            <summary>Оператор неявного преобразования базиса в матрицу 3х3</summary>
        </member>
        <member name="M:MathCore.Vectors.Basis3D.op_Explicit(MathCore.Matrix)~MathCore.Vectors.Basis3D">
            <summary>Оператор явного преобразования матрицы 2х2 в двумерный базис</summary>
        </member>
        <member name="M:MathCore.Vectors.Basis3D.Equals(MathCore.Vectors.Basis3D)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Basis3D.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Basis3D.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Basis3D.op_Equality(MathCore.Vectors.Basis3D,MathCore.Vectors.Basis3D)">
            <summary>Оператор равенства двух базисов</summary>
        </member>
        <member name="M:MathCore.Vectors.Basis3D.op_Inequality(MathCore.Vectors.Basis3D,MathCore.Vectors.Basis3D)">
            <summary>Оператор неравенства двух базисов</summary>
        </member>
        <member name="T:MathCore.Vectors.Fields.VectorField3D">
            <summary>Трёхмерное векторное поле</summary>
            <param name="r">Координата в пространстве</param>
            <returns>Значение вектора в точке с указанными координатами</returns>
        </member>
        <member name="T:MathCore.Vectors.Fields.VectorField3DExtensions">
            <summary>Методы-расширения над <see cref="T:MathCore.Vectors.Fields.VectorField3D"/></summary>
        </member>
        <member name="T:MathCore.Vectors.SpaceAngle">
            <summary>Пространственный угол</summary>
        </member>
        <member name="F:MathCore.Vectors.SpaceAngle.__ToDeg">
            <summary>Константа преобразования угла в радианах в градусы</summary>
        </member>
        <member name="F:MathCore.Vectors.SpaceAngle.__ToRad">
            <summary>Константа преобразования угла в градусах в радианы</summary>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.NormalizeAngle(System.Double,MathCore.AngleType@)">
            <summary>Нормализация угла</summary>
            <param name="angle">Номализуемый угол</param>
            <param name="type">Тип значения угла (градусы/радианы)</param>
            <returns>Угол, представленный в интервале от 0 до 360° (0 до 2π)</returns>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.Random(System.Double,System.Double)">
            <summary>Случайный пространственный угол</summary>
            <param name="Min">Минимальное значение угла</param>
            <param name="Max">Максимальное значение угла</param>
            <returns>Случайный пространственный угол</returns>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.Value(System.Double,System.Double,MathCore.AngleType@)">
            <summary>Создать новый пространственный угол на основе значений углов места и азимута</summary>
            <param name="theta">Угол места</param>
            <param name="phi">Угол азимута</param>
            <param name="type">Тип значения угла</param>
            <returns>Пространственный угол</returns>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.Direction(MathCore.Vectors.Vector3D@)">
            <summary>Создать угол на основе направляющего вектора</summary>
            <param name="r">Вектор направления</param>
            <returns>Угол вектора направления</returns>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.Direction(System.Double,System.Double,System.Double)">
            <summary>Создать пространственный угол по заданным координатам вектора направления</summary>
            <returns>Угол вектора направления</returns>
        </member>
        <member name="F:MathCore.Vectors.SpaceAngle.i">
            <summary>Орта оси OX</summary>
        </member>
        <member name="F:MathCore.Vectors.SpaceAngle.i_negative">
            <summary>Отрицательная орта оси OX</summary>
        </member>
        <member name="F:MathCore.Vectors.SpaceAngle.j">
            <summary>Орта оси OY</summary>
        </member>
        <member name="F:MathCore.Vectors.SpaceAngle.j_negative">
            <summary>Отрицательная орта оси OY</summary>
        </member>
        <member name="F:MathCore.Vectors.SpaceAngle.k">
            <summary>Орта оси OZ</summary>
        </member>
        <member name="F:MathCore.Vectors.SpaceAngle.k_negative">
            <summary>Отрицательная орта оси OZ</summary>
        </member>
        <member name="F:MathCore.Vectors.SpaceAngle._AngleType">
            <summary>Тип угла</summary>
        </member>
        <member name="F:MathCore.Vectors.SpaceAngle._Theta">
            <summary>Угол места</summary>
        </member>
        <member name="F:MathCore.Vectors.SpaceAngle._Phi">
            <summary>Угол азимута</summary>
        </member>
        <member name="P:MathCore.Vectors.SpaceAngle.Theta">
            <summary>Угол места</summary>
        </member>
        <member name="P:MathCore.Vectors.SpaceAngle.Phi">
            <summary>Азимутальный угол в плоскости XOY</summary>
        </member>
        <member name="P:MathCore.Vectors.SpaceAngle.ThetaRad">
            <summary>Угол места в радианах</summary>
        </member>
        <member name="P:MathCore.Vectors.SpaceAngle.ThetaDeg">
            <summary>Угол места в градусах</summary>
        </member>
        <member name="P:MathCore.Vectors.SpaceAngle.PhiRad">
            <summary>Угол азимута в радианах</summary>
        </member>
        <member name="P:MathCore.Vectors.SpaceAngle.PhiDeg">
            <summary>Угол азимута в градусах</summary>
        </member>
        <member name="P:MathCore.Vectors.SpaceAngle.IsZero">
            <summary>Являются ли значения угла места и азимута = 0?</summary>
        </member>
        <member name="P:MathCore.Vectors.SpaceAngle.ComplexCosTheta">
            <summary>Комплексное число, характеризующее действительной частью направляющий косинус <see cref="P:MathCore.Vectors.SpaceAngle.Theta"/>, мнимой частью - направляющий синус</summary>
        </member>
        <member name="P:MathCore.Vectors.SpaceAngle.ComplexCosPhi">
            <summary>Комплексное число, характеризующее действительной частью направляющий косинус <see cref="P:MathCore.Vectors.SpaceAngle.Phi"/>, мнимой частью - направляющий синус</summary>
        </member>
        <member name="P:MathCore.Vectors.SpaceAngle.AngleType">
            <summary>Тип угла</summary>
        </member>
        <member name="P:MathCore.Vectors.SpaceAngle.InDeg">
            <summary>Представление угла в градусах</summary>
            <exception cref="T:System.NotSupportedException" accessor="get">Неизвестный тип угла</exception>
        </member>
        <member name="P:MathCore.Vectors.SpaceAngle.InRad">
            <summary>Представление угла в радианах</summary>
            <exception cref="T:System.NotSupportedException" accessor="get">Неизвестный тип угла</exception>
        </member>
        <member name="P:MathCore.Vectors.SpaceAngle.DirectionalVector">
            <summary>Направляющий вектор</summary>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.#ctor(System.Double)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Vectors.SpaceAngle"/></summary>
            <param name="Phi">Угол азимута</param>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.#ctor(System.Double,MathCore.AngleType@)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Vectors.SpaceAngle"/></summary>
            <param name="Phi">Угол азимута</param>
            <param name="AngleType">Тип значения угла</param>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.#ctor(System.Double,System.Double)">
            <summary>Пространственный угол в радианах</summary>
            <param name="Theta">Угол места [рад]</param>
            <param name="Phi">Азимутальный угол [рад]</param>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.#ctor(System.Double,System.Double,MathCore.AngleType@)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Vectors.SpaceAngle"/></summary>
            <param name="Theta">Угол места</param>
            <param name="Phi">Угол азимута</param>
            <param name="AngleType">Тип значения угла</param>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.#ctor(MathCore.Vectors.SpaceAngle@)">
            <summary>Копирование нового экземпляра <see cref="T:MathCore.Vectors.SpaceAngle"/> из прототипа</summary>
            <param name="Angle">Исходное значение угла</param>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.#ctor(MathCore.Vectors.SpaceAngle@,MathCore.AngleType@)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Vectors.SpaceAngle"/></summary>
            <param name="Angle">Исходное значение угла</param>
            <param name="AngleType">Тип желаемого значения угла</param>
            <exception cref="T:System.NotSupportedException">Если AngleType != Deg || Rad - Неизвестный тип угла</exception>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.RotatePhiTheta(System.Double,System.Double,MathCore.AngleType@)">
            <summary>Повернуть угол в сферической системе координат</summary>
            <param name="theta">Угол места поворота локальной системы координат</param>
            <param name="phi">Угол азимута поворота локальной системы координат</param>
            <param name="type">Тип значений угловых величин</param>
            <returns>Угол в повёрнутой локальной системе координат</returns>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.RotatePhiTheta(MathCore.Vectors.SpaceAngle@)">
            <summary>Повернуть угол в сферической системе координат</summary>
            <param name="angle">Пространственный угол поворота локальной системы координат</param>
            <returns>Угол в повёрнутой локальной системе координат</returns>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.GetRotatorPhiTheta">
            <summary>Получить функцию, осуществляющую поворот пространственного угла на текущий пространственный угол</summary>
            <returns>Функция, осуществляющая поворот пространственного угла на заданный угол</returns>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.GetRotatorPhiTheta(MathCore.Vectors.SpaceAngle@)">
            <summary>Получить функцию, осуществляющую поворот пространственного угла на заданный пространственный угол</summary>
            <param name="angle"></param>
            <returns></returns>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.GetRotatorPhiThetaExpression(System.Linq.Expressions.Expression)">
            <summary>Получить выражение, осуществляющее поворот угла на текущий пространственный угол</summary>
            <param name="r">Выражение, предоставляющее пространственный угол, который требуется повернуть</param>
            <returns>Выражение, обеспечивающее поворот пространственного угла на текущий угол</returns>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.RotatePhiTheta``1(System.Func{MathCore.Vectors.SpaceAngle,``0})">
            <summary>Повернуть функцию от пространственного угла на текущий угол</summary>
            <param name="f">Поворачиваемая функция</param>
            <typeparam name="T">Тип значения функции</typeparam>
            <returns>Функция, аргумент которой повёрнут на текущий угол</returns>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.In(MathCore.AngleType@)">
            <summary>Представить угол в указанном типе значения</summary>
            <param name="type">Тип требуемого значения угла</param>
            <returns></returns>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.Deconstruct(System.Double@,System.Double@)">
            <summary>Деконструктор значений угла</summary>
            <param name="theta">Угол места</param>
            <param name="phi">Угол азимута</param>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.Clone">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.op_UnaryNegation(MathCore.Vectors.SpaceAngle@)">
            <summary>Оператор отрицания значения пространственного угла</summary>
            <param name="a">Исходный пространственный угол</param>
            <returns>Пространственный угол у которого значения угла места и азимута имеют обратный знак по отношению к исходному значению</returns>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.op_ExclusiveOr(System.Func{MathCore.Vectors.SpaceAngle,System.Double},MathCore.Vectors.SpaceAngle@)">
            <summary>Оператор поворота функции на пространственный угол</summary>
            <param name="f">Вещественная пространственная функция</param>
            <param name="a">Пространственный угол поворота</param>
            <returns>Вещественная функция, аргумент которой повёрнут на указанный пространственный угол</returns>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.op_ExclusiveOr(System.Func{MathCore.Vectors.SpaceAngle,MathCore.Complex},MathCore.Vectors.SpaceAngle@)">
            <summary>Оператор поворота функции на пространственный угол</summary>
            <param name="f">Комплексная пространственная функция</param>
            <param name="a">Пространственный угол поворота</param>
            <returns>Комплексная функция, аргумент которой повёрнут на указанный пространственный угол</returns>
        </member>
        <member name="P:MathCore.Vectors.SpaceAngle.ComparisonsAccuracy">
            <summary>Точность сравнения (по умолчанию 10^-13)</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector`1.Equals(MathCore.Vectors.Vector{`0})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector`1.Clone">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector`1.System#ICloneable#Clone">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Vectors.Vector2DConverter">
            <summary>Конвертер для <see cref="T:MathCore.Vectors.Vector2D"/></summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2DConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Vectors.Vector2D">
            <summary>Двумерный вектор</summary>
        </member>
        <member name="F:MathCore.Vectors.Vector2D._X">
            <summary>Координата X</summary>
        </member>
        <member name="F:MathCore.Vectors.Vector2D._Y">
            <summary>Координата Y</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector2D.X">
            <summary>Координата X</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector2D.Y">
            <summary>Координата Y</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector2D.R">
            <summary>Радиус (длина) вектора</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector2D.Angle">
            <summary>Угол к оси X в радианах</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.#ctor(System.Double,System.Double)">
            <summary>Инициализация двумерного вектора</summary>
            <param name="X">Координата X</param>
            <param name="Y">Координата Y</param>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.#ctor(MathCore.Complex@)">
            <summary>Инициализация вектора по по комплексному числу</summary>
            <param name="Z">Комплексное число X + iY</param>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.InBasis(MathCore.Vectors.Basis2D@)">
            <summary>Представление вектора в базисе</summary>
            <param name="b">Базис</param>
            <returns>Вектор в базисе</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector2D.Clone">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector2D.System#ICloneable#Clone">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector2D.Equals(MathCore.Vectors.Vector2D)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector2D.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector2D.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector2D.Deconstruct(System.Double@,System.Double@)">
            <summary>Деконструктор вектора на его составляющие</summary>
            <param name="x">Координата X</param>
            <param name="y">Координата Y</param>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Equality(MathCore.Vectors.Vector2D@,MathCore.Vectors.Vector2D@)">
            <summary>Оператор равенства</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Inequality(MathCore.Vectors.Vector2D@,MathCore.Vectors.Vector2D@)">
            <summary>Оператор неравенства</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Explicit(MathCore.Vectors.Vector2D@)~MathCore.Complex">
            <summary>Оператор явного преобразования типа <see cref="T:MathCore.Vectors.Vector2D"/> в <see cref="T:MathCore.Complex"/></summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Explicit(MathCore.Complex@)~MathCore.Vectors.Vector2D">
            <summary>Оператор явного преобразования типа <see cref="T:MathCore.Complex"/> в <see cref="T:MathCore.Vectors.Vector2D"/></summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Implicit(System.Double)~MathCore.Vectors.Vector2D">
            <summary>Оператор неявного преобразования типа <see cref="T:System.Double"/> в <see cref="T:MathCore.Vectors.Vector2D"/> (вектор вдоль оси OX)</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_UnaryPlus(MathCore.Vectors.Vector2D@)">
            <summary>Унарный оператор +</summary>
            <returns>Вектор без изменения</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_UnaryNegation(MathCore.Vectors.Vector2D@)">
            <summary>Унарный оператор отрицания</summary>
            <returns>Вектор, координаты которого имеют противоположенный знак</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Addition(MathCore.Vectors.Vector2D@,MathCore.Vectors.Vector2D@)">
            <summary>Оператор вычисления суммы двух векторов</summary>
            <returns>Вектор, координаты которого составлены из суммы координат слагаемых</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Subtraction(MathCore.Vectors.Vector2D@,MathCore.Vectors.Vector2D@)">
            <summary>Оператор вычисления разности двух векторов</summary>
            <returns>Вектор, координаты которого составлены из разности координат слагаемых</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Multiply(MathCore.Vectors.Vector2D@,MathCore.Vectors.Vector2D@)">
            <summary>Оператор вычисления скалярного произведения двух векторов</summary>
            <returns>Вещественное число, равное суме попарных произведений координат векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Addition(MathCore.Vectors.Vector2D@,System.Double)">
            <summary>Оператор вычисления суммы вектора и вещественного числа</summary>
            <returns>Вектор, координаты которого увеличены на значение скалярного слагаемого</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Addition(System.Double,MathCore.Vectors.Vector2D@)">
            <summary>Оператор вычисления суммы вектора и вещественного числа</summary>
            <returns>Вектор, координаты которого увеличены на значение скалярного слагаемого</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Subtraction(MathCore.Vectors.Vector2D@,System.Double)">
            <summary>Оператор вычитания скалярного значения из вектора</summary>
            <param name="a">Уменьшаемое - вектор</param>
            <param name="b">Вычитаемое - скаляр</param>
            <returns>Вектор, координаты которого уменьшены на значение скаляра</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Subtraction(System.Double,MathCore.Vectors.Vector2D@)">
            <summary>Оператор вычитания вектора из скалярного значения</summary>
            <param name="b">Уменьшаемое - скаляр</param>
            <param name="a">вычитаемое - вектор</param>
            <returns>Вектор, координаты которого вычтены из скалярного значения</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Multiply(MathCore.Vectors.Vector2D@,System.Double)">
            <summary>Оператор умножения вектора на число</summary>
            <returns>Вектор, координаты которого умножены на скалярное значение</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Multiply(System.Double,MathCore.Vectors.Vector2D@)">
            <summary>Оператор умножения вектора на число</summary>
            <returns>Вектор, координаты которого умножены на скалярное значение</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Division(MathCore.Vectors.Vector2D@,System.Double)">
            <summary>Оператор деления вектора на число</summary>
            <returns>Вектор, координаты которого разделены на скалярное значение</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Division(System.Double,MathCore.Vectors.Vector2D@)">
            <summary>Оператор деления числа на вектор</summary>
            <returns>Вектор, координаты которого образованы делением координат числа на координаты исходного вектора</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_ExclusiveOr(MathCore.Vectors.Vector2D@,MathCore.Vectors.Vector2D@)">
            <summary>Оператор проекции в вектора на вектор</summary>
            <param name="a">Проецируемый вектор</param>
            <param name="b">Вектор проекции</param>
            <returns>Проекция первого вектора на второй</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_BitwiseOr(MathCore.Vectors.Vector2D@,MathCore.Vectors.Vector2D@)">
            <summary>Оператор проверки на параллельность двух векторов</summary>
            <returns>Истина, если вектора параллельны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_BitwiseAnd(MathCore.Vectors.Vector2D@,MathCore.Vectors.Vector2D@)">
            <summary>Оператор проверки на перпендикулярность двух векторов</summary>
            <returns>Истина, если вектора перпендикулярны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Modulus(MathCore.Vectors.Vector2D@,MathCore.Vectors.Vector2D@)">
            <summary>Оператор вычисления проекции вектора на вектор</summary>
            <param name="a">Проецируемый вектор</param>
            <param name="b">Вектор, на который осуществляется проекция</param>
            <returns>Длина проекции</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Modulus(MathCore.Vectors.Vector2D@,MathCore.Vectors.Basis2D@)">
            <summary>Оператор представление вектора в базисе</summary>
            <param name="a">Вектор, представляемый в базисе</param>
            <param name="b">Базис, в котором надо представить вектор</param>
            <returns>Вектор, представленный в базисе</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Addition(MathCore.Vectors.Vector2D@,System.Single)">
            <summary>Оператор суммы вектора и вещественного числа одинарной точности</summary>
            <returns>Вектор, координаты которого увеличены на значение числа одинарной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Subtraction(MathCore.Vectors.Vector2D@,System.Single)">
            <summary>Оператор разности вектора и вещественного числа одинарной точности</summary>
            <returns>Вектор, координаты которого уменьшены на значение числа одинарной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Multiply(MathCore.Vectors.Vector2D@,System.Single)">
            <summary>Оператор произведения вектора и вещественного числа одинарной точности</summary>
            <returns>Вектор, координаты которого умножены на значение числа одинарной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Division(MathCore.Vectors.Vector2D@,System.Single)">
            <summary>Оператор деления вектора и вещественного числа одинарной точности</summary>
            <returns>Вектор, координаты которого поделены на значение числа одинарной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Addition(System.Single,MathCore.Vectors.Vector2D@)">
            <summary>Оператор суммы вектора и вещественного числа одинарной точности</summary>
            <returns>Вектор, координаты которого увеличены на значение числа одинарной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Subtraction(System.Single,MathCore.Vectors.Vector2D@)">
            <summary>Оператор вещественного числа одинарной точности и разности вектора</summary>
            <returns>Вектор, координаты которого равны разности числа одинарной точности и координат исходного вектора</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Multiply(System.Single,MathCore.Vectors.Vector2D@)">
            <returns>Вектор, координаты которого умножены на значение числа одинарной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Division(System.Single,MathCore.Vectors.Vector2D@)">
            <summary>Оператор деления вещественного числа одинарной точности и вектора</summary>
            <returns>Вектор, координаты которого равны отношению числа одинарной точности и координат исходного вектора</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Addition(MathCore.Vectors.Vector2D@,System.Int32)">
            <summary>Оператор суммы вектора и вещественного целого числа</summary>
            <returns>Вектор, координаты которого увеличены на значение целого числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Subtraction(MathCore.Vectors.Vector2D@,System.Int32)">
            <summary>Оператор разности вектора и вещественного целого числа</summary>
            <returns>Вектор, координаты которого уменьшены на значение целого числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Multiply(MathCore.Vectors.Vector2D@,System.Int32)">
            <summary>Оператор произведения вектора и целого числа</summary>
            <returns>Вектор, координаты которого умножены на значение целого числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Division(MathCore.Vectors.Vector2D@,System.Int32)">
            <summary>Оператор деления вектора и целого числа</summary>
            <returns>Вектор, координаты которого поделены на значение целого числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Addition(System.Int32,MathCore.Vectors.Vector2D@)">
            <summary>Оператор произведения вектора и целого числа</summary>
            <returns>Вектор, координаты которого умножены на значение целого числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Subtraction(System.Int32,MathCore.Vectors.Vector2D@)">
            <summary>Оператор целого числа и разности вектора</summary>
            <returns>Вектор, координаты которого равны разности целого числа и координат исходного вектора</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Multiply(System.Int32,MathCore.Vectors.Vector2D@)">
            <summary>Оператор произведения вектора и целого числа</summary>
            <returns>Вектор, координаты которого умножены на значение целого числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Division(System.Int32,MathCore.Vectors.Vector2D@)">
            <summary>Оператор деления целого числа и вектора</summary>
            <returns>Вектор, координаты которого равны отношению целого числа и координат исходного вектора</returns>
        </member>
        <member name="T:MathCore.Vectors.Vector3DConverter">
            <summary>Конвертер для <see cref="T:MathCore.Vectors.Vector3D"/></summary>
        </member>
        <member name="M:MathCore.Vectors.Vector3DConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Vectors.Vector3D">
            <summary>Трёхмерный вектор</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.ThetaPhiRadius(System.Double,System.Double,System.Double)">
            <summary>Создать вектор по сферической системе координат</summary>
            <param name="Theta">Угол места</param>
            <param name="Phi">Азимут</param>
            <param name="R">Длина вектора</param>
            <returns>Трёхмерный вектор</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.XYZ(System.Double,System.Double,System.Double)">
            <summary>Преобразовать координаты декартовой системы в вектор</summary>
            <param name="X">Координата X</param>
            <param name="Y">Координата Y</param>
            <param name="Z">Координата Z</param>
            <returns>Вектор с заданными координатами</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.Random(System.Double,System.Double,System.Random)">
            <summary>Вектор со случайными координатами (с равномерным распределением)</summary>
            <param name="min">Минимальное значение</param>
            <param name="max">Максимальное значение</param>
            <param name="rnd">Генератор случайных чисел (если не задан, то будет создан новый)</param>
            <returns>Вектор со случайными значениями координат из указанного диапазона</returns>
        </member>
        <member name="F:MathCore.Vectors.Vector3D.k">
            <summary>Базисный вектор k</summary>
        </member>
        <member name="F:MathCore.Vectors.Vector3D.Empty">
            <summary>Вектор нулевой длины в начале координат</summary>
        </member>
        <member name="F:MathCore.Vectors.Vector3D.BasisUnitVector">
            <summary>Единичный базисный вектор</summary>
        </member>
        <member name="F:MathCore.Vectors.Vector3D.i">
            <summary>Базисный вектор i</summary>
        </member>
        <member name="F:MathCore.Vectors.Vector3D.j">
            <summary>Базисный вектор j</summary>
        </member>
        <member name="F:MathCore.Vectors.Vector3D._X">
            <summary>Длина по оси X</summary>
        </member>
        <member name="F:MathCore.Vectors.Vector3D._Y">
            <summary>Длина по оси Y</summary>
        </member>
        <member name="F:MathCore.Vectors.Vector3D._Z">
            <summary>Длина по оси Z</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.X">
            <summary>Длина по оси X</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.Y">
            <summary>Длина по оси Y</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.Z">
            <summary>Длина по оси Z</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.R">
            <summary>Длина вектора</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.AngleXOY">
            <summary>Угол проекции в плоскости XOY</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.AngleXOZ">
            <summary>Угол проекции в плоскости XOZ</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.AngleYOZ">
            <summary>Угол проекции в плоскости YOZ</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.Phi">
            <summary>Азимутальный угол</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.Theta">
            <summary>Угол места</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.Angle">
            <summary>Пространственный угол</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.VectorXOY">
            <summary>Двумерный вектор - проекция в плоскости XOY</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.VectorXOZ">
            <summary>Двумерный вектор - проекция в плоскости XOZ (X->X; Z->Y)</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.VectorYOZ">
            <summary>Двумерный вектор - проекция в плоскости YOZ (Y->X; Z->Y)</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.R_XOY">
            <summary>Длина в плоскости XOY</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.R_XOZ">
            <summary>Длина в плоскости XOZ</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.R_YOZ">
            <summary>Длина в плоскости YOZ</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.Abs">
            <summary>Длина вектора</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.Sign">
            <summary>Вектор знаков координат текущего вектора</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.#ctor(System.Double)">
            <summary>Инициализация нового вектора, расположенного вдоль оси OX</summary>
            <param name="X">Координата вдоль оси OX</param>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.#ctor(System.Double,System.Double)">
            <summary>Инициализация нового вектора, расположенного в плоскости XOY</summary>
            <param name="X">Координата вдоль оси OX</param>
            <param name="Y">Координата вдоль оси OY</param>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.#ctor(System.Double,System.Double,System.Double)">
            <summary>Инициализация нового вектора, заданного своими координатами</summary>
            <param name="X">Координата вдоль оси OX</param>
            <param name="Y">Координата вдоль оси OY</param>
            <param name="Z">Координата вдоль оси OZ</param>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.#ctor(MathCore.Vectors.SpaceAngle@)">
            <summary>Единичный вектор, заданный двумя углами в сферической системе координат</summary>
            <param name="Angle">Пространственный угол сферической системы координат</param>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.#ctor(System.Double,MathCore.Vectors.SpaceAngle@)">
            <summary>Вектор, заданный двумя углами и радиусом в сферической системе координат</summary>
            <param name="R">Радиус вектора</param>
            <param name="Angle">Пространственный угол сферической системы координат</param>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.#ctor(MathCore.Vectors.Vector3D@)">
            <summary>Конструктор копирования</summary>
            <param name="V">Вектор-прототип</param>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.InBasis(MathCore.Vectors.Basis3D@)">
            <summary>Представление вектора в базисе</summary>
            <param name="b">Новый базис вектора</param>
            <returns>Вектор в указанном базисе</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.Inc(System.Double,System.Double,System.Double)">
            <summary>Инкрементация координат вектора</summary>
            <param name="dx">Величина приращения координаты X</param>
            <param name="dy">Величина приращения координаты Y</param>
            <param name="dz">Величина приращения координаты Z</param>
            <returns>Вектор с новыми координатами</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.IncX(System.Double)">
            <summary>Инкрементировать координату X</summary>
            <param name="dx">Величина приращения координаты X</param>
            <returns>Вектор с обновлённой координатой X</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.IncY(System.Double)">
            <summary>Инкрементировать координату Y</summary>
            <param name="dy">Величина приращения координаты Y</param>
            <returns>Вектор с обновлённой координатой Y</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.IncZ(System.Double)">
            <summary>Инкрементировать координату Z</summary>
            <param name="dz">Величина приращения координаты Z</param>
            <returns>Вектор с обновлённой координатой Z</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.Dec(System.Double,System.Double,System.Double)">
            <summary>Декрементация координат вектора</summary>
            <param name="dx">Величина приращения координаты X</param>
            <param name="dy">Величина приращения координаты Y</param>
            <param name="dz">Величина приращения координаты Z</param>
            <returns>Вектор с новыми координатами</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.DecX(System.Double)">
            <summary>Декрементировать координату X</summary>
            <param name="dx">Величина приращения координаты X</param>
            <returns>Вектор с обновлённой координатой X</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.DecY(System.Double)">
            <summary>Декрементировать координату Y</summary>
            <param name="dy">Величина приращения координаты Y</param>
            <returns>Вектор с обновлённой координатой Y</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.DecZ(System.Double)">
            <summary>Декрементировать координату Z</summary>
            <param name="dz">Величина приращения координаты Z</param>
            <returns>Вектор с обновлённой координатой Z</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.Scale(System.Double,System.Double,System.Double)">
            <summary>Выполнить масштабирование вектора по координатам</summary>
            <param name="kx">Коэффициент масштабирования координаты X</param>
            <param name="ky">Коэффициент масштабирования координаты Y</param>
            <param name="kz">Коэффициент масштабирования координаты Z</param>
            <returns>Вектор, координаты которого умножены на соответствующие значения</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.ScaleX(System.Double)">
            <summary>Выполнить масштабирование вектора по оси OX</summary>
            <param name="kx">Коэффициент масштабирования координаты X</param>
            <returns>Вектор, координаты которого умножены на соответствующие значения</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.ScaleY(System.Double)">
            <summary>Выполнить масштабирование вектора по оси OY</summary>
            <param name="ky">Коэффициент масштабирования координаты Y</param>
            <returns>Вектор, координаты которого умножены на соответствующие значения</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.ScaleZ(System.Double)">
            <summary>Выполнить масштабирование вектора по оси OZ</summary>
            <param name="kz">Коэффициент масштабирования координаты Z</param>
            <returns>Вектор, координаты которого умножены на соответствующие значения</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector3D.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector3D.System#ICloneable#Clone">
            <summary>Создает новый объект, который является копией текущего экземпляра</summary>
            <returns>Новый объект, являющийся копией этого экземпляра</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.Clone">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector3D.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector3D.ToString(System.String)">
            <summary>Преобразование в строку с форматированием</summary>
            <param name="Format">Строка формата</param>
            <returns>Форматированное строковое представление</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.ToString(System.String,System.IFormatProvider)">
            <summary>Преобразование в строку с форматированием</summary>
            <param name="Format">Строка формата</param>
            <param name="Provider">Провайдер форматирования данных</param>
            <returns>Форматированное строковое представление</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.Deconstruct(System.Double@,System.Double@,System.Double@)">
            <summary>Деконструктор вектора на значения его координат</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.ComparisonsAccuracy">
            <summary>Точность сравнения (по умолчанию 10^-16)</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.Equals(MathCore.Vectors.Vector3D)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector3D.GetInverse">
            <summary>Получить вектор, координаты которого являются обратными к координатам текущего вектора</summary>
            <returns>Вектор с обратными координатами</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.Product_Scalar(MathCore.Vectors.Vector3D)">
            <summary>Скалярное произведение векторов</summary>
            <param name="Vector">Вектор, на который умножается текущий вектор</param>
            <returns>Число, равное скалярному произведению векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.Product_Mixed(MathCore.Vectors.Vector3D,MathCore.Vectors.Vector3D,MathCore.Vectors.Vector3D)">
            <summary>Смешанное произведение трёх векторов</summary>
            <param name="A">Первый вектор произведения</param>
            <param name="B">Второй вектор произведения</param>
            <param name="C">Третий вектор произведения</param>
            <returns>Число, равное смешанному произведения векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.Product_Vector(MathCore.Vectors.Vector3D)">
            <summary>Векторное произведение векторов</summary>
            <param name="Vector">Вектор, на который умножается исходный вектор</param>
            <returns>Вектор, равный векторному произведению векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.Product_Component(MathCore.Vectors.Vector3D)">
            <summary>Покомпонентное умножение на вектор</summary>
            <param name="Vector">Векторный сомножитель</param>
            <returns>Вектор, компоненты которого являются произведениями компоненты векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.GetAngle(MathCore.Vectors.Vector3D)">
            <summary>Угол между векторами</summary>
            <param name="Vector">Вектор, к которому вычисляется угол</param>
            <returns>Пространственный угол между векторами</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.GetProjectionTo(MathCore.Vectors.Vector3D)">
            <summary>Проекция на вектор</summary>
            <param name="Vector">Вектор, НА который производится проекции</param>
            <returns>Проекция на вектор</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.GetProjectorV">
            <summary>Проекцию текущего вектора на вектор</summary>
            <returns>Функция, вычисляющая проекцию текущего вектора на вектор</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.GetProjectorV_Expression(System.Linq.Expressions.Expression)">
            <summary>Проекция текущего вектора на вектор, передаваемый в качестве параметра</summary>
            <param name="v">Выражение, результатом вычисления которого является <see cref="T:MathCore.Vectors.Vector3D"/></param>
            <returns>Выражение, вычисляющее проекцию текущего вектора на вектор, передаваемый в параметре функции</returns>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка</exception>
            <exception cref="T:System.ArgumentException">Если тип результата <paramref name="v"/> не является <see cref="T:MathCore.Vectors.Vector3D"/></exception>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.GetProjectionTo(MathCore.Vectors.SpaceAngle)">
            <summary>Проекция на направление</summary>
            <param name="Direction">Направление, на которое проектируется вектор</param>
            <returns>Проекция вектора на направление</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.GetProjectorA">
            <summary>Проекцию текущего вектора на угол</summary>
            <returns>Функция, вычисляющая проекцию текущего вектора на угол</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.GetProjectorA_Expression(System.Linq.Expressions.Expression)">
            <summary>Создать выражение проекции вектора на пространственный угол</summary>
            <param name="d">Выражение, результатом вычисления которого будет объект <see cref="T:MathCore.Vectors.SpaceAngle"/></param>
            <returns>Выражение проекции вектора на угол</returns>
            <exception cref="T:System.ArgumentNullException">Если <paramref name="d"/> <see langword="=="/> <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Если тип выражения <paramref name="d"/> является не <see cref="T:MathCore.Vectors.SpaceAngle"/></exception>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Addition(MathCore.Vectors.Vector3D,System.Double)">
            <summary>Оператор суммы вектора и числа</summary>
            <returns>Вектор, координаты которого увеличены на значения числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Addition(System.Double,MathCore.Vectors.Vector3D)">
            <summary>Оператор суммы вектора и числа</summary>
            <returns>Вектор, координаты которого увеличены на значения числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Subtraction(MathCore.Vectors.Vector3D,System.Double)">
            <summary>Оператор разности вектора и числа</summary>
            <returns>Вектор, координаты которого уменьшены на значения числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Subtraction(System.Double,MathCore.Vectors.Vector3D)">
            <summary>Оператор суммы числа и вектора</summary>
            <returns>Вектор, координаты которого равны разности числа и координат исходного вектора</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Multiply(MathCore.Vectors.Vector3D,System.Double)">
            <summary>Оператор произведения вектора и числа</summary>
            <returns>Вектор, координаты которого умножены на значения числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Multiply(System.Double,MathCore.Vectors.Vector3D)">
            <summary>Оператор произведения вектора и числа</summary>
            <returns>Вектор, координаты которого умножены на значения числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Division(MathCore.Vectors.Vector3D,System.Double)">
            <summary>Оператор деления вектора на число</summary>
            <returns>Вектор, координаты которого разделены на значения числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Division(System.Double,MathCore.Vectors.Vector3D)">
            <summary>Оператор деления числа на вектор</summary>
            <returns>Вектор, координаты которого являются результатом деления числа на координаты исходного вектора</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Addition(MathCore.Vectors.Vector3D,System.Single)">
            <summary>Оператор суммы вектора и числа одинарной точности</summary>
            <returns>Вектор, координаты которого увеличены на значения числа одинарной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Addition(System.Single,MathCore.Vectors.Vector3D)">
            <summary>Оператор суммы вектора и числа одинарной точности</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Subtraction(MathCore.Vectors.Vector3D,System.Single)">
            <summary>Оператор разности вектора и числа одинарной точности</summary>
            <returns>Вектор, координаты которого уменьшены на значения числа одинарной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Subtraction(System.Single,MathCore.Vectors.Vector3D)">
            <summary>Оператор суммы числа одинарной точности и вектора</summary>
            <returns>Вектор, координаты которого равны разности числа одинарной точности и координат исходного вектора</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Multiply(MathCore.Vectors.Vector3D,System.Single)">
            <summary>Оператор произведения вектора и числа одинарной точности</summary>
            <returns>Вектор, координаты которого умножены на значения числа одинарной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Multiply(System.Single,MathCore.Vectors.Vector3D)">
            <summary>Оператор произведения вектора и числа одинарной точности</summary>
            <returns>Вектор, координаты которого умножены на значения числа одинарной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Division(MathCore.Vectors.Vector3D,System.Single)">
            <summary>Оператор деления вектора на число одинарной точности</summary>
            <returns>Вектор, координаты которого разделены на значения числа одинарной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Division(System.Single,MathCore.Vectors.Vector3D)">
            <summary>Оператор деления числа одинарной точности на вектор</summary>
            <returns>Вектор, координаты которого являются результатом деления числа одинарной точности на координаты исходного вектора</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Addition(MathCore.Vectors.Vector3D,System.Int32)">
            <summary>Оператор суммы вектора и целого числа</summary>
            <returns>Вектор, координаты которого увеличены на значения целого числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Addition(System.Int32,MathCore.Vectors.Vector3D)">
            <summary>Оператор суммы вектора и целого числа</summary>
            <returns>Вектор, координаты которого увеличены на значения целого числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Subtraction(MathCore.Vectors.Vector3D,System.Int32)">
            <summary>Оператор разности вектора и целого числа</summary>
            <returns>Вектор, координаты которого уменьшены на значения целого числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Subtraction(System.Int32,MathCore.Vectors.Vector3D)">
            <summary>Оператор суммы целого числа и вектора</summary>
            <returns>Вектор, координаты которого равны разности целого числа и координат исходного вектора</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Multiply(MathCore.Vectors.Vector3D,System.Int32)">
            <summary>Оператор произведения вектора и целого числа</summary>
            <returns>Вектор, координаты которого умножены на значения целого числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Multiply(System.Int32,MathCore.Vectors.Vector3D)">
            <summary>Оператор произведения вектора и целого числа</summary>
            <returns>Вектор, координаты которого умножены на значения целого числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Division(MathCore.Vectors.Vector3D,System.Int32)">
            <summary>Оператор деления вектора на целое число</summary>
            <returns>Вектор, координаты которого разделены на значения целое числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Division(System.Int32,MathCore.Vectors.Vector3D)">
            <summary>Оператор деления целого числа на вектор</summary>
            <returns>Вектор, координаты которого являются результатом деления целого числа на координаты исходного вектора</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Equality(MathCore.Vectors.Vector3D,MathCore.Vectors.Vector3D)">
            <summary>Оператор проверки равенства двух векторов</summary>
            <returns>Истина, если координаты векторов равны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Inequality(MathCore.Vectors.Vector3D,MathCore.Vectors.Vector3D)">
            <summary>Оператор проверки неравенства двух векторов</summary>
            <returns>Истина, если координаты векторов неравны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Equality(MathCore.Vectors.Vector3D,System.Byte)">
            <summary>Оператор проверки равенства вектора и целого числа (1 байт)</summary>
            <returns>Истина, если длина вектора равна указанному целому числу (1 байт)</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Equality(MathCore.Vectors.Vector3D,System.SByte)">
            <summary>Оператор проверки равенства вектора и целого числа (1 байт со знаком)</summary>
            <returns>Истина, если длина вектора равна указанному целому числу (1 байт со знаком)</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Equality(MathCore.Vectors.Vector3D,System.Int16)">
            <summary>Оператор проверки равенства вектора и целого числа (2 байта со знаком)</summary>
            <returns>Истина, если длина вектора равна указанному целому числу (2 байта со знаком)</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Equality(MathCore.Vectors.Vector3D,System.UInt16)">
            <summary>Оператор проверки равенства вектора и целого числа (2 байта без знака)</summary>
            <returns>Истина, если длина вектора равна указанному целому числу (2 байта без знака)</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Equality(MathCore.Vectors.Vector3D,System.Int32)">
            <summary>Оператор проверки равенства вектора и целого числа</summary>
            <returns>Истина, если длина вектора равна указанному целому числу</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Equality(MathCore.Vectors.Vector3D,System.UInt32)">
            <summary>Оператор проверки равенства вектора и целого числа без знака</summary>
            <returns>Истина, если длина вектора равна указанному целому числу без знака</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Equality(MathCore.Vectors.Vector3D,System.Int64)">
            <summary>Оператор проверки равенства вектора и целого числа (8 байт со знаком)</summary>
            <returns>Истина, если длина вектора равна указанному целому числу (8 байт со знаком)</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Equality(MathCore.Vectors.Vector3D,System.UInt64)">
            <summary>Оператор проверки равенства вектора и целого числа (8 байт без знака)</summary>
            <returns>Истина, если длина вектора равна указанному целому числу (8 байт без знака)</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Equality(MathCore.Vectors.Vector3D,System.Single)">
            <summary>Оператор проверки равенства вектора и числа одинарной точности</summary>
            <returns>Истина, если длина вектора равна указанному числу одинарной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Equality(MathCore.Vectors.Vector3D,System.Double)">
            <summary>Оператор проверки равенства вектора и числа двойной точности</summary>
            <returns>Истина, если длина вектора равна указанному числу двойной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Inequality(MathCore.Vectors.Vector3D,System.Byte)">
            <summary>Оператор проверки неравенства вектора и целого числа (1 байт без знака)</summary>
            <returns>Истина, если длина вектора не равна целому числу (1 байт без знака)</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Inequality(MathCore.Vectors.Vector3D,System.SByte)">
            <summary>Оператор проверки неравенства вектора и целого числа (1 байт со знаком)</summary>
            <returns>Истина, если длина вектора не равна целому числу (1 байт со знаком)</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Inequality(MathCore.Vectors.Vector3D,System.Int16)">
            <summary>Оператор проверки неравенства вектора и целого числа (2 байта со знаком)</summary>
            <returns>Истина, если длина вектора не равна целому числу (2 байта со знаком)</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Inequality(MathCore.Vectors.Vector3D,System.UInt16)">
            <summary>Оператор проверки неравенства вектора и целого числа (2 байта без знака)</summary>
            <returns>Истина, если длина вектора не равна целому числу (2 байта без знака)</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Inequality(MathCore.Vectors.Vector3D,System.Int32)">
            <summary>Оператор проверки неравенства вектора и целого числа</summary>
            <returns>Истина, если длина вектора не равна целому числу</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Inequality(MathCore.Vectors.Vector3D,System.UInt32)">
            <summary>Оператор проверки неравенства вектора и целого числа</summary>
            <returns>Истина, если длина вектора не равна целому числу</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Inequality(MathCore.Vectors.Vector3D,System.Int64)">
            <summary>Оператор проверки неравенства вектора и целого числа (8 байт со знаком)</summary>
            <returns>Истина, если длина вектора не равна целому числу (8 байт со знаком)</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Inequality(MathCore.Vectors.Vector3D,System.UInt64)">
            <summary>Оператор проверки неравенства вектора и целого числа (8 байт без знака)</summary>
            <returns>Истина, если длина вектора не равна целому числу (8 байт без знака)</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Inequality(MathCore.Vectors.Vector3D,System.Single)">
            <summary>Оператор проверки неравенства вектора и вещественного числа одинарной точности</summary>
            <returns>Истина, если длина вектора не равна вещественному числу одинарной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Inequality(MathCore.Vectors.Vector3D,System.Double)">
            <summary>Оператор проверки неравенства вектора и вещественного числа двойной точности</summary>
            <returns>Истина, если длина вектора не равна вещественному числу двойной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Addition(MathCore.Vectors.Vector3D,MathCore.Vectors.Vector3D)">
            <summary>Оператор суммы двух векторов</summary>
            <returns>Вектор, координаты которого равны сумме координат двух исходных векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Subtraction(MathCore.Vectors.Vector3D,MathCore.Vectors.Vector3D)">
            <summary>Оператор разности двух векторов</summary>
            <returns>Вектор, координаты которого равны разности координат двух исходных векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Multiply(MathCore.Vectors.Vector3D,MathCore.Vectors.Vector3D)">
            <summary>Скалярное произведение векторов</summary>
            <param name="A">Первый вектор-множитель</param>
            <param name="B">Второй вектор-множитель</param>
            <returns>Число - скалярное произведение векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_ExclusiveOr(MathCore.Vectors.Vector3D,MathCore.Vectors.Vector3D)">
            <summary>Угол между векторами</summary>
            <param name="A">Вектор 1</param>
            <param name="B">Вектор 2</param>
            <returns>Угол между вектором А и вектором В в пространстве</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_BitwiseOr(MathCore.Vectors.Vector3D,MathCore.Vectors.Vector3D)">
            <summary>Проверка на параллельность</summary>
            <param name="A">Вектор 1</param><param name="B">Вектор 2</param>
            <returns>Истина, если вектора параллельны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_BitwiseAnd(MathCore.Vectors.Vector3D,MathCore.Vectors.Vector3D)">
            <summary>Проверка на ортогональность</summary>
            <param name="A">Вектор 1</param><param name="B">Вектор 2</param>
            <returns>Истина, если вектор 1 ортогонален вектору 2</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Modulus(MathCore.Vectors.Vector3D,MathCore.Vectors.Vector3D)">
            <summary>Проекция вектора A на вектор B</summary>
            <param name="A">Проецируемый вектор</param>
            <param name="B">Вектор, на который производится проекции</param>
            <returns>Проекция вектора А на вектор В</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Modulus(MathCore.Vectors.Vector3D,MathCore.Vectors.SpaceAngle)">
            <summary>Проекция вектора на направление</summary>
            <param name="Vector">Проецируемый вектор</param>
            <param name="Direction">Пространственный угол направления проекции</param>
            <returns>Вещественное значение проекции</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Modulus(MathCore.Vectors.Vector3D,MathCore.Vectors.Basis3D)">
            <summary>Оператор представления вектора в базисе</summary>
            <returns>Вектор, представленный в базисе</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Implicit(MathCore.Vectors.Vector3D)~System.Double">
            <summary>Оператор неявного приведения <see cref="T:MathCore.Vectors.Vector3D"/> к <see cref="T:System.Double"/>, результатом которого является длина вектора</summary>
            <param name="V">Трёхмерный вектор</param>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Implicit(MathCore.Vectors.Vector3D)~MathCore.Vectors.SpaceAngle">
            <summary>Оператор неявного приведения <see cref="T:MathCore.Vectors.Vector3D"/> к <see cref="T:MathCore.Vectors.SpaceAngle"/></summary>
            <param name="V">Трёхмерный вектор</param>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Explicit(MathCore.Vectors.SpaceAngle)~MathCore.Vectors.Vector3D">
            <summary>Оператор неявного приведения <see cref="T:MathCore.Vectors.SpaceAngle"/> к <see cref="T:MathCore.Vectors.Vector3D"/>, результатом которого является единичный вектор, ориентированный в пространстве</summary>
            <param name="Angle">Пространственный угол</param>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Explicit(System.Double)~MathCore.Vectors.Vector3D">
            <summary>Оператор явного приведения типа <see cref="T:System.Double"/> к <see cref="T:MathCore.Vectors.Vector3D"/>, результатом которого является вектор, с равными координатами, длина которого равна указанному числу</summary>
            <param name="V">Длина вектора</param>
        </member>
        <member name="T:MathCore.ViewModels.ViewModel">
            <summary>Наблюдаемая модель</summary>
        </member>
        <member name="E:MathCore.ViewModels.ViewModel.PropertyChanging">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.OnPropertyChanging``1(``0@,``0@,System.String@)">
            <summary>Генерация события находящегося в процессе изменения значения свойства</summary>
            <param name="OldValue">Предыдущее значение свойства</param>
            <param name="NewValue">Новое значение свойства</param>
            <param name="PropertyName">Имя изменившегося свойства (если не указано, то берётся имя вызывающего метода)</param>
            <typeparam name="T">Тип значения свойства</typeparam>
            <returns>Истина, если событие было обработано и новое значение свойства не равно старому</returns>
        </member>
        <member name="E:MathCore.ViewModels.ViewModel.PropertyChanged">
            <summary>Событие возникает когда изменяется значение свойства объекта</summary>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.PropertyChanged_AddHandler(System.ComponentModel.PropertyChangedEventHandler@)">
            <summary>Присоединить обработчик события <see cref="E:MathCore.ViewModels.ViewModel.PropertyChanged"/></summary>
            <param name="handler">Присоединяемый обработчик события <see cref="E:MathCore.ViewModels.ViewModel.PropertyChanged"/></param>
        </member>
        <member name="F:MathCore.ViewModels.ViewModel._PropertyChangedHandlers">
            <summary>Словарь обработчиков событий изменений свойств</summary>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.PropertyChanged_AddHandler(System.String@,System.Action@)">
            <summary>Добавление обработчика события изменения свойства</summary>
            <param name="PropertyName">Имя отслеживаемого события</param>
            <param name="handler">Устанавливаемый обработчик</param>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.PropertyChanged_RemoveHandler(System.String@,System.Action@)">
            <summary>Извлечение обработчика события изменения указанного свойства</summary>
            <param name="PropertyName">Имя отслеживаемого свойства</param>
            <param name="handler">Извлекаемый обработчик события</param>
            <returns>Истина, если обработчик события удалён успешно</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.PropertyChanged_ClearHandlers(System.String@)">
            <summary>Очистка обработчиков изменений свойства</summary>
            <returns>Истина, если очистка произведена успешно</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.PropertyChanged_ClearHandlers">
            <summary>Очистка обработчиков изменений всех свойств</summary>
            <returns>Истина, если очистка произведена успешно</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.PropertyChanged_RemoveHandler(System.ComponentModel.PropertyChangedEventHandler@)">
            <summary>Отсоединить обработчик события <see cref="E:MathCore.ViewModels.ViewModel.PropertyChanged"/></summary>
            <param name="handler">Отсоединяемый обработчик события <see cref="E:MathCore.ViewModels.ViewModel.PropertyChanged"/></param>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.GetPropertyChangedObservers``1">
            <summary>Получить перечисление всех объектов, подписанных на событие <see cref="E:MathCore.ViewModels.ViewModel.PropertyChanged"/></summary>
            <typeparam name="T">Тип интересующих объектов</typeparam>
            <returns>Перечисление объектов-подписчиков события <see cref="E:MathCore.ViewModels.ViewModel.PropertyChanged"/></returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.GetPropertyChangedObserversMethods">
            <summary>Получить перечисление всех методов, подписанных на событие <see cref="E:MathCore.ViewModels.ViewModel.PropertyChanged"/></summary>
            <returns>Перечисление всех методов-подписчиков события <see cref="E:MathCore.ViewModels.ViewModel.PropertyChanged"/></returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.GetPropertyChangedObserversMethods``1">
            <summary>Получить перечисление всех методов, подписанных на событие <see cref="E:MathCore.ViewModels.ViewModel.PropertyChanged"/></summary>
            <typeparam name="T">Тип интересующих объектов</typeparam>
            <returns>Перечисление всех методов-подписчиков события <see cref="E:MathCore.ViewModels.ViewModel.PropertyChanged"/> для объекта типа <typeparamref name="T"/></returns>
        </member>
        <member name="F:MathCore.ViewModels.ViewModel._PropertiesDependenciesDictionary">
            <summary>Словарь графа зависимости изменений свойств</summary>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.PropertyDependence_Add(System.String,System.String[])">
            <summary>Добавить зависимости между свойствами</summary>
            <param name="PropertyName">Имя исходного свойства</param>
            <param name="Dependencies">Перечисление свойств, на которые исходное свойство имеет влияние</param>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.IsLoopDependency(System.String@,System.String@,System.String@,System.Collections.Generic.Stack{System.String})">
            <summary>Проверка модели на циклические зависимости между свойствами</summary>
            <param name="property">Проверяемое свойство</param>
            <param name="dependency">Зависимость</param>
            <param name="next_property">Следующее свойство в цепочке зависимости</param>
            <param name="invoke_stack">Стек вызова свойств</param>
            <returns>Истина, если найден цикл</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.PropertyDependencies_Remove(System.String@,System.String@)">
            <summary>Удаление зависимости между свойствами</summary>
            <param name="PropertyName">Исходное свойство</param>
            <param name="Dependence">Свойство, связь с которым надо разорвать</param>
            <returns>Истина, если связь успешно удалена, ложь - если связь отсутствовала</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.PropertyDependencies_Clear(System.String@)">
            <summary>Очистить граф зависимостей между свойствами для указанного свойства</summary>
            <param name="PropertyName">Название свойства, связи которого нао удалить</param>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.OnPropertyChanged(System.String)">
            <summary>Метод генерации события изменения значения свойства</summary>
            <param name="PropertyName">Имя изменившегося свойства</param>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.OnPropertyChanged_Simple(System.String@)">
            <summary>Ускоренная генерация события изменения свойства</summary>
            <param name="PropertyName">Имя изменившегося свойства</param>
        </member>
        <member name="F:MathCore.ViewModels.ViewModel._PropertyAsyncInvokeTime">
            <summary>Словарь, хранящий время последней генерации события изменения указанного свойства в асинхронном режиме</summary>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.OnPropertyChangedAsync(System.String,System.Int32,System.Action,System.Action)">
            <summary>Асинхронная генерация события изменения свойства с возможностью указания таймаута ожидания повторных изменений</summary>
            <param name="PropertyName">Имя свойства</param>
            <param name="Timeout">Таймаут ожидания повторных изменений, прежде чем событие будет сгенерировано</param>
            <param name="OnChanging">Метод, выполняемый до генерации события</param>
            <param name="OnChanged">Метод, выполняемый после генерации события</param>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.#ctor(System.Boolean)">
            <summary>Инициализация новой view-модели</summary>
            <param name="check_dependencies">Создавать карту зависимостей на основе атрибутов</param>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.Dispose">
            <inheritdoc />
        </member>
        <member name="F:MathCore.ViewModels.ViewModel._Disposed">
            <summary>Признак того, что объект уже уничтожен</summary>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.Dispose(System.Boolean)">
            <summary>Освобождение ресурсов</summary>
            <param name="disposing">Если истина, то требуется освободить управляемые объекты. Освободить неуправляемые объекты в любом случае</param>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.DisposeManagedObject">
            <summary>Освободить управляемые объекты</summary>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.DisposeUnmanagedObject">
            <summary>Освободить неуправляемые объекты</summary>
        </member>
        <member name="T:MathCore.ViewModels.ViewModel.PropertyChangingEventArgs`1">
            <summary>Аргумент события процесса изменения значения свойства</summary>
            <typeparam name="T">Тип значения свойства</typeparam>
        </member>
        <member name="F:MathCore.ViewModels.ViewModel.PropertyChangingEventArgs`1._OldValue">
            <summary>Предыдущее значение свойства</summary>
        </member>
        <member name="F:MathCore.ViewModels.ViewModel.PropertyChangingEventArgs`1._NewValue">
            <summary>Новое значение свойства</summary>
        </member>
        <member name="P:MathCore.ViewModels.ViewModel.PropertyChangingEventArgs`1.OldValue">
            <summary>Предыдущее значение свойства</summary>
        </member>
        <member name="P:MathCore.ViewModels.ViewModel.PropertyChangingEventArgs`1.NewValue">
            <summary>Новое значение свойства (которое может быть изменено)</summary>
        </member>
        <member name="P:MathCore.ViewModels.ViewModel.PropertyChangingEventArgs`1.IsChangingValue">
            <summary>Признак того, что новое значение свойства отличается от старого</summary>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.PropertyChangingEventArgs`1.#ctor(`0@,`0@,System.String@)">
            <summary>Инициализация нового экземпляра <see cref="T:System.ComponentModel.PropertyChangingEventArgs"/></summary>
            <param name="OldValue">Предыдущее значение свойства</param>
            <param name="NewValue">Новое значение свойства</param>
            <param name="PropertyName">Имя изменяющегося свойства</param>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.PropertyChangingEventArgs`1.Set(`0@)">
            <summary>Установить новое значение свойства</summary>
            <param name="Value">Новое значение свойства</param>
            <returns>Истина, если новое значение свойства отличается от старого</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.Set``1(``0@,``0,System.String@)">
            <summary>Установить значение поля модели, в котором хранится значение изменяющегося свойства</summary>
            <typeparam name="T">Тип значения поля</typeparam>
            <param name="field">Ссылка на поле модели</param>
            <param name="value">Значение, устанавливаемое для поля</param>
            <param name="PropertyName">Имя метода, вызывавшего обновление. По умолчанию должно быть равно пустоте</param>
            <returns>Истина, если метод изменил значение поля и вызвал событие <see cref="E:MathCore.ViewModels.ViewModel.PropertyChanged"/></returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.Set``1(``0@,``0@,System.Func{``0,System.Boolean}@,System.String@)">
            <summary>Установить значение поля модели, в котором хранится значение изменяющегося свойства</summary>
            <typeparam name="T">Тип значения поля</typeparam>
            <param name="field">Ссылка на поле модели</param>
            <param name="value">Значение, устанавливаемое для поля</param>
            <param name="ValueChecker">Метод определения области допустимых значений (должен вернуть истину для корректного значения)</param>
            <param name="PropertyName">Имя метода, вызывавшего обновление. По умолчанию должно быть равно пустоте</param>
            <returns>Истина, если метод изменил значение поля и вызвал событие <see cref="E:MathCore.ViewModels.ViewModel.PropertyChanged"/></returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.Set``1(``0@,``0@,System.String@,System.Func{``0,System.Boolean}@,System.String@)">
            <summary>Установить значение поля модели, в котором хранится значение изменяющегося свойства</summary>
            <typeparam name="T">Тип значения поля</typeparam>
            <param name="field">Ссылка на поле модели</param>
            <param name="value">Значение, устанавливаемое для поля</param>
            <param name="ErrorMessage">Сообщение, записываемое в генерируемое исключение <see cref="T:System.ArgumentOutOfRangeException"/> в случае если проверка <paramref name="Validator"/> не пройдена</param>
            <param name="Validator">Метод определения области допустимых значений (должен вернуть истину для корректного значения)</param>
            <param name="PropertyName">Имя метода, вызывавшего обновление. По умолчанию должно быть равно пустоте</param>
            <returns>Истина, если метод изменил значение поля и вызвал событие <see cref="E:MathCore.ViewModels.ViewModel.PropertyChanged"/></returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.Set``1(``0@,``0@,System.Action{System.String}@,System.String@)">
            <summary>Метод установки значения свойства, осуществляющий генерацию события изменения свойства</summary>
            <typeparam name="T">Тип значения свойства</typeparam>
            <param name="field">Ссылка на поле, хранящее значение свойства</param>
            <param name="value">Значение свойства, которое надо установить</param>
            <param name="OnPropertyChanged">Действие, выполняемое для извещения об изменении свойства</param>
            <param name="PropertyName">Имя свойства</param>
            <returns>Истина, если значение свойства установлено успешно</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.Set``1(``0@,``0@,System.Action{System.String}@,System.Func{``0,System.Boolean}@,System.String@)">
            <summary>Метод установки значения свойства, осуществляющий генерацию события изменения свойства</summary>
            <typeparam name="T">Тип значения свойства</typeparam>
            <param name="field">Ссылка на поле, хранящее значение свойства</param>
            <param name="value">Значение свойства, которое надо установить</param>
            <param name="OnPropertyChanged">Действие, выполняемое для извещения об изменении свойства</param>
            <param name="Validator">Метод определения области допустимых значений (должен вернуть истину для корректного значения)</param>
            <param name="PropertyName">Имя свойства</param>
            <returns>Истина, если значение свойства установлено успешно</returns>
        </member>
        <member name="T:MathCore.ViewModels.ViewModel.SetStaticValueResult`1">
            <summary>Объект, отвечающий за управление процессом установки значения свойства при статическом вызове метода Set</summary>
            <typeparam name="T">Тип значения свойства</typeparam>
        </member>
        <member name="F:MathCore.ViewModels.ViewModel.SetStaticValueResult`1._Result">
            <summary>Было ли значение свойства обновлено</summary>
        </member>
        <member name="F:MathCore.ViewModels.ViewModel.SetStaticValueResult`1._OldValue">
            <summary>Прежнее значение свойства</summary>
        </member>
        <member name="F:MathCore.ViewModels.ViewModel.SetStaticValueResult`1._NewValue">
            <summary>Новое значение свойства</summary>
        </member>
        <member name="F:MathCore.ViewModels.ViewModel.SetStaticValueResult`1._OnPropertyChanged">
            <summary>Действие по генерации события обновления свойства - делегат <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></summary>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.#ctor(System.Boolean,`0@,System.Action{System.String}@)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ViewModels.ViewModel.SetStaticValueResult`1"/></summary>
            <param name="Result">Было ли значение свойства обновлено</param>
            <param name="OldValue">Прежнее значение свойства</param>
            <param name="OnPropertyChanged">Действие по генерации события обновления свойства - делегат <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></param>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.#ctor(System.Boolean,`0@,`0@,System.Action{System.String}@)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ViewModels.ViewModel.SetStaticValueResult`1"/></summary>
            <param name="Result">Было ли значение свойства обновлено</param>
            <param name="OldValue">Прежнее значение свойства</param>
            <param name="NewValue">Новое значение свойства</param>
            <param name="OnPropertyChanged">Действие по генерации события обновления свойства - делегат <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></param>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.Then(System.Action@)">
            <summary>В случае если значение свойства было изменено вызывать указанное действие</summary>
            <param name="execute">Действие, выполняемое в случае обновления значения свойства</param>
            <returns>Признак того, что свойство изменило своё значение</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.Then(System.Action{`0}@)">
            <summary>В случае если значение свойства было изменено вызывать указанное действие над новым значением</summary>
            <param name="execute">Действие над новым значением, выполняемое в случае обновления значения свойства</param>
            <returns>Признак того, что свойство изменило своё значение</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.Then(System.Action{`0,`0}@)">
            <summary>В случае если значение свойства было изменено вызывать указанное действие над старым и новым значением</summary>
            <param name="execute">Действие над старым и новым значением, выполняемое в случае обновления значения свойства</param>
            <returns>Признак того, что свойство изменило своё значение</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.Update(System.String@)">
            <summary>Выполнить генерацию события изменения указанного свойства, если значение текущего свойства изменилось</summary>
            <param name="PropertyName">Имя обновившегося связанного свойства</param>
            <returns>Текущий объект <see cref="T:MathCore.ViewModels.ViewModel.SetStaticValueResult`1"/></returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.AnywayUpdate(System.String@)">
            <summary>Выполнить генерацию события изменения указанного свойства даже если значение свойства не изменилось</summary>
            <param name="PropertyName">Имя обновившегося связанного свойства</param>
            <returns>Текущий объект <see cref="T:MathCore.ViewModels.ViewModel.SetStaticValueResult`1"/></returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.Update(System.String[])">
            <summary>Выполнить генерацию события изменения указанного набора свойств, если значение текущего свойства изменилось</summary>
            <param name="PropertyName">Имена обновившихся связанных свойства</param>
            <returns>Текущий объект <see cref="T:MathCore.ViewModels.ViewModel.SetStaticValueResult`1"/></returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.AnywayUpdate(System.String[])">
            <summary>Выполнить генерацию события изменения указанного набора свойств даже если значение свойства не изменилось</summary>
            <param name="PropertyName">Имена обновившихся связанных свойства</param>
            <returns>Текущий объект <see cref="T:MathCore.ViewModels.ViewModel.SetStaticValueResult`1"/></returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.AnywayThen(System.Action@)">
            <summary>Выполнить указанное действие даже в случае если значение свойства не изменилось</summary>
            <param name="execute">Выполняемое действие</param>
            <returns>Истина, если значение свойства изменилось</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.AnywayThen(System.Action{System.Boolean}@)">
            <summary>Выполнить указанное действие с признаком обновления свойства даже в случае если значение свойства не изменилось</summary>
            <param name="execute">Выполняемое действие с признаком обновления свойства</param>
            <returns>Истина, если значение свойства изменилось</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.AnywayThen(System.Action{`0}@)">
            <summary>Выполнить указанное действие над новым значением свойства даже в случае если значение свойства не изменилось</summary>
            <param name="execute">Выполняемое действие над новым значением свойства</param>
            <returns>Истина, если значение свойства изменилось</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.AnywayThen(System.Action{`0,System.Boolean}@)">
            <summary>Выполнить указанное действие над новым значением и признаком изменения свойства даже в случае если значение свойства не изменилось</summary>
            <param name="execute">Выполняемое действие над новым значением и признаком изменения свойства</param>
            <returns>Истина, если значение свойства изменилось</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.AnywayThen(System.Action{`0,`0}@)">
            <summary>Выполнить указанное действие над старым и новым значением свойства даже в случае если значение свойства не изменилось</summary>
            <param name="execute">Выполняемое действие над старым и новым значением свойства</param>
            <returns>Истина, если значение свойства изменилось</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.AnywayThen(System.Action{`0,`0,System.Boolean}@)">
            <summary>Выполнить указанное действие над старым, новым значением и признаком изменения свойства даже в случае если значение свойства не изменилось</summary>
            <param name="execute">Выполняемое действие над старым, новым значением и признаком изменения свойства</param>
            <returns>Истина, если значение свойства изменилось</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.Equals(MathCore.ViewModels.ViewModel.SetStaticValueResult{`0}@)">
            <summary>Indicates whether this instance and a specified object are equal.</summary>
            <param name="other">The object to compare with the current instance.</param>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.op_Equality(MathCore.ViewModels.ViewModel.SetStaticValueResult{`0}@,MathCore.ViewModels.ViewModel.SetStaticValueResult{`0}@)">
            <summary>Оператор равенства двух значений</summary>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.op_Inequality(MathCore.ViewModels.ViewModel.SetStaticValueResult{`0}@,MathCore.ViewModels.ViewModel.SetStaticValueResult{`0}@)">
            <summary>Оператор неравенства двух значений</summary>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValue``1(``0@,``0@,System.Action{System.String}@,System.String@)">
            <summary>Установить новое значение свойства</summary>
            <param name="field">Ссылка на поле свойства</param>
            <param name="value">Устанавливаемое новое значение свойства</param>
            <param name="OnPropertyChanged">Метод извещения об изменении значения свойства</param>
            <param name="PropertyName">Имя изменяемого свойства</param>
            <typeparam name="T">ТИп значения свойства</typeparam>
            <returns>Объект контроля процесс обновления значения свойства</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValue``1(``0@,``0@,System.Func{``0,System.Boolean}@,System.Action{System.String}@,System.String@)">
            <summary>Установить новое значение свойства</summary>
            <param name="field">Ссылка на поле свойства</param>
            <param name="value">Устанавливаемое новое значение свойства</param>
            <param name="Validator">Метод проверки корректности значения свойства</param>
            <param name="OnPropertyChanged">Метод извещения об изменении значения свойства</param>
            <param name="PropertyName">Имя изменяемого свойства</param>
            <typeparam name="T">ТИп значения свойства</typeparam>
            <returns>Объект контроля процесс обновления значения свойства</returns>
        </member>
        <member name="T:MathCore.ViewModels.ViewModel.SetValueResult`1">
            <summary>Установщик значения</summary>
            <typeparam name="T">Тип устанавливаемого значения</typeparam>
        </member>
        <member name="F:MathCore.ViewModels.ViewModel.SetValueResult`1._Result">
            <summary>Результат установки значения</summary>
        </member>
        <member name="F:MathCore.ViewModels.ViewModel.SetValueResult`1._OldValue">
            <summary>Предыдущее значение свойства</summary>
        </member>
        <member name="F:MathCore.ViewModels.ViewModel.SetValueResult`1._NewValue">
            <summary>Новое значение свойства</summary>
        </member>
        <member name="F:MathCore.ViewModels.ViewModel.SetValueResult`1._Model">
            <summary>Модель-представления, для которой производится установка значения</summary>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.#ctor(System.Boolean,`0@,MathCore.ViewModels.ViewModel@)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ViewModels.ViewModel.SetValueResult`1"/></summary>
            <param name="Result">Было ли значение установлено для свойства</param>
            <param name="OldValue">Старое значение</param>
            <param name="model">Модель-представления, для свойство которой изменилось</param>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.#ctor(System.Boolean,`0@,`0@,MathCore.ViewModels.ViewModel@)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ViewModels.ViewModel.SetValueResult`1"/></summary>
            <param name="Result">Было ли значение установлено для свойства</param>
            <param name="OldValue">Старое значение</param>
            <param name="NewValue">Новое (установленное) значение</param>
            <param name="model">Модель-представления, для свойство которой изменилось</param>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.Then(System.Action@)">
            <summary>В случае если значение было установлено, выполнить указанное действие</summary>
            <param name="execute">Действие, которое требуется выполнить в случае если значение свойства было установлено</param>
            <returns>Истина, если значение свойства было установлено</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.Then(System.Action{`0}@)">
            <summary>В случае если значение было установлено, выполнить указанное действие над новым значением</summary>
            <param name="execute">Действие над значением, которое требуется выполнить в случае если значение свойства было установлено</param>
            <returns>Истина, если значение свойства было установлено</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.Then(System.Action{`0,`0}@)">
            <summary>В случае если значение было установлено, выполнить указанное действие над старым и новым значением</summary>
            <param name="execute">Действие над старым и новым значением, которое требуется выполнить в случае если значение свойства было установлено</param>
            <returns>Истина, если значение свойства было установлено</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.Update(System.String@)">
            <summary>Выполнить генерацию события обновления указанного свойства</summary>
            <param name="PropertyName">Имя свойства, которое также изменилось</param>
            <returns>Текущий объект установки значения</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.Update(System.String[])">
            <summary>Выполнить генерацию события обновления для указанных свойств</summary>
            <param name="PropertyName">Массив имён изменившихся свойств</param>
            <returns>Текущий объект установки значения</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.AnywayThen(System.Action@)">
            <summary>Выполнить действие вне зависимости от того, изменилось ли значение свойства, или нет</summary>
            <param name="execute">Действие, которое требуется выполнить</param>
            <returns>Истина, если свойство было изменено</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.AnywayThen(System.Action{System.Boolean}@)">
            <summary>
            Выполнить действие вне зависимости от того, изменилось ли значение свойства, или нет.
            Параметр действия - флаг, сигнализирующий о том, было ли изменено свойство
            </summary>
            <param name="execute">Действие, которое требуется выполнить</param>
            <returns>Истина, если свойство было изменено</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.AnywayThen(System.Action{`0}@)">
            <summary>Выполнить действие с новым значением вне зависимости от того, изменилось оно, или нет</summary>
            <param name="execute">Действие, которое требуется выполнить с параметром в виде значения свойства</param>
            <returns>Истина, если свойство было изменено</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.AnywayThen(System.Action{`0,System.Boolean}@)">
            <summary>
            Выполнить действие вне зависимости от того, изменилось ли значение свойства, или нет.
            Параметры действия - флаг, сигнализирующий о том, было ли изменено свойство, и значение свойства
            </summary>
            <param name="execute">Действие, которое требуется выполнить над значением свойства</param>
            <returns>Истина, если свойство было изменено</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.AnywayThen(System.Action{`0,`0}@)">
            <summary>
            Выполнить действие вне зависимости от того, изменилось ли значение свойства, или нет.
            Параметры действия - предыдущее и текущее значение свойства
            </summary>
            <param name="execute">Действие, которое требуется выполнить над значением свойства</param>
            <returns>Истина, если свойство было изменено</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.AnywayThen(System.Action{`0,`0,System.Boolean}@)">
            <summary>
            Выполнить действие вне зависимости от того, изменилось ли значение свойства, или нет.
            Параметры действия - предыдущее и текущее значение свойства, а также признак изменения значения
            </summary>
            <param name="execute">Действие, которое требуется выполнить над значением свойства</param>
            <returns>Истина, если свойство было изменено</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.Equals(MathCore.ViewModels.ViewModel.SetValueResult{`0}@)">
            <summary>Indicates whether this instance and a specified object are equal.</summary>
            <param name="other">The object to compare with the current instance.</param>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.op_Equality(MathCore.ViewModels.ViewModel.SetValueResult{`0}@,MathCore.ViewModels.ViewModel.SetValueResult{`0}@)">
            <summary>Оператор равенства двух значений</summary>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.op_Inequality(MathCore.ViewModels.ViewModel.SetValueResult{`0}@,MathCore.ViewModels.ViewModel.SetValueResult{`0}@)">
            <summary>Оператор неравенства двух значений</summary>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValue``1(``0@,``0@,System.String@)">
            <summary>Установить значение свойства</summary>
            <param name="field">Поле свойства</param>
            <param name="value">Устанавливаемое значение</param>
            <param name="PropertyName">Имя свойства (если пусто, то будет взято имя метода, откуда выполняется запуск)</param>
            <typeparam name="T">Тип значения</typeparam>
            <returns>Объект, отвечающий за обработку результата установки значения</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValue``1(``0@,``0@,System.Func{``0,System.Boolean}@,System.String@)">
            <summary>Установить значение свойства</summary>
            <param name="field">Поле свойства</param>
            <param name="value">Устанавливаемое значение</param>
            <param name="Validator">Метод проверки корректности значения, передаваемого в свойство</param>
            <param name="PropertyName">Имя свойства (если пусто, то будет взято имя метода, откуда выполняется запуск)</param>
            <typeparam name="T">Тип значения</typeparam>
            <returns>Объект, отвечающий за обработку результата установки значения</returns>
        </member>
        <member name="T:MathCore.XmlInitializer`1">
            <summary>Инициализатор объекта по структуре xml-файла</summary>
            <typeparam name="TObject">Тип инициализируемого объекта</typeparam>
        </member>
        <member name="T:MathCore.XmlInitializer`1.Rule">
            <summary>Правило инициализации</summary>
        </member>
        <member name="F:MathCore.XmlInitializer`1.Rule._XPath">
            <summary>XPath-выражение - путь в структуре xml</summary>
        </member>
        <member name="F:MathCore.XmlInitializer`1.Rule._PropertyBody">
            <summary>Выражение, применяемое при обнаружении значения указанного XPath-пути</summary>
        </member>
        <member name="F:MathCore.XmlInitializer`1.Rule._Update">
            <summary>Скомпилированный метод инициализации</summary>
        </member>
        <member name="P:MathCore.XmlInitializer`1.Rule.UpdateExpression">
            <summary>Выражение, применяемое при обнаружении значения указанного XPath-пути</summary>
        </member>
        <member name="P:MathCore.XmlInitializer`1.Rule.XPath">
            <summary>XPath-выражение - путь в структуре xml</summary>
        </member>
        <member name="P:MathCore.XmlInitializer`1.Rule.IsObjectLess">
            <summary>Правилу не нужен объект</summary>
        </member>
        <member name="P:MathCore.XmlInitializer`1.Rule.Update">
            <summary>Скомпилированный метод инициализации</summary>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Rule.#ctor(System.String,System.Linq.Expressions.Expression{System.Action{`0,System.String}},System.Boolean)">
            <summary>Инициализация нового правила</summary>
            <param name="XPath">XPath-путь в структуре xml</param>
            <param name="Expression">Выражение инициализации</param>
            <param name="IsObjectLess">Правилу не нужен объект</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Rule.Execute(`0,System.Xml.Linq.XElement,System.Xml.IXmlNamespaceResolver)">
            <summary>Выполнить инициализацию</summary>
            <param name="obj">Инициализируемый объект</param>
            <param name="e">Корень структуры xml</param>
            <param name="ns">Описание пространств имён</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Rule.Execute(System.Xml.Linq.XElement,System.Xml.IXmlNamespaceResolver)">
            <summary>Выполнить инициализацию</summary>
            <param name="e">Корень структуры xml</param>
            <param name="ns">Описание пространств имён</param>
        </member>
        <member name="T:MathCore.XmlInitializer`1.Rule`1">
            <summary>Типизированное правило инициализации</summary>
            <typeparam name="TValue">Тип значения инициализируемого параметра объекта</typeparam>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Rule`1.GetExpression(System.Linq.Expressions.Expression{System.Func{`0,`1}},System.Linq.Expressions.Expression{System.Func{System.String,`1}})">
            <summary>Получить выражение инициализации для выражения определения свойства</summary>
            <param name="expression">Выражение определения инициализируемого параметра объекта</param>
            <param name="ValueConverterExpression">Выражение преобразования строки в тип объекта</param>
            <returns>Выражение инициализации, как процедура с параметром - объектом и строкой xml-узла</returns>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Rule`1.GetExpression(System.Linq.Expressions.Expression{System.Action{`0,`1}},System.Linq.Expressions.Expression{System.Func{System.String,`1}})">
            <summary>Получить выражение инициализации объекта по выражению инициализации и выражению конвертера</summary>
            <param name="expression">Выражение инициализации</param>
            <param name="ValueConverterExpression">Конвертер преобразования строки в нужный тип данных</param>
            <returns>Выражение инициализации объекта по строке xml-структуры</returns>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Rule`1.#ctor(System.String,System.Linq.Expressions.Expression{System.Func{`0,`1}},System.Linq.Expressions.Expression{System.Func{System.String,`1}})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.XmlInitializer`1.Rule`1"/></summary>
            <param name="XPath">Путь к значению внутри xml-файла</param>
            <param name="expression">Выражение преобразования значения объекта инициализации к типу <typeparamref name="TValue"/>, выполняемое для инициализации значения объекта</param>
            <param name="converter">Выражение преобразования строкового типа значения из xml-файла в <typeparamref name="TValue"/></param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Rule`1.#ctor(System.String,System.Linq.Expressions.Expression{System.Action{`0,`1}},System.Linq.Expressions.Expression{System.Func{System.String,`1}})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.XmlInitializer`1.Rule`1"/></summary>
            <param name="XPath">Путь к значению внутри xml-файла</param>
            <param name="expression">Выражение действия над объектом инициализации и типом <typeparamref name="TValue"/>, выполняемое для присвоения значения</param>
            <param name="converter">Выражение преобразования строкового типа значения из xml-файла в <typeparamref name="TValue"/></param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Rule`1.#ctor(System.String,System.Linq.Expressions.Expression{System.Action{`0,System.String}})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.XmlInitializer`1.Rule`1"/></summary>
            <param name="XPath">Путь к значению внутри xml-файла</param>
            <param name="expression">Выражение действия над объектом инициализации и типом <typeparamref name="TValue"/>, выполняемое для присвоения значения</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Rule`1.#ctor(System.String,System.Linq.Expressions.Expression{System.Action{`1}},System.Linq.Expressions.Expression{System.Func{System.String,`1}})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.XmlInitializer`1.Rule`1"/></summary>
            <param name="XPath">Путь к значению внутри xml-файла</param>
            <param name="expression">Выражение действия над объектом инициализации, выполняемое для присвоения значения</param>
            <param name="converter">Выражение преобразования строкового типа значения из xml-файла в <typeparamref name="TValue"/></param>
        </member>
        <member name="F:MathCore.XmlInitializer`1._Rules">
            <summary>Набор правил</summary>
        </member>
        <member name="P:MathCore.XmlInitializer`1.Count">
            <summary>Число правил инициализации</summary>
        </member>
        <member name="P:MathCore.XmlInitializer`1.Item(System.Int32)">
            <summary>Правило инициализации с указанным индексом</summary>
            <param name="i">Индекс правила инициализации в списке</param>
            <returns>Правило инициализации с указанным индексом</returns>
        </member>
        <member name="P:MathCore.XmlInitializer`1.Namespace">
            <summary>Менеджер пространств имён xml-файла</summary>
        </member>
        <member name="M:MathCore.XmlInitializer`1.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.XmlInitializer`1"/></summary>
        </member>
        <member name="M:MathCore.XmlInitializer`1.#ctor(MathCore.XmlInitializer{`0}.Rule[])">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.XmlInitializer`1"/></summary>
            <param name="Rules">Список правил инициализации</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Initialize(`0,System.Xml.Linq.XDocument)">
            <summary>Инициализировать объект</summary>
            <param name="obj">Инициализируемый объект</param>
            <param name="xml">Xml-документ - источник данных процесса инициализации</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Initialize(`0,System.Xml.Linq.XElement)">
            <summary>Инициализировать объект</summary>
            <param name="obj">Инициализируемый объект</param>
            <param name="xml">Узел Xml-документа - источник данных процесса инициализации</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Initialize(System.Xml.Linq.XDocument,System.Xml.IXmlNamespaceResolver)">
            <summary>Инициализировать объект</summary>
            <param name="xml">Xml-документ - источник данных процесса инициализации</param>
            <param name="XmlNamespace">Пространство имён данных процесса инициализации</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Initialize(`0,System.Xml.Linq.XDocument,System.Xml.IXmlNamespaceResolver)">
            <summary>Инициализировать объект</summary>
            <param name="obj">Инициализируемый объект</param>
            <param name="xml">Xml-документ - источник данных процесса инициализации</param>
            <param name="XmlNamespace">Пространство имён данных процесса инициализации</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Initialize(`0,System.Xml.Linq.XElement,System.Xml.IXmlNamespaceResolver)">
            <summary>Инициализировать объект</summary>
            <param name="obj">Инициализируемый объект</param>
            <param name="xml">Узел Xml-документа - источник данных процесса инициализации</param>
            <param name="XmlNamespace">Пространство имён данных процесса инициализации</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Initialize(System.Xml.Linq.XElement,System.Xml.IXmlNamespaceResolver)">
            <summary>Инициализировать объект</summary>
            <param name="xml">Узел Xml-документа - источник данных процесса инициализации</param>
            <param name="XmlNamespace">Пространство имён данных процесса инициализации</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Initialize(`0,System.Xml.XmlReader)">
            <summary>Инициализировать объект данными из xml-документа</summary>
            <param name="obj">инициализируемый объект</param>
            <param name="xml">Объект чтения xml-документа</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Initialize(`0,System.Xml.XmlReader,System.Xml.XmlNamespaceManager)">
            <summary>Инициализировать объект данными из xml-документа</summary>
            <param name="obj">инициализируемый объект</param>
            <param name="xml">Объект чтения xml-документа</param>
            <param name="XmlNamespace">Пространство имён данных процесса инициализации</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Add``1(System.String,System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Linq.Expressions.Expression{System.Func{System.String,``0}})">
            <summary>Добавить правило с указанием выражения получения члена объекта</summary>
            <typeparam name="TPropertyValue">Тип значения свойства</typeparam>
            <param name="XPath">Путь в xml-структуре</param>
            <param name="InitializationExpression">Выражение, определяющее член объекта</param>
            <param name="DataConverterExpression">Выражение преобразования строки в целевой тип данных</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Add``1(System.String,System.Linq.Expressions.Expression{System.Action{`0,``0}},System.Linq.Expressions.Expression{System.Func{System.String,``0}})">
            <summary>Добавить правило инициализации объекта <typeparamref name="TObject"/></summary>
            <param name="XPath">Путь к данным внутри xml-файла</param>
            <param name="InitializationExpression">Выражение, определяющее как записать данные в объект после извлечения их из xml-файла</param>
            <param name="DataConverterExpression">Выражение, определяющее как требуется преобразовать строку, полученную из xml-файла в тип данных, необходимый объекту</param>
            <typeparam name="TArgument">Тип устанавливаемого значения для объекта инициализации</typeparam>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Add(System.String,System.Linq.Expressions.Expression{System.Action{`0,System.String}},System.Linq.Expressions.Expression{System.Func{System.String,System.String}})">
            <summary>Добавить правило инициализации</summary>
            <param name="XPath">Путь к данным внутри xml-файла</param>
            <param name="InitializationExpression">Выражение, определяющее как записать строку в объект после извлечения её из xml-файла</param>
            <param name="DataConverterExpression">Выражение, определяющее как требуется преобразовать строку, полученную из xml-файла в строку, необходимую объекту</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Add``1(System.String,System.Linq.Expressions.Expression{System.Action{``0}},System.Linq.Expressions.Expression{System.Func{System.String,``0}})">
            <summary>Добавить правило инициализации без инициализируемого объекта</summary>
            <param name="XPath">Путь к данным внутри xml-файла</param>
            <param name="InitializationExpression">Выражение, определяющее что требуется сделать с данными после извлечения их из xml-файла</param>
            <param name="DataConverterExpression">Выражение, определяющее как требуется преобразовать строку, полученную из xml-файла в тип данных, необходимый объекту</param>
            <typeparam name="TArgument">Тип устанавливаемого значения для объекта инициализации</typeparam>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Add(System.String,System.Linq.Expressions.Expression{System.Action{System.String}},System.Linq.Expressions.Expression{System.Func{System.String,System.String}})">
            <summary>Добавить правило инициализации без инициализируемого объекта</summary>
            <param name="XPath">Путь к данным внутри xml-файла</param>
            <param name="InitializationExpression">Выражение, определяющее что требуется сделать со строкой после её извлечения из xml-файла</param>
            <param name="DataConverterExpression">Выражение, определяющее как требуется преобразовать строку, полученную из xml-файла в строку, необходимую для процесса инициализации</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Clear">
            <summary>Удалить все правила инициализации</summary>
        </member>
        <member name="P:MathCore.XmlInitializer`1.System#Collections#Generic#ICollection{MathCore#XmlInitializer{TObject}#Rule}#IsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:MathCore.XmlInitializer`1.System#Collections#Generic#ICollection{MathCore#XmlInitializer{TObject}#Rule}#Add(MathCore.XmlInitializer{`0}.Rule)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.XmlInitializer`1.System#Collections#Generic#ICollection{MathCore#XmlInitializer{TObject}#Rule}#Contains(MathCore.XmlInitializer{`0}.Rule)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.XmlInitializer`1.System#Collections#Generic#ICollection{MathCore#XmlInitializer{TObject}#Rule}#CopyTo(MathCore.XmlInitializer{`0}.Rule[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.XmlInitializer`1.System#Collections#Generic#ICollection{MathCore#XmlInitializer{TObject}#Rule}#Remove(MathCore.XmlInitializer{`0}.Rule)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.XmlInitializer`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.XmlInitializer`1.System#Collections#Generic#IEnumerable{MathCore#XmlInitializer{TObject}#Rule}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Xml.LambdaXmlSerializer">
            <summary>Настраиваемый сериализатор объектов в XML</summary>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer.Create``1(System.String)">
            <summary>Создать новый сериализатор объектов</summary>
            <typeparam name="T">Тип сериализуемого класса</typeparam>
            <param name="RootName">Имя корневого элемента (если не указано, то будет использовано имя класса)</param>
            <returns>Сериализатор</returns>
        </member>
        <member name="T:MathCore.Xml.LambdaXmlSerializer`1">
            <summary>Настраиваемый сериализатор объектов в XML</summary>
            <typeparam name="T">Тип сериализуемого класса</typeparam>
        </member>
        <member name="F:MathCore.Xml.LambdaXmlSerializer`1.__EmptyName">
            <summary>Название элемента по умолчанию</summary>
        </member>
        <member name="P:MathCore.Xml.LambdaXmlSerializer`1.EmptyName">
            <summary>Название элемента по умолчанию</summary>
        </member>
        <member name="F:MathCore.Xml.LambdaXmlSerializer`1._ElementName">
            <summary>Название элемента</summary>
        </member>
        <member name="F:MathCore.Xml.LambdaXmlSerializer`1._Attributes">
            <summary>Список методов формирования атрибутов элемента</summary>
        </member>
        <member name="F:MathCore.Xml.LambdaXmlSerializer`1._Elements">
            <summary>Список методов формирования дочерних элементов</summary>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.#ctor(System.String)">
            <summary>Инициализация нового настраиваемого сериализатора</summary>
            <param name="ElementName">Название корневого элемента</param>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Serialize(`0)">
            <summary>Выполнение процесса сериализации</summary>
            <param name="value">Сериализуемый объект</param>
            <returns>xml-представление сериализуемого объекта</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Serialize(System.String,`0)">
            <summary>Выполнение процесса сериализации</summary>
            <param name="Name">Название корневого элемента</param>
            <param name="value">Сериализуемый объект</param>
            <returns>xml-представление сериализуемого объекта</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Content(`0)">
            <summary>Формирование содержимого элемента</summary>
            <remarks>Выполнение списков методов вычисления значений атрибутов, затем - дочерних элементов</remarks>
            <param name="value">Сериализуемый объект</param>
            <returns>Перечисление атрибутов и дочерних элементов, вкладываемых в корневой элемент</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Attribute``1(System.String,System.Func{`0,``0})">
            <summary>Добавление конфигурации атрибута</summary>
            <typeparam name="TValue">ТИп значения атрибута</typeparam>
            <param name="Name">Имя атрибута</param>
            <param name="Selector">Метод определения значения атрибута</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Attributes``2(System.Func{`0,System.Collections.Generic.IEnumerable{``0}},System.Func{``0,System.String},System.Func{``0,``1})">
            <summary>Добавление конфигурации атрибутов</summary>
            <typeparam name="TItem">Тип данных сериализуемого элемента</typeparam>
            <typeparam name="TValue">Тип значения атрибута</typeparam>
            <param name="Selector">Метод определения набора данных, который должен быть упакован в атрибуты</param>
            <param name="NameSelector">Метод определения имени каждого конкретного атрибута</param>
            <param name="ValueSelector">Метод определения значения каждого конкретного атрибута</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Attributes``2(System.Func{`0,System.Collections.Generic.IEnumerable{``0}},System.Func{``0,System.String},System.Func{``0,System.Boolean},System.Func{``0,``1})">
            <summary>Добавление конфигурации атрибутов</summary>
            <typeparam name="TItem">Тип данных сериализуемого элемента</typeparam>
            <typeparam name="TValue">Тип значения атрибута</typeparam>
            <param name="Selector">Метод определения набора данных, который должен быть упакован в атрибуты</param>
            <param name="NameSelector">Метод определения имени каждого конкретного атрибута</param>
            <param name="NeedToSerialize">Метод, определяющий - требуется ли выполнять сериализацию конкретного значения в атрибут?</param>
            <param name="ValueSelector">Метод определения значения каждого конкретного атрибута</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Attributes``2(System.Func{`0,System.Collections.Generic.IEnumerable{``0}},System.Func{``0,System.Int32,System.String},System.Func{``0,``1})">
            <summary>Добавление конфигурации атрибутов</summary>
            <typeparam name="TItem">Тип данных сериализуемого элемента</typeparam>
            <typeparam name="TValue">Тип значения атрибута</typeparam>
            <param name="Selector">Метод определения набора данных, который должен быть упакован в атрибуты</param>
            <param name="NameSelector">Метод определения имени каждого конкретного атрибута в том числе по порядковому номеру</param>
            <param name="ValueSelector">Метод определения значения каждого конкретного атрибута</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Attributes``2(System.Func{`0,System.Collections.Generic.IEnumerable{``0}},System.Func{``0,System.Int32,System.String},System.Func{``0,System.Boolean},System.Func{``0,``1})">
            <summary>Добавление конфигурации атрибутов</summary>
            <typeparam name="TItem">Тип данных сериализуемого элемента</typeparam>
            <typeparam name="TValue">Тип значения атрибута</typeparam>
            <param name="Selector">Метод определения набора данных, который должен быть упакован в атрибуты</param>
            <param name="NameSelector">Метод определения имени каждого конкретного атрибута в том числе по порядковому номеру</param>
            <param name="NeedToSerialize">Метод, определяющий - требуется ли выполнять сериализацию конкретного значения в атрибут?</param>
            <param name="ValueSelector">Метод определения значения каждого конкретного атрибута</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Attributes``2(System.Func{`0,System.Collections.Generic.IEnumerable{``0}},System.Func{``0,System.String},System.Func{``0,System.Int32,``1})">
            <summary>Добавление конфигурации атрибутов</summary>
            <typeparam name="TItem">Тип данных сериализуемого элемента</typeparam>
            <typeparam name="TValue">Тип значения атрибута</typeparam>
            <param name="Selector">Метод определения набора данных, который должен быть упакован в атрибуты</param>
            <param name="NameSelector">Метод определения имени каждого конкретного атрибута в том числе</param>
            <param name="ValueSelector">Метод определения значения каждого конкретного атрибута по порядковому номеру</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Attributes``2(System.Func{`0,System.Collections.Generic.IEnumerable{``0}},System.Func{``0,System.Int32,System.String},System.Func{``0,System.Boolean},System.Func{``0,System.Int32,``1})">
            <summary>Добавление конфигурации атрибутов</summary>
            <typeparam name="TItem">Тип данных сериализуемого элемента</typeparam>
            <typeparam name="TValue">Тип значения атрибута</typeparam>
            <param name="Selector">Метод определения набора данных, который должен быть упакован в атрибуты</param>
            <param name="NameSelector">Метод определения имени каждого конкретного атрибута в том числе</param>
            <param name="NeedToSerialize">Метод, определяющий - требуется ли выполнять сериализацию конкретного значения в атрибут?</param>
            <param name="ValueSelector">Метод определения значения каждого конкретного атрибута по порядковому номеру</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Element``1(System.String,System.Func{`0,``0})">
            <summary>Добавление конфигурации элемента</summary>
            <typeparam name="TValue">Тип данных значения элемента</typeparam>
            <param name="Name">Имя элемента</param>
            <param name="Selector">Метод определения значения элемента</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Element``1(System.String,System.Func{`0,``0},System.Func{``0,System.Boolean})">
            <summary>Добавление конфигурации элемента</summary>
            <typeparam name="TValue">Тип данных значения элемента</typeparam>
            <param name="Name">Имя элемента</param>
            <param name="Selector">Метод определения значения элемента</param>
            <param name="NeedToSerialize">Метод, определяющий - нужно ли выполнять сериализацию данного элемента</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Element``1(System.String,System.Func{`0,``0},System.Action{MathCore.Xml.LambdaXmlSerializer{``0}})">
            <summary>Добавление конфигурации элемента</summary>
            <typeparam name="TValue">Тип данных значения элемента</typeparam>
            <param name="Name">Имя элемента</param>
            <param name="Selector">Метод определения значения элемента</param>
            <param name="Configurator">Конфигурация сериализатора значения элемента</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Element``1(System.String,System.Func{`0,``0},System.Func{``0,System.Boolean},System.Action{MathCore.Xml.LambdaXmlSerializer{``0}})">
            <summary>Добавление конфигурации элемента</summary>
            <typeparam name="TValue">Тип данных значения элемента</typeparam>
            <param name="Name">Имя элемента</param>
            <param name="Selector">Метод определения значения элемента</param>
            <param name="NeedToSerialize">Метод, определяющий - нужно ли выполнять сериализацию данного элемента</param>
            <param name="Configurator">Конфигурация сериализатора значения элемента</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Elements``1(System.String,System.Func{`0,System.Collections.Generic.IEnumerable{``0}},System.Action{MathCore.Xml.LambdaXmlSerializer{``0}})">
            <summary>Добавление конфигурации набора элементов</summary>
            <typeparam name="TValue">Тип данных значения элемента</typeparam>
            <param name="Name">Имя элемента</param>
            <param name="ElementsSelector">Метод определения набора значений элементов для сериализации</param>
            <param name="Configurator">Конфигурация сериализатора значения элемента</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Elements``1(System.String,System.Func{`0,System.Collections.Generic.IEnumerable{``0}},System.Func{``0,System.Boolean},System.Action{MathCore.Xml.LambdaXmlSerializer{``0}})">
            <summary>Добавление конфигурации набора элементов</summary>
            <typeparam name="TValue">Тип данных значения элемента</typeparam>
            <param name="Name">Имя элемента</param>
            <param name="ElementsSelector">Метод определения набора значений элементов для сериализации</param>
            <param name="NeedToSerialize">Метод, определяющий - нужно ли выполнять сериализацию данного элемента</param>
            <param name="Configurator">Конфигурация сериализатора значения элемента</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Elements``1(System.Func{`0,System.Collections.Generic.IEnumerable{``0}},System.Func{``0,System.String},System.Action{MathCore.Xml.LambdaXmlSerializer{``0}})">
            <summary>Добавление конфигурации набора элементов</summary>
            <typeparam name="TValue">Тип данных значения элемента</typeparam>
            <param name="ElementsSelector">Метод определения набора значений элементов для сериализации</param>
            <param name="NameSelector">Метод определения имени элемента</param>
            <param name="Configurator">Конфигурация сериализатора значения элемента</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Elements``1(System.Func{`0,System.Collections.Generic.IEnumerable{``0}},System.Func{``0,System.String},System.Func{``0,System.Boolean},System.Action{MathCore.Xml.LambdaXmlSerializer{``0}})">
            <summary>Добавление конфигурации набора элементов</summary>
            <typeparam name="TValue">Тип данных значения элемента</typeparam>
            <param name="ElementsSelector">Метод определения набора значений элементов для сериализации</param>
            <param name="NameSelector">Метод определения имени элемента</param>
            <param name="NeedToSerialize">Метод, определяющий - нужно ли выполнять сериализацию данного элемента</param>
            <param name="Configurator">Конфигурация сериализатора значения элемента</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Elements``1(System.Func{`0,System.Collections.Generic.IEnumerable{``0}},System.Func{``0,System.Int32,System.String},System.Action{MathCore.Xml.LambdaXmlSerializer{``0}})">
            <summary>Добавление конфигурации набора элементов</summary>
            <typeparam name="TValue">Тип данных значения элемента</typeparam>
            <param name="ElementsSelector">Метод определения набора значений элементов для сериализации</param>
            <param name="NameSelector">Метод определения имени элемента</param>
            <param name="Configurator">Конфигурация сериализатора значения элемента</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Elements``1(System.Func{`0,System.Collections.Generic.IEnumerable{``0}},System.Func{``0,System.Int32,System.String},System.Func{``0,System.Boolean},System.Action{MathCore.Xml.LambdaXmlSerializer{``0}})">
            <summary>Добавление конфигурации набора элементов</summary>
            <typeparam name="TValue">Тип данных значения элемента</typeparam>
            <param name="ElementsSelector">Метод определения набора значений элементов для сериализации</param>
            <param name="NameSelector">Метод определения имени элемента</param>
            <param name="NeedToSerialize">Метод, определяющий - нужно ли выполнять сериализацию данного элемента</param>
            <param name="Configurator">Конфигурация сериализатора значения элемента</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Value">
            <summary>Добавление конфигурации, устанавливающий необходимость включения значения сериализуемого объекта</summary>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Value``1(``0)">
            <summary>Добавление конфигурации, устанавливающий необходимость включения указанного значения</summary>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Value``1(System.Func{`0,``0})">
            <summary>Добавление конфигурации, устанавливающий необходимость включения значения, определяемого на основе сериализуемого объекта</summary>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="T:System.ActionsCollectionProcessor">
            <summary>Процессор, выполняющий действия</summary>
        </member>
        <member name="M:System.ActionsCollectionProcessor.#ctor(System.Collections.Generic.IEnumerable{System.Action})">
            <summary>Инициализация нового экземпляра <see cref="T:System.ActionsCollectionProcessor"/></summary>
            <param name="ActionsCollection">Перечисление действий, которые требуется выполнить</param>
        </member>
        <member name="M:System.ActionsCollectionProcessor.MainAction">
            <summary>Основной метод действия процессора, вызываемое в цикле. Должно быть переопределено в классах-наследниках</summary>
        </member>
        <member name="M:System.ActionsCollectionProcessor.ProcessAction(System.Action)">
            <summary>Выполнить очередное действие</summary>
            <param name="action">Очередное действие из очереди действий, которые должен выполнить процессор</param>
        </member>
        <member name="T:System.AffectsTheAttribute">
            <summary>Влияние на</summary>
        </member>
        <member name="P:System.AffectsTheAttribute.Name">
            <summary>Элемент, на который оказывается влияние</summary>
        </member>
        <member name="M:System.AffectsTheAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.AffectsTheAttribute"/></summary>
        </member>
        <member name="M:System.AffectsTheAttribute.#ctor(System.String)">
            <summary>Инициализация нового экземпляра <see cref="T:System.AffectsTheAttribute"/></summary>
            <param name="Name">Имя элемента, на что помеченный элемент оказывает влияние</param>
        </member>
        <member name="T:System.ChangedHandlerAttribute">
            <summary>Указывает процедуру без параметров, определённую в классе, которая должна быть вызвана после изменения значения свойства</summary>
        </member>
        <member name="P:System.ChangedHandlerAttribute.MethodName">
            <summary>Имя метода-реакции на изменение значения свойства</summary>
        </member>
        <member name="M:System.ChangedHandlerAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.DependencyOnAttribute"/></summary>
        </member>
        <member name="M:System.ChangedHandlerAttribute.#ctor(System.String)">
            <summary>Инициализация нового экземпляра <see cref="T:System.DependencyOnAttribute"/></summary>
            <param name="MethodName">Имя метода-реакции на изменение значения свойства</param>
        </member>
        <member name="T:System.CopyrightAttribute">
            <summary>Сведения об авторских правах на участок кода</summary>
        </member>
        <member name="P:System.CopyrightAttribute.Copyright">
            <summary>Авторские права</summary>
        </member>
        <member name="P:System.CopyrightAttribute.url">
            <summary>Ссылка на источник</summary>
        </member>
        <member name="M:System.CopyrightAttribute.#ctor(System.String)">
            <summary>Инициализация нового экземпляра <see cref="T:System.CopyrightAttribute"/></summary>
            <param name="Copyright">Авторские права</param>
        </member>
        <member name="M:System.CopyrightAttribute.ToString">
            <inheritdoc />
        </member>
        <member name="T:System.DependencyOnAttribute">
            <summary>Зависимость от</summary>
        </member>
        <member name="P:System.DependencyOnAttribute.Name">
            <summary>Элемент, от которого существует зависимость</summary>
        </member>
        <member name="M:System.DependencyOnAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.DependencyOnAttribute"/></summary>
        </member>
        <member name="M:System.DependencyOnAttribute.#ctor(System.String)">
            <summary>Инициализация нового экземпляра <see cref="T:System.DependencyOnAttribute"/></summary>
            <param name="Name">Имя элемента, от которого зависит помеченный элемент</param>
        </member>
        <member name="T:System.dValueAttribute">
            <summary>Допустимая величина изменения значения</summary>
        </member>
        <member name="P:System.dValueAttribute.dV">
            <summary>Допустимая величина изменения значения</summary>
        </member>
        <member name="M:System.dValueAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.dValueAttribute"/></summary>
        </member>
        <member name="M:System.dValueAttribute.#ctor(System.Double)">
            <summary>Инициализация нового экземпляра <see cref="T:System.dValueAttribute"/></summary>
            <param name="dV">Допустимая величина изменения значения</param>
        </member>
        <member name="T:System.ElementDescriptionAttribute">
            <summary>Описание</summary>
        </member>
        <member name="P:System.ElementDescriptionAttribute.Description">
            <summary>Описание</summary>
        </member>
        <member name="M:System.ElementDescriptionAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.ElementDescriptionAttribute"/></summary> 
        </member>
        <member name="M:System.ElementDescriptionAttribute.#ctor(System.String)">
            <summary>Инициализация нового экземпляра <see cref="T:System.ElementDescriptionAttribute"/></summary>
            <param name="Description">Описание</param>
        </member>
        <member name="M:System.ElementDescriptionAttribute.ToString">
            <inheritdoc />
        </member>
        <member name="T:System.GreaterOrEqualAttribute">
            <summary>Значение должно быть больше, либо равно</summary>
        </member>
        <member name="F:System.GreaterOrEqualAttribute._Value">
            <summary>Пороговое значение</summary>
        </member>
        <member name="P:System.GreaterOrEqualAttribute.Value">
            <summary>Пороговое значение</summary>
        </member>
        <member name="M:System.GreaterOrEqualAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.GreaterOrEqualAttribute"/></summary>
        </member>
        <member name="M:System.GreaterOrEqualAttribute.#ctor(System.Object)">
            <summary>Инициализация нового экземпляра <see cref="T:System.GreaterOrEqualAttribute"/></summary>
            <param name="Value">Пороговое значение</param>
        </member>
        <member name="M:System.GreaterOrEqualAttribute.ToString">
            <inheritdoc />
        </member>
        <member name="T:System.GreaterThenAttribute">
            <summary>Значение должно быть больше, чем</summary>
        </member>
        <member name="F:System.GreaterThenAttribute._Value">
            <summary>Пороговое значение</summary>
        </member>
        <member name="P:System.GreaterThenAttribute.Value">
            <summary>Пороговое значение</summary>
        </member>
        <member name="M:System.GreaterThenAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.GreaterThenAttribute"/></summary>
        </member>
        <member name="M:System.GreaterThenAttribute.#ctor(System.Object)">
            <summary>Инициализация нового экземпляра <see cref="T:System.GreaterThenAttribute"/></summary>
            <param name="Value">Максимально допустимое значение</param>
        </member>
        <member name="M:System.GreaterThenAttribute.ToString">
            <inheritdoc />
        </member>
        <member name="T:System.HyperlinkAttribute">
            <summary>Ссылка</summary>
        </member>
        <member name="P:System.HyperlinkAttribute.Link">
            <summary>Ссылка</summary>
        </member>
        <member name="M:System.HyperlinkAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.HyperlinkAttribute"/></summary>
        </member>
        <member name="M:System.HyperlinkAttribute.#ctor(System.String)">
            <summary>Инициализация нового экземпляра <see cref="T:System.HyperlinkAttribute"/></summary>
            <param name="Link">Текст ссылки</param>
        </member>
        <member name="M:System.HyperlinkAttribute.op_Implicit(System.HyperlinkAttribute)~System.Uri">
            <summary>Оператор неявного приведения типа <see cref="T:System.HyperlinkAttribute"/> к <see cref="T:System.Uri"/></summary>
            <param name="A">Атрибут ссылки, преобразуемый в <see cref="T:System.Uri"/></param>
        </member>
        <member name="T:System.IntervalValueAttribute">
            <summary>Допустимый интервал значений</summary>
        </member>
        <member name="P:System.IntervalValueAttribute.Min">
            <summary>Минимальное значение</summary>
        </member>
        <member name="P:System.IntervalValueAttribute.Max">
            <summary>Максимальное значение</summary>
        </member>
        <member name="P:System.IntervalValueAttribute.Interval">
            <summary>Допустимый интервал значений</summary>
        </member>
        <member name="M:System.IntervalValueAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.IntervalValueAttribute"/></summary>
        </member>
        <member name="M:System.IntervalValueAttribute.#ctor(MathCore.Interval)">
            <summary>Инициализация нового экземпляра <see cref="T:System.IntervalValueAttribute"/></summary>
            <param name="Interval">Допустимый интервал значений</param>
        </member>
        <member name="M:System.IntervalValueAttribute.#ctor(System.Double,System.Double)">
            <summary>Инициализация нового экземпляра <see cref="T:System.IntervalValueAttribute"/></summary>
            <param name="Min">Минимально допустимое значение</param>
            <param name="Max">Максимально допустимое значение</param>
        </member>
        <member name="T:System.LessOrEqualAttribute">
            <summary>Значение должно быть больше, либо равно</summary>
        </member>
        <member name="F:System.LessOrEqualAttribute._Value">
            <summary>Пороговое значение</summary>
        </member>
        <member name="P:System.LessOrEqualAttribute.Value">
            <summary>Пороговое значение</summary>
        </member>
        <member name="M:System.LessOrEqualAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.LessOrEqualAttribute"/></summary>
        </member>
        <member name="M:System.LessOrEqualAttribute.#ctor(System.Object)">
            <summary>Инициализация нового экземпляра <see cref="T:System.LessOrEqualAttribute"/></summary>
            <param name="Value">Пороговое значение</param>
        </member>
        <member name="M:System.LessOrEqualAttribute.ToString">
            <inheritdoc />
        </member>
        <member name="T:System.LessThenAttribute">
            <summary>Значение должно быть больше, чем</summary>
        </member>
        <member name="P:System.LessThenAttribute.Value">
            <summary>Пороговое значение</summary>
        </member>
        <member name="M:System.LessThenAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.LessThenAttribute"/></summary>
        </member>
        <member name="M:System.LessThenAttribute.#ctor(System.Object)">
            <summary>Инициализация нового экземпляра <see cref="T:System.LessThenAttribute"/></summary>
            <param name="Value">Максимально допустимое значение</param>
        </member>
        <member name="M:System.LessThenAttribute.ToString">
            <inheritdoc />
        </member>
        <member name="T:System.MaxValueAttribute">
            <summary>Максимально допустимое значение</summary>
        </member>
        <member name="P:System.MaxValueAttribute.Value">
            <summary>Максимально допустимое значение</summary>
        </member>
        <member name="M:System.MaxValueAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.MaxValueAttribute"/></summary>
        </member>
        <member name="M:System.MaxValueAttribute.#ctor(System.Double)">
            <summary>Инициализация нового экземпляра <see cref="T:System.MaxValueAttribute"/></summary>
            <param name="Value">Максимально допустимое значение</param>
        </member>
        <member name="T:System.MinValueAttribute">
            <summary>Минимально допустимое значение</summary>
        </member>
        <member name="P:System.MinValueAttribute.Value">
            <summary>Минимально допустимое значение</summary>
        </member>
        <member name="M:System.MinValueAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.MinValueAttribute"/></summary>
        </member>
        <member name="M:System.MinValueAttribute.#ctor(System.Double)">
            <summary>Инициализация нового экземпляра <see cref="T:System.MinValueAttribute"/></summary>
            <param name="Value">Минимально допустимое значение</param>
        </member>
        <member name="T:System.NotImplementedAttribute">
            <summary>Атрибут признака нереализованности</summary>
        </member>
        <member name="P:System.NotImplementedAttribute.Message">
            <summary>Сообщение</summary>
        </member>
        <member name="M:System.NotImplementedAttribute.#ctor">
            <summary>Новый атрибут нереализованности</summary>
        </member>
        <member name="M:System.NotImplementedAttribute.#ctor(System.String)">
            <summary>Новый атрибут нереализованности</summary>
            <param name="Message">Сообщение (почему не реализовано?)</param>
        </member>
        <member name="M:System.NotImplementedAttribute.IsDefaultAttribute">
            <summary>Признак атрибута "по умолчанию"</summary>
            <returns>Истина, если указан незаполненный атрибут</returns>
        </member>
        <member name="T:System.NotSupportedAttribute">
            <summary>Атрибут признака неподдерживаемости</summary>
        </member>
        <member name="P:System.NotSupportedAttribute.Message">
            <summary>Сообщение</summary>
        </member>
        <member name="M:System.NotSupportedAttribute.#ctor">
            <summary>Новый атрибут неподдерживаемости</summary>
        </member>
        <member name="M:System.NotSupportedAttribute.#ctor(System.String)">
            <summary>Новый атрибут неподдерживаемости</summary>
            <param name="Message">Сообщение (почему не поддерживается?)</param>
        </member>
        <member name="M:System.NotSupportedAttribute.IsDefaultAttribute">
            <summary>Признак атрибута "по умолчанию"</summary>
            <returns>Истина, если указан незаполненный атрибут</returns>
        </member>
        <member name="T:System.RegexPatternAttribute">
            <summary>Является регулярным выражением</summary>
        </member>
        <member name="T:System.ValueBetweenAttribute">
            <summary>Значение должно быть в диапазоне значений</summary>
        </member>
        <member name="F:System.ValueBetweenAttribute._Min">
            <summary>Нижнее пороговое значение</summary>
        </member>
        <member name="F:System.ValueBetweenAttribute._Max">
            <summary>Нижнее пороговое значение</summary>
        </member>
        <member name="P:System.ValueBetweenAttribute.Min">
            <summary>Нижнее пороговое значение</summary>
        </member>
        <member name="P:System.ValueBetweenAttribute.Max">
            <summary>Нижнее пороговое значение</summary>
        </member>
        <member name="M:System.ValueBetweenAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.GreaterOrEqualAttribute"/></summary>
        </member>
        <member name="M:System.ValueBetweenAttribute.#ctor(System.Object,System.Object)">
            <summary>Инициализация нового экземпляра <see cref="T:System.GreaterOrEqualAttribute"/></summary>
            <param name="Min">Минимальное значение</param>
            <param name="Max">Максимальное значение</param>
        </member>
        <member name="M:System.ValueBetweenAttribute.ToString">
            <inheritdoc />
        </member>
        <member name="T:System.EventArgs`1">
            <summary>Аргумент события с типизированным параметром</summary>
        </member>
        <member name="P:System.EventArgs`1.Argument">
            <summary>Параметр аргумента</summary>
        </member>
        <member name="M:System.EventArgs`1.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`1"/></summary>
        </member>
        <member name="M:System.EventArgs`1.#ctor(`0)">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`1"/></summary>
            <param name="Argument">Параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`1.ToString">
            <summary>Строковое представление аргумента события</summary>
        </member>
        <member name="M:System.EventArgs`1.op_Implicit(System.EventArgs{`0})~`0">
            <summary>Оператор неявного преобразования аргумента события к типу содержащегося в нём значения</summary>
            <param name="Args">Аргумент события</param>
            <returns>Хранимый объект</returns>
        </member>
        <member name="M:System.EventArgs`1.op_Implicit(`0)~System.EventArgs{`0}">
            <summary>Оператор неявного преобразования типа хранимого значения в обёртку из аргумента события, содержащего это значение</summary>
            <param name="Argument">Объект аргумента события</param>
            <returns>Аргумент события</returns>
        </member>
        <member name="T:System.EventArgs`2">
            <summary>Аргумент события с 2 типизированными параметрами</summary>
            <typeparam name="TArgument1">Тип аргумента 1</typeparam>
            <typeparam name="TArgument2">Тип аргумента 2</typeparam>
        </member>
        <member name="P:System.EventArgs`2.Argument1">
            <summary>1 параметр аргумента</summary>
        </member>
        <member name="P:System.EventArgs`2.Argument2">
            <summary>2 параметр аргумента</summary>
        </member>
        <member name="M:System.EventArgs`2.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`2"/></summary>
        </member>
        <member name="M:System.EventArgs`2.#ctor(`0,`1)">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`2"/></summary>
            <param name="Argument1">1 параметр аргумента</param>
            <param name="Argument2">2 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`2.Deconstruct(`0@,`1@)">
            <summary>Деконструктор <see cref="T:System.EventArgs`2"/></summary>
            <param name="Arg1">1 параметр аргумента</param>
            <param name="Arg2">2 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`2.op_Implicit(System.EventArgs{`0,`1})~System.ValueTuple{`0,`1}">
            <summary>Оператор неявного преобразования типа <see cref="T:System.EventArgs`2"/> к кортежу</summary>
            <param name="Args">Аргумент события <see cref="T:System.EventArgs`2"/></param>
            <returns>Кортеж из 2 параметров</returns>
        </member>
        <member name="M:System.EventArgs`2.op_Implicit(System.ValueTuple{`0,`1})~System.EventArgs{`0,`1}">
            <summary>Оператор неявного преобразования кортежа из 2 параметров к типу <see cref="T:System.EventArgs`2"/></summary>
            <param name="Args">Кортеж из 2 параметров</param>
            <returns>Аргумент события <see cref="T:System.EventArgs`2"/></returns>
        </member>
        <member name="T:System.EventArgs`3">
            <summary>Аргумент события с 3 типизированными параметрами</summary>
            <typeparam name="TArgument1">Тип аргумента 1</typeparam>
            <typeparam name="TArgument2">Тип аргумента 2</typeparam>
            <typeparam name="TArgument3">Тип аргумента 3</typeparam>
        </member>
        <member name="P:System.EventArgs`3.Argument3">
            <summary>3 параметр аргумента</summary>
        </member>
        <member name="M:System.EventArgs`3.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`3"/></summary>
        </member>
        <member name="M:System.EventArgs`3.#ctor(`0,`1,`2)">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`3"/></summary>
            <param name="Argument1">1 параметр аргумента</param>
            <param name="Argument2">2 параметр аргумента</param>
            <param name="Argument3">3 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`3.Deconstruct(`0@,`1@,`2@)">
            <summary>Деконструктор <see cref="T:System.EventArgs`3"/></summary>
            <param name="Arg1">1 параметр аргумента</param>
            <param name="Arg2">2 параметр аргумента</param>
            <param name="Arg3">3 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`3.op_Implicit(System.EventArgs{`0,`1,`2})~System.ValueTuple{`0,`1,`2}">
            <summary>Оператор неявного преобразования типа <see cref="T:System.EventArgs`3"/> к кортежу</summary>
            <param name="Args">Аргумент события <see cref="T:System.EventArgs`3"/></param>
            <returns>Кортеж из 3 параметров</returns>
        </member>
        <member name="M:System.EventArgs`3.op_Implicit(System.ValueTuple{`0,`1,`2})~System.EventArgs{`0,`1,`2}">
            <summary>Оператор неявного преобразования кортежа из 3 параметров к типу <see cref="T:System.EventArgs`3"/></summary>
            <param name="Args">Кортеж из 3 параметров</param>
            <returns>Аргумент события <see cref="T:System.EventArgs`3"/></returns>
        </member>
        <member name="T:System.EventArgs`4">
            <summary>Аргумент события с 4 типизированными параметрами</summary>
            <typeparam name="TArgument1">Тип аргумента 1</typeparam>
            <typeparam name="TArgument2">Тип аргумента 2</typeparam>
            <typeparam name="TArgument3">Тип аргумента 3</typeparam>
            <typeparam name="TArgument4">Тип аргумента 4</typeparam>
        </member>
        <member name="P:System.EventArgs`4.Argument4">
            <summary>4 параметр аргумента</summary>
        </member>
        <member name="M:System.EventArgs`4.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`4"/></summary>
        </member>
        <member name="M:System.EventArgs`4.#ctor(`0,`1,`2,`3)">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`4"/></summary>
            <param name="Argument1">1 параметр аргумента</param>
            <param name="Argument2">2 параметр аргумента</param>
            <param name="Argument3">3 параметр аргумента</param>
            <param name="Argument4">4 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`4.Deconstruct(`0@,`1@,`2@,`3@)">
            <summary>Деконструктор <see cref="T:System.EventArgs`4"/></summary>
            <param name="Arg1">1 параметр аргумента</param>
            <param name="Arg2">2 параметр аргумента</param>
            <param name="Arg3">3 параметр аргумента</param>
            <param name="Arg4">4 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`4.op_Implicit(System.EventArgs{`0,`1,`2,`3})~System.ValueTuple{`0,`1,`2,`3}">
            <summary>Оператор неявного преобразования типа <see cref="T:System.EventArgs`4"/> к кортежу</summary>
            <param name="Args">Аргумент события <see cref="T:System.EventArgs`4"/></param>
            <returns>Кортеж из 4 параметров</returns>
        </member>
        <member name="M:System.EventArgs`4.op_Implicit(System.ValueTuple{`0,`1,`2,`3})~System.EventArgs{`0,`1,`2,`3}">
            <summary>Оператор неявного преобразования кортежа из 4 параметров к типу <see cref="T:System.EventArgs`4"/></summary>
            <param name="Args">Кортеж из 4 параметров</param>
            <returns>Аргумент события <see cref="T:System.EventArgs`4"/></returns>
        </member>
        <member name="T:System.EventArgs`5">
            <summary>Аргумент события с 5 типизированными параметрами</summary>
            <typeparam name="TArgument1">Тип аргумента 1</typeparam>
            <typeparam name="TArgument2">Тип аргумента 2</typeparam>
            <typeparam name="TArgument3">Тип аргумента 3</typeparam>
            <typeparam name="TArgument4">Тип аргумента 4</typeparam>
            <typeparam name="TArgument5">Тип аргумента 5</typeparam>
        </member>
        <member name="P:System.EventArgs`5.Argument5">
            <summary>5 параметр аргумента</summary>
        </member>
        <member name="M:System.EventArgs`5.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`5"/></summary>
        </member>
        <member name="M:System.EventArgs`5.#ctor(`0,`1,`2,`3,`4)">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`5"/></summary>
            <param name="Argument1">1 параметр аргумента</param>
            <param name="Argument2">2 параметр аргумента</param>
            <param name="Argument3">3 параметр аргумента</param>
            <param name="Argument4">4 параметр аргумента</param>
            <param name="Argument5">5 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`5.Deconstruct(`0@,`1@,`2@,`3@,`4@)">
            <summary>Деконструктор <see cref="T:System.EventArgs`5"/></summary>
            <param name="Arg1">1 параметр аргумента</param>
            <param name="Arg2">2 параметр аргумента</param>
            <param name="Arg3">3 параметр аргумента</param>
            <param name="Arg4">4 параметр аргумента</param>
            <param name="Arg5">5 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`5.op_Implicit(System.EventArgs{`0,`1,`2,`3,`4})~System.ValueTuple{`0,`1,`2,`3,`4}">
            <summary>Оператор неявного преобразования типа <see cref="T:System.EventArgs`5"/> к кортежу</summary>
            <param name="Args">Аргумент события <see cref="T:System.EventArgs`5"/></param>
            <returns>Кортеж из 5 параметров</returns>
        </member>
        <member name="M:System.EventArgs`5.op_Implicit(System.ValueTuple{`0,`1,`2,`3,`4})~System.EventArgs{`0,`1,`2,`3,`4}">
            <summary>Оператор неявного преобразования кортежа из 5 параметров к типу <see cref="T:System.EventArgs`5"/></summary>
            <param name="Args">Кортеж из 5 параметров</param>
            <returns>Аргумент события <see cref="T:System.EventArgs`5"/></returns>
        </member>
        <member name="T:System.EventArgs`6">
            <summary>Аргумент события с 6 типизированными параметрами</summary>
            <typeparam name="TArgument1">Тип аргумента 1</typeparam>
            <typeparam name="TArgument2">Тип аргумента 2</typeparam>
            <typeparam name="TArgument3">Тип аргумента 3</typeparam>
            <typeparam name="TArgument4">Тип аргумента 4</typeparam>
            <typeparam name="TArgument5">Тип аргумента 5</typeparam>
            <typeparam name="TArgument6">Тип аргумента 6</typeparam>
        </member>
        <member name="P:System.EventArgs`6.Argument6">
            <summary>6 параметр аргумента</summary>
        </member>
        <member name="M:System.EventArgs`6.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`6"/></summary>
        </member>
        <member name="M:System.EventArgs`6.#ctor(`0,`1,`2,`3,`4,`5)">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`6"/></summary>
            <param name="Argument1">1 параметр аргумента</param>
            <param name="Argument2">2 параметр аргумента</param>
            <param name="Argument3">3 параметр аргумента</param>
            <param name="Argument4">4 параметр аргумента</param>
            <param name="Argument5">5 параметр аргумента</param>
            <param name="Argument6">6 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`6.Deconstruct(`0@,`1@,`2@,`3@,`4@,`5@)">
            <summary>Деконструктор <see cref="T:System.EventArgs`6"/></summary>
            <param name="Arg1">1 параметр аргумента</param>
            <param name="Arg2">2 параметр аргумента</param>
            <param name="Arg3">3 параметр аргумента</param>
            <param name="Arg4">4 параметр аргумента</param>
            <param name="Arg5">5 параметр аргумента</param>
            <param name="Arg6">6 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`6.op_Implicit(System.EventArgs{`0,`1,`2,`3,`4,`5})~System.ValueTuple{`0,`1,`2,`3,`4,`5}">
            <summary>Оператор неявного преобразования типа <see cref="T:System.EventArgs`6"/> к кортежу</summary>
            <param name="Args">Аргумент события <see cref="T:System.EventArgs`6"/></param>
            <returns>Кортеж из 6 параметров</returns>
        </member>
        <member name="M:System.EventArgs`6.op_Implicit(System.ValueTuple{`0,`1,`2,`3,`4,`5})~System.EventArgs{`0,`1,`2,`3,`4,`5}">
            <summary>Оператор неявного преобразования кортежа из 6 параметров к типу <see cref="T:System.EventArgs`6"/></summary>
            <param name="Args">Кортеж из 6 параметров</param>
            <returns>Аргумент события <see cref="T:System.EventArgs`6"/></returns>
        </member>
        <member name="T:System.EventArgs`7">
            <summary>Аргумент события с 7 типизированными параметрами</summary>
            <typeparam name="TArgument1">Тип аргумента 1</typeparam>
            <typeparam name="TArgument2">Тип аргумента 2</typeparam>
            <typeparam name="TArgument3">Тип аргумента 3</typeparam>
            <typeparam name="TArgument4">Тип аргумента 4</typeparam>
            <typeparam name="TArgument5">Тип аргумента 5</typeparam>
            <typeparam name="TArgument6">Тип аргумента 6</typeparam>
            <typeparam name="TArgument7">Тип аргумента 7</typeparam>
        </member>
        <member name="P:System.EventArgs`7.Argument7">
            <summary>7 параметр аргумента</summary>
        </member>
        <member name="M:System.EventArgs`7.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`7"/></summary>
        </member>
        <member name="M:System.EventArgs`7.#ctor(`0,`1,`2,`3,`4,`5,`6)">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`7"/></summary>
            <param name="Argument1">1 параметр аргумента</param>
            <param name="Argument2">2 параметр аргумента</param>
            <param name="Argument3">3 параметр аргумента</param>
            <param name="Argument4">4 параметр аргумента</param>
            <param name="Argument5">5 параметр аргумента</param>
            <param name="Argument6">6 параметр аргумента</param>
            <param name="Argument7">7 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`7.Deconstruct(`0@,`1@,`2@,`3@,`4@,`5@,`6@)">
            <summary>Деконструктор <see cref="T:System.EventArgs`7"/></summary>
            <param name="Arg1">1 параметр аргумента</param>
            <param name="Arg2">2 параметр аргумента</param>
            <param name="Arg3">3 параметр аргумента</param>
            <param name="Arg4">4 параметр аргумента</param>
            <param name="Arg5">5 параметр аргумента</param>
            <param name="Arg6">6 параметр аргумента</param>
            <param name="Arg7">7 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`7.op_Implicit(System.EventArgs{`0,`1,`2,`3,`4,`5,`6})~System.ValueTuple{`0,`1,`2,`3,`4,`5,`6}">
            <summary>Оператор неявного преобразования типа <see cref="T:System.EventArgs`7"/> к кортежу</summary>
            <param name="Args">Аргумент события <see cref="T:System.EventArgs`7"/></param>
            <returns>Кортеж из 7 параметров</returns>
        </member>
        <member name="M:System.EventArgs`7.op_Implicit(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6})~System.EventArgs{`0,`1,`2,`3,`4,`5,`6}">
            <summary>Оператор неявного преобразования кортежа из 7 параметров к типу <see cref="T:System.EventArgs`7"/></summary>
            <param name="Args">Кортеж из 7 параметров</param>
            <returns>Аргумент события <see cref="T:System.EventArgs`7"/></returns>
        </member>
        <member name="T:System.EventArgs`8">
            <summary>Аргумент события с 8 типизированными параметрами</summary>
            <typeparam name="TArgument1">Тип аргумента 1</typeparam>
            <typeparam name="TArgument2">Тип аргумента 2</typeparam>
            <typeparam name="TArgument3">Тип аргумента 3</typeparam>
            <typeparam name="TArgument4">Тип аргумента 4</typeparam>
            <typeparam name="TArgument5">Тип аргумента 5</typeparam>
            <typeparam name="TArgument6">Тип аргумента 6</typeparam>
            <typeparam name="TArgument7">Тип аргумента 7</typeparam>
            <typeparam name="TArgument8">Тип аргумента 8</typeparam>
        </member>
        <member name="P:System.EventArgs`8.Argument8">
            <summary>8 параметр аргумента</summary>
        </member>
        <member name="M:System.EventArgs`8.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`8"/></summary>
        </member>
        <member name="M:System.EventArgs`8.#ctor(`0,`1,`2,`3,`4,`5,`6,`7)">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`8"/></summary>
            <param name="Argument1">1 параметр аргумента</param>
            <param name="Argument2">2 параметр аргумента</param>
            <param name="Argument3">3 параметр аргумента</param>
            <param name="Argument4">4 параметр аргумента</param>
            <param name="Argument5">5 параметр аргумента</param>
            <param name="Argument6">6 параметр аргумента</param>
            <param name="Argument7">7 параметр аргумента</param>
            <param name="Argument8">8 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`8.Deconstruct(`0@,`1@,`2@,`3@,`4@,`5@,`6@,`7@)">
            <summary>Деконструктор <see cref="T:System.EventArgs`8"/></summary>
            <param name="Arg1">1 параметр аргумента</param>
            <param name="Arg2">2 параметр аргумента</param>
            <param name="Arg3">3 параметр аргумента</param>
            <param name="Arg4">4 параметр аргумента</param>
            <param name="Arg5">5 параметр аргумента</param>
            <param name="Arg6">6 параметр аргумента</param>
            <param name="Arg7">7 параметр аргумента</param>
            <param name="Arg8">8 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`8.op_Implicit(System.EventArgs{`0,`1,`2,`3,`4,`5,`6,`7})~System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,System.ValueTuple{`7}}">
            <summary>Оператор неявного преобразования типа <see cref="T:System.EventArgs`8"/> к кортежу</summary>
            <param name="Args">Аргумент события <see cref="T:System.EventArgs`8"/></param>
            <returns>Кортеж из 8 параметров</returns>
        </member>
        <member name="M:System.EventArgs`8.op_Implicit(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,System.ValueTuple{`7}})~System.EventArgs{`0,`1,`2,`3,`4,`5,`6,`7}">
            <summary>Оператор неявного преобразования кортежа из 8 параметров к типу <see cref="T:System.EventArgs`8"/></summary>
            <param name="Args">Кортеж из 8 параметров</param>
            <returns>Аргумент события <see cref="T:System.EventArgs`8"/></returns>
        </member>
        <member name="T:System.EventArgs`9">
            <summary>Аргумент события с 9 типизированными параметрами</summary>
            <typeparam name="TArgument1">Тип аргумента 1</typeparam>
            <typeparam name="TArgument2">Тип аргумента 2</typeparam>
            <typeparam name="TArgument3">Тип аргумента 3</typeparam>
            <typeparam name="TArgument4">Тип аргумента 4</typeparam>
            <typeparam name="TArgument5">Тип аргумента 5</typeparam>
            <typeparam name="TArgument6">Тип аргумента 6</typeparam>
            <typeparam name="TArgument7">Тип аргумента 7</typeparam>
            <typeparam name="TArgument8">Тип аргумента 8</typeparam>
            <typeparam name="TArgument9">Тип аргумента 9</typeparam>
        </member>
        <member name="P:System.EventArgs`9.Argument9">
            <summary>9 параметр аргумента</summary>
        </member>
        <member name="M:System.EventArgs`9.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`9"/></summary>
        </member>
        <member name="M:System.EventArgs`9.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8)">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`9"/></summary>
            <param name="Argument1">1 параметр аргумента</param>
            <param name="Argument2">2 параметр аргумента</param>
            <param name="Argument3">3 параметр аргумента</param>
            <param name="Argument4">4 параметр аргумента</param>
            <param name="Argument5">5 параметр аргумента</param>
            <param name="Argument6">6 параметр аргумента</param>
            <param name="Argument7">7 параметр аргумента</param>
            <param name="Argument8">8 параметр аргумента</param>
            <param name="Argument9">9 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`9.Deconstruct(`0@,`1@,`2@,`3@,`4@,`5@,`6@,`7@,`8@)">
            <summary>Деконструктор <see cref="T:System.EventArgs`9"/></summary>
            <param name="Arg1">1 параметр аргумента</param>
            <param name="Arg2">2 параметр аргумента</param>
            <param name="Arg3">3 параметр аргумента</param>
            <param name="Arg4">4 параметр аргумента</param>
            <param name="Arg5">5 параметр аргумента</param>
            <param name="Arg6">6 параметр аргумента</param>
            <param name="Arg7">7 параметр аргумента</param>
            <param name="Arg8">8 параметр аргумента</param>
            <param name="Arg9">9 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`9.op_Implicit(System.EventArgs{`0,`1,`2,`3,`4,`5,`6,`7,`8})~System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,System.ValueTuple{`7,`8}}">
            <summary>Оператор неявного преобразования типа <see cref="T:System.EventArgs`9"/> к кортежу</summary>
            <param name="Args">Аргумент события <see cref="T:System.EventArgs`9"/></param>
            <returns>Кортеж из 9 параметров</returns>
        </member>
        <member name="M:System.EventArgs`9.op_Implicit(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,System.ValueTuple{`7,`8}})~System.EventArgs{`0,`1,`2,`3,`4,`5,`6,`7,`8}">
            <summary>Оператор неявного преобразования кортежа из 9 параметров к типу <see cref="T:System.EventArgs`9"/></summary>
            <param name="Args">Кортеж из 9 параметров</param>
            <returns>Аргумент события <see cref="T:System.EventArgs`9"/></returns>
        </member>
        <member name="T:System.EventArgs`10">
            <summary>Аргумент события с 10 типизированными параметрами</summary>
            <typeparam name="TArgument1">Тип аргумента 1</typeparam>
            <typeparam name="TArgument2">Тип аргумента 2</typeparam>
            <typeparam name="TArgument3">Тип аргумента 3</typeparam>
            <typeparam name="TArgument4">Тип аргумента 4</typeparam>
            <typeparam name="TArgument5">Тип аргумента 5</typeparam>
            <typeparam name="TArgument6">Тип аргумента 6</typeparam>
            <typeparam name="TArgument7">Тип аргумента 7</typeparam>
            <typeparam name="TArgument8">Тип аргумента 8</typeparam>
            <typeparam name="TArgument9">Тип аргумента 9</typeparam>
            <typeparam name="TArgument10">Тип аргумента 10</typeparam>
        </member>
        <member name="P:System.EventArgs`10.Argument10">
            <summary>10 параметр аргумента</summary>
        </member>
        <member name="M:System.EventArgs`10.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`10"/></summary>
        </member>
        <member name="M:System.EventArgs`10.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9)">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`10"/></summary>
            <param name="Argument1">1 параметр аргумента</param>
            <param name="Argument2">2 параметр аргумента</param>
            <param name="Argument3">3 параметр аргумента</param>
            <param name="Argument4">4 параметр аргумента</param>
            <param name="Argument5">5 параметр аргумента</param>
            <param name="Argument6">6 параметр аргумента</param>
            <param name="Argument7">7 параметр аргумента</param>
            <param name="Argument8">8 параметр аргумента</param>
            <param name="Argument9">9 параметр аргумента</param>
            <param name="Argument10">10 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`10.Deconstruct(`0@,`1@,`2@,`3@,`4@,`5@,`6@,`7@,`8@,`9@)">
            <summary>Деконструктор <see cref="T:System.EventArgs`10"/></summary>
            <param name="Arg1">1 параметр аргумента</param>
            <param name="Arg2">2 параметр аргумента</param>
            <param name="Arg3">3 параметр аргумента</param>
            <param name="Arg4">4 параметр аргумента</param>
            <param name="Arg5">5 параметр аргумента</param>
            <param name="Arg6">6 параметр аргумента</param>
            <param name="Arg7">7 параметр аргумента</param>
            <param name="Arg8">8 параметр аргумента</param>
            <param name="Arg9">9 параметр аргумента</param>
            <param name="Arg10">10 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`10.op_Implicit(System.EventArgs{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9})~System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,System.ValueTuple{`7,`8,`9}}">
            <summary>Оператор неявного преобразования типа <see cref="T:System.EventArgs`10"/> к кортежу</summary>
            <param name="Args">Аргумент события <see cref="T:System.EventArgs`10"/></param>
            <returns>Кортеж из 10 параметров</returns>
        </member>
        <member name="M:System.EventArgs`10.op_Implicit(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,System.ValueTuple{`7,`8,`9}})~System.EventArgs{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9}">
            <summary>Оператор неявного преобразования кортежа из 10 параметров к типу <see cref="T:System.EventArgs`10"/></summary>
            <param name="Args">Кортеж из 10 параметров</param>
            <returns>Аргумент события <see cref="T:System.EventArgs`10"/></returns>
        </member>
        <member name="T:System.EventHandlerArgs`2">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TArgs">Тип аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.EventHandlerArgs`3">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TResult">Тип результата события</typeparam>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TArgs">Тип аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
            <returns>Результат события</returns>
        </member>
        <member name="T:System.EventHandler`2">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TParameter">Тип параметра аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.EventHandler`3">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TParameter1">Тип параметра 1 аргумента события</typeparam>
            <typeparam name="TParameter2">Тип параметра 2 аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.EventHandler`4">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TParameter1">Тип параметра 1 аргумента события</typeparam>
            <typeparam name="TParameter2">Тип параметра 2 аргумента события</typeparam>
            <typeparam name="TParameter3">Тип параметра 3 аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.EventHandler`5">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TParameter1">Тип параметра 1 аргумента события</typeparam>
            <typeparam name="TParameter2">Тип параметра 2 аргумента события</typeparam>
            <typeparam name="TParameter3">Тип параметра 3 аргумента события</typeparam>
            <typeparam name="TParameter4">Тип параметра 4 аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.EventHandler`6">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TParameter1">Тип параметра 1 аргумента события</typeparam>
            <typeparam name="TParameter2">Тип параметра 2 аргумента события</typeparam>
            <typeparam name="TParameter3">Тип параметра 3 аргумента события</typeparam>
            <typeparam name="TParameter4">Тип параметра 4 аргумента события</typeparam>
            <typeparam name="TParameter5">Тип параметра 5 аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.EventHandler`7">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TParameter1">Тип параметра 1 аргумента события</typeparam>
            <typeparam name="TParameter2">Тип параметра 2 аргумента события</typeparam>
            <typeparam name="TParameter3">Тип параметра 3 аргумента события</typeparam>
            <typeparam name="TParameter4">Тип параметра 4 аргумента события</typeparam>
            <typeparam name="TParameter5">Тип параметра 5 аргумента события</typeparam>
            <typeparam name="TParameter6">Тип параметра 6 аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.EventHandler`8">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TParameter1">Тип параметра 1 аргумента события</typeparam>
            <typeparam name="TParameter2">Тип параметра 2 аргумента события</typeparam>
            <typeparam name="TParameter3">Тип параметра 3 аргумента события</typeparam>
            <typeparam name="TParameter4">Тип параметра 4 аргумента события</typeparam>
            <typeparam name="TParameter5">Тип параметра 5 аргумента события</typeparam>
            <typeparam name="TParameter6">Тип параметра 6 аргумента события</typeparam>
            <typeparam name="TParameter7">Тип параметра 7 аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.EventHandler`9">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TParameter1">Тип параметра 1 аргумента события</typeparam>
            <typeparam name="TParameter2">Тип параметра 2 аргумента события</typeparam>
            <typeparam name="TParameter3">Тип параметра 3 аргумента события</typeparam>
            <typeparam name="TParameter4">Тип параметра 4 аргумента события</typeparam>
            <typeparam name="TParameter5">Тип параметра 5 аргумента события</typeparam>
            <typeparam name="TParameter6">Тип параметра 6 аргумента события</typeparam>
            <typeparam name="TParameter7">Тип параметра 7 аргумента события</typeparam>
            <typeparam name="TParameter8">Тип параметра 8 аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.EventHandler`10">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TParameter1">Тип параметра 1 аргумента события</typeparam>
            <typeparam name="TParameter2">Тип параметра 2 аргумента события</typeparam>
            <typeparam name="TParameter3">Тип параметра 3 аргумента события</typeparam>
            <typeparam name="TParameter4">Тип параметра 4 аргумента события</typeparam>
            <typeparam name="TParameter5">Тип параметра 5 аргумента события</typeparam>
            <typeparam name="TParameter6">Тип параметра 6 аргумента события</typeparam>
            <typeparam name="TParameter7">Тип параметра 7 аргумента события</typeparam>
            <typeparam name="TParameter8">Тип параметра 8 аргумента события</typeparam>
            <typeparam name="TParameter9">Тип параметра 9 аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.EventHandler`11">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TParameter1">Тип параметра 1 аргумента события</typeparam>
            <typeparam name="TParameter2">Тип параметра 2 аргумента события</typeparam>
            <typeparam name="TParameter3">Тип параметра 3 аргумента события</typeparam>
            <typeparam name="TParameter4">Тип параметра 4 аргумента события</typeparam>
            <typeparam name="TParameter5">Тип параметра 5 аргумента события</typeparam>
            <typeparam name="TParameter6">Тип параметра 6 аргумента события</typeparam>
            <typeparam name="TParameter7">Тип параметра 7 аргумента события</typeparam>
            <typeparam name="TParameter8">Тип параметра 8 аргумента события</typeparam>
            <typeparam name="TParameter9">Тип параметра 9 аргумента события</typeparam>
            <typeparam name="TParameter10">Тип параметра 10 аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.EventSenderArgs`2">
            <summary>Аргумент события с типизированным параметром</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TArgument">Тип параметра аргумента</typeparam>
        </member>
        <member name="P:System.EventSenderArgs`2.Sender">
            <summary>Источник события</summary>
        </member>
        <member name="M:System.EventSenderArgs`2.#ctor(`0,`1)">
            <summary>Новый аргумент события с типизированным параметром</summary>
            <param name="Sender">Источник события</param>
            <param name="Argument">Параметр аргумента</param>
        </member>
        <member name="M:System.EventSenderArgs`2.ToString">
            <summary>
            Возвращает объект <see cref="T:System.String"/>, который представляет текущий объект <see cref="T:System.Object"/>.
            </summary>
            <returns>Объект <see cref="T:System.String"/>, представляющий текущий объект <see cref="T:System.Object"/>.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:System.EventSenderArgs`2.op_Implicit(System.EventSenderArgs{`0,`1})~`1">
            <summary>Оператор неявного преобразования аргумента события к типу содержащегося в нём значения </summary>
            <param name="Args">Аргумент события</param>
            <returns>Хранимый объект</returns>
        </member>
        <member name="T:System.EventSenderArgs`4">
            <summary>Аргумент события с двумя типизированными параметрами</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TArgument1">Тип первого параметра</typeparam>
            <typeparam name="TArgument2">Тип второго параметра</typeparam>
            <typeparam name="TArgument3">Тип третьего параметра</typeparam>
        </member>
        <member name="P:System.EventSenderArgs`4.Sender">
            <summary>Источник события</summary>
        </member>
        <member name="M:System.EventSenderArgs`4.#ctor">
            <summary>Новый аргумент события с тремя параметрами</summary>
        </member>
        <member name="M:System.EventSenderArgs`4.#ctor(`0,`1,`2,`3)">
            <summary>Новый аргумент события с тремя параметрами</summary>
            <param name="Sender">Источник события</param>
            <param name="Argument1">Первый аргумент события</param>
            <param name="Argument2">Второй аргумент события</param>
            <param name="Argument3">Третий аргумент события</param>
        </member>
        <member name="T:System.EventSenderArgs`3">
            <summary>Аргумент события с двумя типизированными параметрами</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TArgument1">Тип первого параметра</typeparam>
            <typeparam name="TArgument2">Тип второго параметра</typeparam>
        </member>
        <member name="P:System.EventSenderArgs`3.Sender">
            <summary>Источник события</summary>
        </member>
        <member name="M:System.EventSenderArgs`3.#ctor">
            <summary>Новый аргумент события с двумя параметрами</summary>
        </member>
        <member name="M:System.EventSenderArgs`3.#ctor(`0,`1,`2)">
            <summary>Новый аргумент события с двумя параметрами</summary>
            <param name="Sender">Источник события</param>
            <param name="Argument1">Первый аргумент события</param>
            <param name="Argument2">Второй аргумент события</param>
        </member>
        <member name="T:System.ExceptionEventHandler`1">
            <summary>Обработчик событий генерации исключения</summary>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргументы события</param>
            <typeparam name="TException">Тип исключения</typeparam>
        </member>
        <member name="T:System.ExceptionEventHandlerExtensions">
            <summary>Класс методов расширений для обработчика событий генерации исключений</summary>
        </member>
        <member name="M:System.ExceptionEventHandlerExtensions.Start``1(System.ExceptionEventHandler{``0},System.Object,System.ExceptionEventHandlerArgs{``0})">
            <summary>Генерация события обработки исключения</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
            <typeparam name="TException">Тип исключения</typeparam>
        </member>
        <member name="M:System.ExceptionEventHandlerExtensions.StartAsync``1(System.ExceptionEventHandler{``0},System.Object,System.ExceptionEventHandlerArgs{``0},System.AsyncCallback,System.Object)">
            <summary>Асинхронная генерация события обработки исключения</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
            <param name="CallBack">Делегат завершения вызова события</param>
            <param name="State">Объект состояния, передаваемый в обработчик завершающего метода</param>
            <typeparam name="TException">Тип исключения</typeparam>
        </member>
        <member name="M:System.ExceptionEventHandlerExtensions.FastStart``1(System.ExceptionEventHandler{``0},System.Object,System.ExceptionEventHandlerArgs{``0})">
            <summary>Быстрый запуск события без учёта многопоточных компонентов</summary>
            <param name="Handler">Обработчики события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
            <typeparam name="TException">Тип события</typeparam>
        </member>
        <member name="M:System.ExceptionEventHandlerExtensions.ThrowIfUnhandled``1(System.ExceptionEventHandler{``0},System.Object,System.ExceptionEventHandlerArgs{``0},System.Nullable{System.Boolean})">
            <summary>
            Вызвать <typeparamref name="TException">исключение</typeparamref>, 
            если обработчики его не обработали, либо если кто-либо из обработчиков принял решение вызвать исключение
            </summary>
            <param name="Handler">Обработчики событий</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
            <param name="IsHandledDefault">
            Если истина, то исключение считается обработанным до тех пор, пока обработчик события не укажет обратного
            Если ложь, то обработчики должны явно указать, что исключение обработано.
            По умолчанию значение не определено (= null) - при наличии обработчиков у события исключение считается обработанным. Иначе оно генерируется. 
            </param>
            <typeparam name="TException">Тип исключения</typeparam>
            <exception cref="T:System.Exception"><typeparamref name="TException">Исключение</typeparamref> генерируется при отсутствии обработки его обработчиками события</exception>
        </member>
        <member name="T:System.ExceptionEventHandlerArgs`1">
            <summary>Аргументы события исключения</summary>
            <typeparam name="TException">Тип исключения</typeparam>
        </member>
        <member name="F:System.ExceptionEventHandlerArgs`1._Unhandled">
            <summary>Флаг необходимости генерации исключения</summary>
        </member>
        <member name="F:System.ExceptionEventHandlerArgs`1._IsHandled">
            <summary>Флаг признака обработки исключения обработчиками</summary>
        </member>
        <member name="P:System.ExceptionEventHandlerArgs`1.IsHandled">
            <summary>Исключение обработано</summary>
        </member>
        <member name="P:System.ExceptionEventHandlerArgs`1.NeedToThrow">
            <summary>Признак необходимости генерации исключения</summary>
        </member>
        <member name="M:System.ExceptionEventHandlerArgs`1.#ctor(`0)">
            <summary>Новый аргумент события генерации исключения</summary>
            <param name="Error">Исключение</param>
        </member>
        <member name="M:System.ExceptionEventHandlerArgs`1.Handled">
            <summary>Исключение обработано</summary>
        </member>
        <member name="M:System.ExceptionEventHandlerArgs`1.Unhandled">
            <summary>Исключение должно быть сгенерировано в любом случае</summary>
        </member>
        <member name="T:System.Linq.Expressions.AttributesExtractor">
            <summary>Объект, осуществляющий извлечение атрибута с указанным именем из информации о методе</summary>
        </member>
        <member name="F:System.Linq.Expressions.AttributesExtractor._Info">
            <summary>Информация о методе</summary>
        </member>
        <member name="P:System.Linq.Expressions.AttributesExtractor.Inherit">
            <summary>Искать в данных предков цепочки наследования классов/интерфейсов</summary>
        </member>
        <member name="P:System.Linq.Expressions.AttributesExtractor.Item(System.String)">
            <summary>Атрибут (если найден) с указанным именем</summary>
            <param name="Name">Имя искомого атрибута</param>
            <returns>Атрибут, с указанным именем, либо <see langword="null"/></returns>
        </member>
        <member name="P:System.Linq.Expressions.AttributesExtractor.Item(System.String,System.Boolean)">
            <summary>Атрибут (если найден) с указанным именем</summary>
            <param name="Name">Имя искомого атрибута</param>
            <param name="IsInherit">Искать в данных предков цепочки наследования классов/интерфейсов</param>
            <returns>Атрибут, с указанным именем, либо <see langword="null"/></returns>
        </member>
        <member name="P:System.Linq.Expressions.AttributesExtractor.Item(System.String,System.String)">
            <summary>Получить значение свойства атрибута, определяемое именем атрибута и именем свойства атрибута</summary>
            <param name="Name">Имя искомого атрибута</param>
            <param name="ValueName">Имя свойства атрибута, значение которого надо получить</param>
            <returns>Значение свойства атрибута, если тот был найден и если у него было найдено указанное свойство</returns>
        </member>
        <member name="M:System.Linq.Expressions.AttributesExtractor.#ctor(System.Reflection.MemberInfo)">
            <summary>Инициализация нового экземпляра <see cref="T:System.Linq.Expressions.AttributesExtractor"/></summary>
            <param name="Info">Мета-информация о методе, для для которого надо осуществлять поиск атрибутов</param>
        </member>
        <member name="M:System.Linq.Expressions.AttributesExtractor.GetAttributes(System.String)">
            <summary>Получить все атрибуты с указанным именем</summary>
            <param name="Name">Имя искомых атрибутов</param>
            <returns>Перечисление атрибутов с указанным именем</returns>
        </member>
        <member name="M:System.Linq.Expressions.AttributesExtractor.GetAttributes(System.String,System.Boolean)">
            <summary>Получить все атрибуты с указанным именем</summary>
            <param name="Name">Имя искомых атрибутов</param>
            <param name="IsInherit">Искать в данных предков цепочки наследования классов/интерфейсов</param>
            <returns>Перечисление атрибутов с указанным именем</returns>
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitElementInitializer(System.Linq.Expressions.ElementInit)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitTypeIs(System.Linq.Expressions.TypeBinaryExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitMemberAccess(System.Linq.Expressions.MemberExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitLambda(System.Linq.Expressions.LambdaExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
            <inheritdoc />
        </member>
        <member name="T:System.Linq.Expressions.ExpressionMatrix">
            <summary>Матрица выражений NxM</summary>
            <remarks>
            i (первый индекс) - номер строки, 
            j (второй индекс) - номер столбца
            ------------ j ---------->
            | a11 a12 a13 a14 a15 a16 a1M
            | a21........................
            | a31........................
            | a41.......aij..............
            i a51........................
            | a61........................
            | aN1.....................aNM
            \/
            </remarks>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetUnitaryMatrix(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param>
            <returns>Единичная матрица размерности NxN</returns>
        </member>
        <member name="F:System.Linq.Expressions.ExpressionMatrix._N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="F:System.Linq.Expressions.ExpressionMatrix._M">
            <summary>Число столбцов матриц</summary>
        </member>
        <member name="F:System.Linq.Expressions.ExpressionMatrix._Data">
            <summary>Элементы матрицы</summary>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.Item(System.Int32,System.Int32)">
            <summary>Элемент матрицы</summary>
            <param name="i">Номер строки (элемента в столбце) 0..N-1</param>
            <param name="j">Номер столбца (элемента в строке) 0..M-1</param>
            <returns>Элемент матрицы</returns>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.Item(System.Int32)">
            <summary>Вектор-столбец</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы</returns>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.IsSquare">
            <summary>Матрица является квадратной матрицей</summary>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.IsCol">
            <summary>Матрица является столбцом</summary>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.IsRow">
            <summary>Матрица является строкой</summary>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.IsDigit">
            <summary>Матрица является числом</summary>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.T">
            <summary>Транспонированная матрица</summary>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.#ctor(System.Int32,System.Int32)">
            <summary>Матрица выражения</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.#ctor(System.Int32)">
            <summary>Квадратная матрица выражения</summary>
            <param name="N">Размерность</param>
        </member>
        <member name="T:System.Linq.Expressions.ExpressionMatrix.MatrixItemCreator">
            <summary>Метод определения значения элемента матрицы выражения</summary>
            <param name="i">Номер строки</param>
            <param name="j">Номер столбца</param>
            <returns>Значение элемента матрицы M[<paramref name="i"/>, <paramref name="j"/>]</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.#ctor(System.Int32,System.Linq.Expressions.ExpressionMatrix.MatrixItemCreator)">
            <summary>Квадратная матрица выражения</summary>
            <param name="N">Размерность</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.#ctor(System.Int32,System.Int32,System.Linq.Expressions.ExpressionMatrix.MatrixItemCreator)">
            <summary>Матрица выражения</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="CreateFunction">Порождающая функция f(i,j) - i-строка, j-столбец</param>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetCol(System.Int32)">
            <summary>Получить столбец матрицы</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы номер j</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetRow(System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="i">Номер строки</param>
            <returns>Строка матрицы номер i</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetTriangle">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <returns>Треугольная матрица</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetInverse">
            <summary>Получить обратную матрицу</summary>
            <returns>Обратная матрица</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetTransvection(System.Int32)">
            <summary>Трансвекция матрицы</summary>
            <param name="col">Опорный столбец</param>
            <returns>Трансвекция матрицы А</returns>                    
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetTranspose">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetAdjunct(System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetMinor(System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetDeterminant">
            <summary>Определитель матрицы</summary>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.ToString">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.Clone">
            <summary>Клонирование матрицы</summary>
            <returns>Копия текущей матрицы</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.System#ICloneable#Clone">
            <summary> Создает новый объект, который является копией текущего экземпляра</summary>
            <returns> Новый объект, являющийся копией этого экземпляра </returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.op_Addition(System.Linq.Expressions.ExpressionMatrix,System.Linq.Expressions.ExpressionMatrix)">
            <summary>Оператор сложения двух матриц</summary>
            <param name="A">Первое слагаемое</param>
            <param name="B">Второе слагаемое</param>
            <returns>Сумма двух матриц</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.op_Subtraction(System.Linq.Expressions.ExpressionMatrix,System.Linq.Expressions.ExpressionMatrix)">
            <summary>Оператор разности двух матриц</summary>
            <param name="A">Уменьшаемое</param>
            <param name="B">Вычитаемое</param>
            <returns>Разность двух матриц</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.op_Multiply(System.Linq.Expressions.ExpressionMatrix,System.Linq.Expressions.ExpressionMatrix)">
            <summary>Оператор произведения двух матриц</summary>
            <param name="A">Первый сомножитель</param>
            <param name="B">Второй сомножитель</param>
            <returns>Произведение двух матриц</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.op_Division(System.Linq.Expressions.ExpressionMatrix,System.Linq.Expressions.ExpressionMatrix)">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param>
            <param name="B">Делитель</param>
            <returns>Частное двух матриц</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.op_BitwiseOr(System.Linq.Expressions.ExpressionMatrix,System.Linq.Expressions.ExpressionMatrix)">
            <summary>Конкатенация двух матриц (либо по строкам, либо по столбцам)</summary>
            <param name="A">Первое слагаемое</param>
            <param name="B">Второе слагаемое</param>
            <returns>Объединённая матрица</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.op_Implicit(System.Linq.Expressions.Expression)~System.Linq.Expressions.ExpressionMatrix">
            <summary>Оператор неявного приведения типа вещественного числа двойной точности к типу Матрица порядка 1х1</summary>
            <param name="X">Приводимое число</param><returns>Матрица порядка 1х1</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:System.Linq.Expressions.ExpressionRebuilder">
            <summary>Пересборщик дерева выражения Linq.Expression</summary>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionRebuilder.InvokeEvent``1(System.EventHandlerReturn{System.EventArgs{``0},System.Linq.Expressions.Expression},``0,System.Func{``0,System.Linq.Expressions.Expression})">
            <summary>Метод генерации события посещения узла типа Expression</summary>
            <typeparam name="TExpressionNode">Тип узла дерева</typeparam>
            <param name="Handlers">Событие</param>
            <param name="Node">Узел дерева</param>
            <param name="Base">Базовый метод обработки узла</param>
            <returns>Узел, которым надо заместить посещённый узел дерева</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionRebuilder.InvokeEvent``2(System.EventHandlerReturn{System.EventArgs{``1},``1},``0,System.Func{``0,``1})">
            <summary>Метод генерации события посещения узла произвольного типа</summary>
            <typeparam name="TElement">Тип узла дерева</typeparam><typeparam name="TOut">Тип выходного узла</typeparam>
            <param name="Handlers">Событие</param>
            <param name="Node">Посещённый узел дерева</param>
            <param name="Base">Базовый метод обработки узла</param>
            <returns>Узел, которым надо заместить посещённый узел дерева</returns>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.Visited">
            <summary>Событие возникает при посещении любого узла дерева</summary>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionRebuilder.Visit(System.Linq.Expressions.Expression)">
            <summary>Посетить узел дерева</summary><param name="Node">Узел дерева</param><returns>Новый узел дерева</returns>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.BinaryVisited">
            <summary>Событие возникает при посещении узла дерева бинарного выражения</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.BindingVisited">
            <summary>Событие возникает при посещении узла привязки</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.BindingListVisited">
            <summary>Событие возникает при посещении коллекции привязки</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.ConditionalVisited">
            <summary>Событие возникает при посещении узла условного оператора</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.ConsonantVisited">
            <summary>Событие возникает при посещении узла константы</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.ElementInitializerVisited">
            <summary>Событие возникает при посещении узла инициализатора объекта</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.ElementInitializerListVisited">
            <summary>Событие возникает при посещении коллекции инициализаторов объекта</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.ExpressionListVisited">
            <summary>Событие возникает при посещении коллекции выражений</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.LambdaVisited">
            <summary>Событие возникает при посещении лямбда-выражения</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.ListInitVisited">
            <summary>Событие возникает при посещении узла инициализатора коллекции</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.InvocationVisited">
            <summary>Событие возникает при посещении узла вызова функции</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.MemberAccessVisited">
            <summary>Событие возникает при посещении узла доступа к члену объекта</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.MemberAssignmentVisited">
            <summary>Событие возникает при посещении узла присвоения члену объекта значения</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.MemberInitVisited">
            <summary>Событие возникает при посещении узла инициализатора свойства объекта</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.MemberListBindingVisited">
            <summary>Событие возникает при посещении узла инициализатора коллекции объектов</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.MemberMemberBindingVisited">
            <summary>Событие возникает при посещении узла инициализатора элементов элемента</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.MethodCallVisited">
            <summary>Событие возникает при посещении узла вызова метода</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.NewVisited">
            <summary>Событие возникает при посещении узла конструктора</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.NewArrayVisited">
            <summary>Событие возникает при посещении узла конструктора массива</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.ParameterVisited">
            <summary>Событие возникает при посещении узла параметра выражения</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.TypeIsVisited">
            <summary>Событие возникает при посещении узла определения типа выражения</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.UnaryVisited">
            <summary>Событие возникает при посещении узла унарного выражения</summary>
        </member>
        <member name="T:System.Linq.Expressions.MultiplicationSign">
            <summary>TeX supports several styles for multiplication sign</summary>
        </member>
        <member name="F:System.Linq.Expressions.MultiplicationSign.None">
            <summary>Without any sign</summary>
        </member>
        <member name="F:System.Linq.Expressions.MultiplicationSign.Asterisk">
            <summary>* sign</summary>
        </member>
        <member name="F:System.Linq.Expressions.MultiplicationSign.Times">
            <summary>x sign</summary>
        </member>
        <member name="T:System.Linq.Expressions.Property`1">
            <summary>Свойство класса</summary>
            <typeparam name="T">Тип значения свойства</typeparam>
        </member>
        <member name="E:System.Linq.Expressions.Property`1.PropertyChanged">
            <summary>Событие изменения свойства</summary>
        </member>
        <member name="M:System.Linq.Expressions.Property`1.OnPropertyChanged(System.String)">
            <summary>Метод генерации события изменения свойства</summary>
            <param name="PropertyName">Имя свойства</param>
        </member>
        <member name="F:System.Linq.Expressions.Property`1._PropertyInfo">
            <summary>Информация о свойстве</summary>
        </member>
        <member name="F:System.Linq.Expressions.Property`1._Reader">
            <summary>Метод чтения свойства</summary>
        </member>
        <member name="F:System.Linq.Expressions.Property`1._Writer">
            <summary>Метод записи значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.CanRead">
            <summary>Признак возможности чтения значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.CanWrite">
            <summary>Признак возможности записи значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.Writer">
            <summary>Метод записи значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.Reader">
            <summary>Метод чтения значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.Value">
            <summary>Значение свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.DescriptionAttribute">
            <summary>Свойство доступа к значению атрибута <see cref="T:System.ComponentModel.DescriptionAttribute"/></summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.DisplayName">
            <summary>Отображаемое имя</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.IsNotifyPropertyChanged">
            <summary>Признак реализации объектом-хозяином свойства интерфейса <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></summary>
        </member>
        <member name="M:System.Linq.Expressions.Property`1.#ctor(System.Type,System.String,System.Boolean)">
            <summary>Инициализация доступа к статическому свойству</summary>
            <param name="type">Рассматриваемый тип</param>
            <param name="Name">Имя статического свойства</param>
            <param name="IsPublicOnly">Признак публичности свойства</param>
        </member>
        <member name="M:System.Linq.Expressions.Property`1.#ctor(System.Object,System.String,System.Boolean)">
            <summary>Инициализация доступа к свойству объекта</summary>
            <param name="Obj">Рассматриваемый объект</param>
            <param name="Name">Имя свойства</param>
            <param name="IsPublicOnly">Признак публичности свойства</param>
        </member>
        <member name="M:System.Linq.Expressions.Property`1.#ctor(System.Object,System.Reflection.PropertyInfo,System.Boolean)">
            <summary>Инициализация доступа к свойству объекта</summary>
            <param name="Obj">Рассматриваемый объект</param>
            <param name="info">Информация о свойстве</param>
            <param name="IsPublicOnly">Признак публичности свойства</param>
        </member>
        <member name="M:System.Linq.Expressions.Property`1.LoadAttributes">
            <summary>Чтение сведений из атрибутов</summary>
        </member>
        <member name="T:System.Linq.Expressions.Property">
            <summary>Свойство класса</summary>
        </member>
        <member name="E:System.Linq.Expressions.Property.PropertyChanged">
            <summary>Событие изменения свойства</summary>
        </member>
        <member name="M:System.Linq.Expressions.Property.OnPropertyChanged(System.String)">
            <summary>Метод генерации события изменения свойства</summary>
            <param name="PropertyName">Имя свойства</param>
        </member>
        <member name="F:System.Linq.Expressions.Property._PropertyInfo">
            <summary>Информация о свойстве</summary>
        </member>
        <member name="F:System.Linq.Expressions.Property._Reader">
            <summary>Метод чтения свойства</summary>
        </member>
        <member name="F:System.Linq.Expressions.Property._Writer">
            <summary>Метод записи значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.CanRead">
            <summary>Признак возможности чтения значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.CanWrite">
            <summary>Признак возможности записи значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.Writer">
            <summary>Метод записи значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.Reader">
            <summary>Метод чтения значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.DescriptionAttribute">
            <summary>Свойство доступа к значению атрибута <see cref="T:System.ComponentModel.DescriptionAttribute"/></summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.DisplayName">
            <summary>Отображаемое имя</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.IsNotifyPropertyChanged">
            <summary>Признак реализации объектом-хозяином свойства интерфейса <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.Value">
            <summary>Значение свойства</summary>
        </member>
        <member name="M:System.Linq.Expressions.Property.#ctor(System.Type,System.String,System.Boolean)">
            <summary>Инициализация доступа к статическому свойству</summary>
            <param name="type">Рассматриваемый тип</param>
            <param name="Name">Имя статического свойства</param>
            <param name="IsPublicOnly">Признак публичности свойства</param>
        </member>
        <member name="M:System.Linq.Expressions.Property.#ctor(System.Object,System.String,System.Boolean)">
            <summary>Инициализация доступа к свойству объекта</summary>
            <param name="Obj">Рассматриваемый объект</param>
            <param name="Name">Имя свойства</param>
            <param name="IsPublicOnly">Признак публичности свойства</param>
        </member>
        <member name="M:System.Linq.Expressions.Property.#ctor(System.Object,System.Reflection.PropertyInfo,System.Boolean)">
            <summary>Инициализация доступа к свойству объекта</summary>
            <param name="Obj">Рассматриваемый объект</param>
            <param name="info">Информация о свойстве</param>
            <param name="IsPublicOnly">Признак публичности свойства</param>
        </member>
        <member name="M:System.Linq.Expressions.Property.LoadAttributes">
            <summary>Чтение сведений из атрибутов</summary>
        </member>
        <member name="T:System.Linq.Expressions.TeXEvaluationExpressionVisitor">
            <summary>Класс "посетителя" для "подстановки" актуальных значений в дерево выражения</summary>
        </member>
        <member name="T:System.Linq.Expressions.TeXExpressionVisitor">
            <summary>
            Класс "посетителя", который "изучает" дерево выражения путем переопределения соответствующих
            виртуальных методов базового класса System.Linq.Expressions.ExpressionVisitor
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.TeXExpressionVisitor.VisitPrefixBinary(System.Linq.Expressions.BinaryExpression)">
            <summary>
            Оператор деления \fract требует иного порядка аргументов:
            \frac{arg1}{arg2} 
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="T:System.Linq.IEnumerableExtensions">
            <summary>Класс методов-расширений для интерфейса перечисления</summary>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Dispersion(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Дисперсия значений</summary>
            <param name="enumerable">Объект-источник данных</param>
            <returns>Дисперсия значений</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Dispersion(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>Дисперсия значений</summary>
            <param name="enumerable">Объект-источник данных</param>
            <returns>Дисперсия значений</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Dispersion(System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>Дисперсия значений</summary>
            <param name="enumerable">Объект-источник данных</param>
            <returns>Дисперсия значений</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Dispersion``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
            <summary>Дисперсия значений</summary>
            <param name="enumerable">Объект-источник данных</param>
            <param name="Selector">Метод получения вещественного значения</param>
            <returns>Дисперсия значений</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.InsertBefore``1(System.Collections.Generic.IEnumerable{``0},``0[])">
            <summary>Добавить элемент в начало последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="enumerable">Исходная последовательность элементов</param>
            <param name="values">Добавляемый элемент</param>
            <returns>Результирующая последовательность элементов, в которой добавленный элемент идёт на первом месте</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.InsertBefore``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Добавить элемент в начало последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="enumerable">Исходная последовательность элементов</param>
            <param name="values">Добавляемый элемент</param>
            <returns>Результирующая последовательность элементов, в которой добавленный элемент идёт на первом месте</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetLambdaEnumerable``2(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>Преобразовать объект в перечисление</summary>
            <param name="obj">Объект-источник элементов</param>
            <param name="Creator">Метод извлечения дочерних элементов объекта</param>
            <typeparam name="TObject">Тип объекта</typeparam>
            <typeparam name="TValue">Тип дочерних элементов</typeparam>
            <returns>Перечисление дочерних элементов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Where(System.Collections.Generic.IEnumerable{System.String},System.Text.RegularExpressions.Regex)">
            <summary>Фильтрация последовательности строк по указанному регулярному выражению</summary>
            <param name="strings">Последовательность строк</param>
            <param name="regex">Регулярное выражение-фильтр</param>
            <returns>Последовательность строк, удовлетворяющая регулярному выражению</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.WhereNot(System.Collections.Generic.IEnumerable{System.String},System.Text.RegularExpressions.Regex)">
            <summary>Фильтрация последовательности строк, которые не удовлетворяют регулярному выражению</summary>
            <param name="strings">Фильтруемая последовательность строк</param>
            <param name="regex">Регулярное выражение-фильтр</param>
            <returns>Последовательность строк, которые не удовлетворяют регулярному выражению</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Where(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>Фильтрация последовательности строк по указанному регулярному выражению</summary>
            <param name="strings">Последовательность строк</param>
            <param name="regex">Регулярное выражение-фильтр</param>
            <returns>Последовательность строк, удовлетворяющая регулярному выражению</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.WhereNot(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>Фильтрация последовательности строк, которые не удовлетворяют регулярному выражению</summary>
            <param name="strings">Фильтруемая последовательность строк</param>
            <param name="regex">Регулярное выражение-фильтр</param>
            <returns>Последовательность строк, которые не удовлетворяют регулярному выражению</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.WhereNot``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Выполняет фильтрацию последовательности значений на основе заданного предиката</summary>
            <returns>
            Объект <see cref="T:System.Collections.Generic.IEnumerable`1"/>, содержащий элементы входной последовательности, которые не удовлетворяют условию.
            </returns>
            <param name="enumerable">Объект <see cref="T:System.Collections.Generic.IEnumerable`1"/>, подлежащий фильтрации.</param>
            <param name="NotSelector">Функция для проверки каждого элемента на не соответствие условию.</param>
            <typeparam name="T">Тип элементов последовательности <paramref name="enumerable"/>.</typeparam>
            <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="enumerable"/> или <paramref name="NotSelector"/> — null.</exception>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.TakeWhileNot``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Возвращает цепочку элементов последовательности, удовлетворяющих указанному условию</summary>
            <returns>
            Объект <see cref="T:System.Collections.Generic.IEnumerable`1"/>, содержащий элементы входной последовательности до первого элемента, который не прошел проверку.
            </returns>
            <param name="enumerable">Последовательность, из которой требуется возвратить элементы.</param>
            <param name="NotSelector">Функция для проверки каждого элемента на соответствие условию.</param>
            <typeparam name="T">Тип элементов последовательности <paramref name="enumerable"/>.</typeparam>
            <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="enumerable"/> или <paramref name="NotSelector"/> — null.</exception>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ToArray``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>Преобразование перечисления в массив с преобразованием элементов</summary>
            <typeparam name="T">Тип элементов исходного перечисления</typeparam>
            <typeparam name="TValue">Тип элементов результирующего массива</typeparam>
            <param name="enumerable">Исходное перечисление</param>
            <param name="converter">Метод преобразования элементов</param>
            <returns>
            Если ссылка на исходное перечисление не пуста, то
                Результирующий массив, состоящий из элементов исходного перечисления, преобразованных указанным методом
            иначе
                пустая ссылка на массив
            </returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ToArray``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,``1})">
            <summary>Преобразование перечисления в массив с преобразованием элементов</summary>
            <typeparam name="T">Тип элементов исходного перечисления</typeparam>
            <typeparam name="TValue">Тип элементов результирующего массива</typeparam>
            <param name="enumerable">Исходное перечисление</param>
            <param name="converter">Метод преобразования элементов и индекса элемента</param>
            <returns>
            Если ссылка на исходное перечисление не пуста, то
                Результирующий массив, состоящий из элементов исходного перечисления, преобразованных указанным методом
            иначе
                пустая ссылка на массив
            </returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ToList``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>Преобразование перечисления в список с преобразованием элементов</summary>
            <typeparam name="T">Тип элементов исходного перечисления</typeparam>
            <typeparam name="TValue">Тип элементов результирующего списка</typeparam>
            <param name="enumerable">Исходное перечисление</param>
            <param name="converter">Метод преобразования элементов</param>
            <returns>
            Если ссылка на исходное перечисление не пуста, то
                Результирующий список, состоящий из элементов исходного перечисления, преобразованных указанным методом
            иначе
                пустая ссылка на список
            </returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Aggregate(System.Collections.Generic.IEnumerable{System.String})">
            <summary>Объединение перечисления строк в единую строку с разделителем - переносом строки</summary>
            <param name="Lines">Перечисление строк</param>
            <returns>Если ссылка на перечисление пуста, то пустая ссылка на строку, иначе - объединение строк с разделителем - переносом строки</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.AddTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.ICollection{``0})">
            <summary>Добавить элементы перечисления в коллекцию</summary>
            <typeparam name="T">Тип элемента</typeparam>
            <param name="source">Перечисление добавляемых элементов</param>
            <param name="collection">Коллекция-приёмник элементов</param>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.RemoveFrom``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.ICollection{``0})">
            <summary>Удалить перечисление элементов из коллекции</summary>
            <typeparam name="T">Тип элементов</typeparam>
            <param name="source">Перечисление удаляемых элементов</param>
            <param name="collection">Коллекция, из которой производится удаление</param>
            <returns>Перечисление результатов операций удаления для каждого из элементов исходного перечисления</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.AddToDictionary``2(System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IDictionary{``0,``1},System.Func{``1,``0})">
            <summary>Добавить в словарь</summary>
            <typeparam name="TKey">Тип ключей словаря</typeparam>
            <typeparam name="TValue">Тип значений словаря</typeparam>
            <param name="collection">Коллекция элементов, добавляемых в словарь</param>
            <param name="dictionary">Словарь, в который добавляются элементы</param>
            <param name="converter">Метод определения ключа элемента</param>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ConvertToType``2(System.Collections.Generic.IEnumerable{``0})">
            <summary>Преобразовать последовательность одних элементов в последовательность других элементов с использованием механизма конвертации</summary>
            <typeparam name="TItem">Тип исходных элементов</typeparam>
            <typeparam name="TValue">Тип элементов, в которые преобразуются исходные</typeparam>
            <param name="collection">Последовательность исходных элементов</param>
            <returns>Последовательность элементов преобразованного типа</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.SelectWithLastValue``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``1})">
            <summary>Создать последовательность элементов, каждое значение в которой будет получено на основе двух значений исходной последовательности</summary>
            <typeparam name="TItem">Тип элементов исходной последовательности</typeparam>
            <typeparam name="TValue">Тип элементов последовательности конвертированных элементов</typeparam>
            <param name="collection">Исходная последовательность элементов</param>
            <param name="converter">
            Метод преобразования, в который передаётся исходный элемент последовательности, предыдущий элемент последовательности, 
            и на основе двух этих элементов, он определяет значение элемента результирующей последовательности</param>
            <returns>Последовательность элементов, составляемая из преобразованных элементов исходной последовательности, где метод преобразования учитывает значение предшествующего элемента</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.AtFirst``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>Выполнить действие для первого элемента последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="action">Действие, выполняемое для первого элемента последовательности в момент её перечисления</param>
            <returns>Исходная последовательность элементов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.AtLast``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>Выполнить действие для последнего элемента последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="action">Действие, выполняемое для последнего элемента в момент её перечисления. Если последовательность элементов просмотрена до конца</param>
            <returns>Исходная последовательность элементов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Before``1(System.Collections.Generic.IEnumerable{``0},System.Action)">
            <summary> Выполнить действие до начала перечисления последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="ActionBefore">Действие, выполняемое до начала перечисления элементов последовательности</param>
            <returns>Исходная последовательность элементов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.OnComplete``1(System.Collections.Generic.IEnumerable{``0},System.Action)">
            <summary>Выполнение действия по завершению перечисления коллекции</summary>
            <typeparam name="T">Тип элементов коллекции</typeparam>
            <param name="collection">Коллекция элементов</param>
            <param name="CompleteAction">Действие, выполняемое по завершению перечисления коллекции</param>
            <returns>Исходная последовательность элементов</returns>
        </member>
        <member name="T:System.Linq.IEnumerableExtensions.EnumerableHistory`1">
            <summary>История перечисления последовательности элементов</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
        </member>
        <member name="F:System.Linq.IEnumerableExtensions.EnumerableHistory`1._HistoryLength">
            <summary>Длина истории</summary>
        </member>
        <member name="F:System.Linq.IEnumerableExtensions.EnumerableHistory`1._Queue">
            <summary>Список элементов в истории</summary>
        </member>
        <member name="F:System.Linq.IEnumerableExtensions.EnumerableHistory`1._ObservableObject">
            <summary>Объект-наблюдения за историей</summary>
        </member>
        <member name="P:System.Linq.IEnumerableExtensions.EnumerableHistory`1.Current">
            <summary>Текущий элемент перечисления</summary>
        </member>
        <member name="P:System.Linq.IEnumerableExtensions.EnumerableHistory`1.Length">
            <summary>Длина истории</summary>
        </member>
        <member name="P:System.Linq.IEnumerableExtensions.EnumerableHistory`1.Count">
            <summary>Количество элементов в истории</summary>
        </member>
        <member name="P:System.Linq.IEnumerableExtensions.EnumerableHistory`1.Item(System.Int32)">
            <summary>Доступ к элементам истории начиная с текущего</summary>
            <param name="i">Индекс элемента в истории, где 0 - текущий элемент</param>
            <returns>Элемент истории перечисления</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.EnumerableHistory`1.#ctor(System.Int32)">
            <summary>Инициализация нового экземпляра <see cref="T:System.Linq.IEnumerableExtensions.EnumerableHistory`1"/></summary>
            <param name="HistoryLength">Длина истории</param>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.EnumerableHistory`1.Check">
            <summary>Удаление лишних элементов из истории</summary>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.EnumerableHistory`1.Add(`0)">
            <summary>Добавить элемент в историю перечисления</summary>
            <param name="item">Добавляемый элемент</param>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.EnumerableHistory`1.GetEnumerator">
            <summary>Получить перечислитель истории элементов</summary><returns>Перечислитель истории элементов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.EnumerableHistory`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Получить перечислитель истории элементов</summary><returns>Перечислитель истории элементов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.EnumerableHistory`1.Subscribe(System.IObserver{`0})">
            <summary>Подписка на изменения истории перечисления</summary>
            <param name="observer">Объект-подписчик, уведомляемый об изменениях в истории перечисления</param>
            <returns>Объект, осуществляющий возможность отписаться от уведомлений изменения истории перечисления</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.SelectWithHistory``2(System.Collections.Generic.IEnumerable{``0},System.Func{System.Linq.IEnumerableExtensions.EnumerableHistory{``0},``1},System.Int32)">
            <summary>Преобразование исходной последовательности элементов с учётом указанного размера истории перечисления</summary>
            <typeparam name="TIn">Тип элементов исходной коллекции</typeparam>
            <typeparam name="TOut">Тип элементов результирующей коллекции</typeparam>
            <param name="collection">Исходная коллекция элементов</param>
            <param name="Selector">Метод преобразования элементов коллекции на основе истории их перечисления</param>
            <param name="HistoryLength">Максимальная длина истории перечисления</param>
            <returns>Коллекция элементов, сформированная на основе исходной с учётом истории процесса перечисления исходной коллекции</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetStatistic(System.Collections.Generic.IEnumerable{System.Double},System.Int32)">
            <summary>Оценка статистических параметров перечисления</summary>
            <param name="collection">Перечисление значений, статистику которых требуется получить</param>
            <param name="Length">Размер выборки для оценки</param>
            <returns>Оценка статистики</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.FilterNullValuesFromEnd(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Отбросить нулевые значения с конца перечисления</summary>
            <param name="collection">Фильтруемое перечисление</param>
            <returns>Перечисление чисел, в котором отсутствуют хвостовые нули</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMinMax``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double},``0@,``0@)">
            <summary>Определить минимальное и максимальное значение перечисления</summary>
            <typeparam name="T">Тип элементов перечисления</typeparam>
            <param name="collection">Перечисление, минимум и максимум которого необходимо определить</param>
            <param name="selector">Метод преобразования объектов в вещественные числа</param>
            <param name="Min">Минимальный элемент перечисления</param>
            <param name="Max">Максимальный элемент перечисления</param>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMinMax(System.Collections.Generic.IEnumerable{System.Double},System.Double@,System.Double@)">
            <summary>Определить минимальное и максимальное значение перечисления</summary>
            <param name="collection">Перечисление, минимум и максимум которого необходимо определить</param>
            <param name="Min">Минимальный элемент перечисления</param>
            <param name="Max">Максимальный элемент перечисления</param>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMinMax``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double},``0@,System.Int32@,``0@,System.Int32@)">
            <summary>Определить минимальное и максимальное значение перечисления</summary>
            <typeparam name="T">Тип элементов перечисления</typeparam>
            <param name="collection">Перечисление, минимум и максимум которого необходимо определить</param>
            <param name="selector">Метод преобразования объектов в вещественные числа</param>
            <param name="Min">Минимальный элемент перечисления</param>
            <param name="MinIndex">Индекс минимального элемента в коллекции</param>
            <param name="Max">Максимальный элемент перечисления</param>
            <param name="MaxIndex">Индекс максимального элемента в коллекции</param>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMinMax(System.Collections.Generic.IEnumerable{System.Double},System.Double@,System.Int32@,System.Double@,System.Int32@)">
            <summary>Определить минимальное и максимальное значение перечисления</summary>
            <param name="collection">Перечисление, минимум и максимум которого необходимо определить</param>
            <param name="Min">Минимальный элемент перечисления</param>
            <param name="MinIndex">Индекс минимального элемента в коллекции</param>
            <param name="Max">Максимальный элемент перечисления</param>
            <param name="MaxIndex">Индекс максимального элемента в коллекции</param>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMax``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
            <summary>Определение максимального элемента последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="selector">Метод преобразования элементов в вещественные числа</param>
            <returns>Максимальный элемент последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMax(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Определение максимального элемента последовательности</summary>
            <param name="collection">Последовательность элементов</param>
            <returns>Максимальный элемент последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMax``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double},System.Int32@)">
            <summary>Определение максимального элемента последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="selector">Метод преобразования элементов в вещественные числа</param>
            <param name="index">Индекс максимального элемента в последовательности</param>
            <returns>Максимальный элемент последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMax(System.Collections.Generic.IEnumerable{System.Double},System.Int32@)">
            <summary>Определение максимального элемента последовательности</summary>
            <param name="collection">Последовательность элементов</param>
            <param name="index">Индекс максимального элемента в последовательности</param>
            <returns>Максимальный элемент последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMin``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
            <summary>Определение минимального элемента последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="selector">Метод преобразования элементов в вещественные числа</param>
            <returns>Минимальный элемент последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMin(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Определение минимального элемента последовательности</summary>
            <param name="collection">Последовательность элементов</param>
            <returns>Минимальный элемент последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMin``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double},System.Int32@)">
            <summary>Определение минимального элемента последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="selector">Метод преобразования элементов в вещественные числа</param>
            <param name="index">Индекс минимального элемента в последовательности</param>
            <returns>Минимальный элемент последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMin(System.Collections.Generic.IEnumerable{System.Double},System.Int32@)">
            <summary>Определение минимального элемента последовательности</summary>
            <param name="collection">Последовательность элементов</param>
            <param name="index">Индекс минимального элемента в последовательности</param>
            <returns>Минимальный элемент последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ToSeparatedString``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>Преобразование последовательности элементов в строку с указанной строкой-разделителем</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов, преобразуемая в строку</param>
            <param name="Separator">Строка-разделитель</param>
            <returns>Строка, составленная из строковых эквивалентов элементов входного перечисления, разделённых строкой-разделителем</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ToListFast``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Быстрое преобразование последовательности в список</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="Enum">Последовательность, преобразуемая в список</param>
            <returns>Список элементов последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Sum(System.Collections.Generic.IEnumerable{MathCore.Complex})">
            <summary>Сумма последовательности комплексных чисел</summary>
            <param name="collection">Последовательность комплексных чисел</param>
            <returns>Комплексное число, являющееся суммой последовательности комплексных чисел</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Aggregate``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,System.Int32,``1},System.Int32)">
            <summary>Объединить элементы коллекции</summary>
            <typeparam name="T">Тип элемента коллекции</typeparam>
            <typeparam name="TResult">Тип результата</typeparam>
            <param name="collection">Исходная коллекция элементов</param>
            <param name="Init">Исходное состояние результата объединения</param>
            <param name="func">Метод объединения</param>
            <param name="index">Индекс элемента коллекции</param>
            <returns>Результат объединения коллекции элементов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Contains``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Проверка на наличие элемента в коллекции</summary>
            <typeparam name="T">Тип элемента</typeparam>
            <param name="collection">Проверяемая коллекция</param>
            <param name="selector">Метод выбора</param>
            <returns>Истина, если выполняется предикат хотя бы на одном элементе коллекции</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Find``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Найти элемент в перечислении, удовлетворяющий предикату</summary>
            <param name="collection">Перечисление элементов</param>
            <param name="selector">Предикат выбора</param>
            <typeparam name="T">Тип элементов перечисления</typeparam>
            <returns>Найденный элемент, либо пустая ссылка</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Foreach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>Выполнение действия для всех элементов коллекции</summary>
            <param name="collection">Коллекция элементов</param>
            <param name="Action">Выполняемое действие</param>
            <typeparam name="T">Тип элементов коллекции</typeparam>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Foreach``2(System.Collections.Generic.IEnumerable{``0},``1,System.Action{``0,``1})">
            <summary>Выполнение действия для всех элементов коллекции</summary>
            <param name="collection">Коллекция элементов</param>
            <param name="p">Параметр действия</param>
            <param name="Action">Выполняемое действие</param>
            <typeparam name="T">Тип элементов коллекции</typeparam>
            <typeparam name="TP">Тип параметра процесса перебора</typeparam>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Foreach``3(System.Collections.Generic.IEnumerable{``0},``1,``2,System.Action{``0,``1,``2})">
            <summary>Выполнение действия для всех элементов коллекции</summary>
            <param name="collection">Коллекция элементов</param>
            <param name="p1">Параметр 1 действия</param>
            <param name="p2">Параметр 2 действия</param>
            <param name="Action">Выполняемое действие</param>
            <typeparam name="T">Тип элементов коллекции</typeparam>
            <typeparam name="TP1">Тип параметра 1 процесса перебора</typeparam>
            <typeparam name="TP2">Тип параметра 2 процесса перебора</typeparam>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Foreach``4(System.Collections.Generic.IEnumerable{``0},``1,``2,``3,System.Action{``0,``1,``2,``3})">
            <summary>Выполнение действия для всех элементов коллекции</summary>
            <param name="collection">Коллекция элементов</param>
            <param name="p1">Параметр 1 действия</param>
            <param name="p2">Параметр 2 действия</param>
            <param name="p3">Параметр 3 действия</param>
            <param name="Action">Выполняемое действие</param>
            <typeparam name="T">Тип элементов коллекции</typeparam>
            <typeparam name="TP1">Тип 1 параметра процесса перебора</typeparam>
            <typeparam name="TP2">Тип 2 параметра процесса перебора</typeparam>
            <typeparam name="TP3">Тип 3 параметра процесса перебора</typeparam>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Foreach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32},System.Int32)">
            <summary>Выполнение действия для всех элементов коллекции с указанием индекса элемента</summary>
            <param name="collection">Коллекция элементов</param>
            <param name="Action">Действие над элементом</param>
            <param name="index">Смещение индекса элемента коллекции</param>
            <typeparam name="T">Тип элемента коллекции</typeparam>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Foreach``2(System.Collections.Generic.IEnumerable{``0},``1,System.Action{``0,System.Int32,``1},System.Int32)">
            <summary>Выполнение действия для всех элементов коллекции с указанием индекса элемента</summary>
            <param name="collection">Коллекция элементов</param>
            <param name="p">Параметр действия</param>
            <param name="Action">Действие над элементом</param>
            <param name="index">Смещение индекса элемента коллекции</param>
            <typeparam name="T">Тип элемента коллекции</typeparam>
            <typeparam name="TP">Тип параметра процесса перебора</typeparam>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Foreach``3(System.Collections.Generic.IEnumerable{``0},``1,``2,System.Action{``0,System.Int32,``1,``2},System.Int32)">
            <summary>Выполнение действия для всех элементов коллекции с указанием индекса элемента</summary>
            <param name="collection">Коллекция элементов</param>
            <param name="p1">Параметр действия 1</param>
            <param name="p2">Параметр действия 2</param>
            <param name="Action">Действие над элементом</param>
            <param name="index">Смещение индекса элемента коллекции</param>
            <typeparam name="T">Тип элемента коллекции</typeparam>
            <typeparam name="TP1">Тип параметра процесса перебора 1</typeparam>
            <typeparam name="TP2">Тип параметра процесса перебора 2</typeparam>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Foreach``4(System.Collections.Generic.IEnumerable{``0},``1,``2,``3,System.Action{``0,System.Int32,``1,``2,``3},System.Int32)">
            <summary>Выполнение действия для всех элементов коллекции с указанием индекса элемента</summary>
            <param name="collection">Коллекция элементов</param>
            <param name="p1">Параметр действия 1</param>
            <param name="p2">Параметр действия 2</param>
            <param name="p3">Параметр действия 3</param>
            <param name="Action">Действие над элементом</param>
            <param name="index">Смещение индекса элемента коллекции</param>
            <typeparam name="T">Тип элемента коллекции</typeparam>
            <typeparam name="TP1">Тип параметра процесса перебора 1</typeparam>
            <typeparam name="TP2">Тип параметра процесса перебора 2</typeparam>
            <typeparam name="TP3">Тип параметра процесса перебора 3</typeparam>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.CastLazy``1(System.Collections.IEnumerable)">
            <summary>Ленивое преобразование типов, пропускающее непреобразуемые объекты</summary>
            <param name="collection">Исходное перечисление объектов</param>
            <typeparam name="T">Тип объектов входного перечисления</typeparam>
            <returns>Коллекция объектов преобразованного типа</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.CastLazy``2(System.Collections.Generic.IEnumerable{``0})">
            <summary>Ленивое преобразование типов элементов перечисления</summary>
            <typeparam name="TItem">Тип элементов входной перечисления</typeparam>
            <typeparam name="TValue">Тип элементов перечисления, в который требуется осуществить преобразование</typeparam>
            <param name="collection">Исходная перечисление элементов</param>
            <returns>Перечисление элементов преобразованного типа</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ForeachLazyIf``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Action{``0})">
            <summary>Действие, выполняемое в процессе перебора элементов для всех элементов перечисления при условии выполнения предиката</summary>
            <typeparam name="T">Ип элементов перечисления</typeparam>
            <param name="collection">Перечисление элементов, для которых надо выполнить действие</param>
            <param name="Predicate">Условие выполнения действия</param>
            <param name="Action">Действие, выполняемое для всех элементов перечисления</param>
            <returns>Исходное перечисление</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ForeachLazy``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>Отложенное выполнение указанного действия для каждого элемента последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="Action">Выполняемое действие</param>
            <returns>Последовательность элементов, для элементов которой выполняется отложенное действие</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ForeachLazyLast``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>Выполнение указанного действия на каждом шаге перебора последовательности после выдачи элемента</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="action">Действие, выполняемое после выдачи элемента последовательности</param>
            <returns>Исходная последовательность элементов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ForeachLazy``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32},System.Int32)">
            <summary>Отложенное выполнение действия до перебора элементов последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="Action">Выполняемое действие</param>
            <param name="index">Начальный индекс элемента последовательности</param>
            <returns>Последовательность элементов, для элементов которой которой выполняется действие</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ExistingItems``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Пересечение последовательностей</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="Source">Исходная последовательность элементов</param>
            <param name="Items">Последовательность элементов, пересечение с которой вычисляется</param>
            <returns>Последовательность элементов, входящих как в первую, так и во вторую последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetUnique``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,System.Boolean})">
            <summary>Последовательность уникальных элементов</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="values">Исходная последовательность элементов</param>
            <param name="Comparer">Метод сравнения элементов</param>
            <returns>Последовательность элементов, таких, что ранее они отсутствовали во входной последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetUnique``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Последовательность уникальных элементов</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="values">Исходная последовательность элементов</param>
            <returns>Последовательность элементов, таких, что ранее они отсутствовали во входной последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.MissingItems``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Найти элементы, которые не входят во вторую последовательность</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="Source">Исходная последовательность</param>
            <param name="Items">Последовательность элементов, которых не должно быть в выходной последовательности</param>
            <returns>Последовательность элементов, которые отсутствуют во второй последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Intersection``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Пересечение последовательностей</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="A">Первая последовательность</param>
            <param name="B">Вторая последовательность</param>
            <returns>Массив элементов, входящих и в первую и во вторую последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ItemEquals``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Последовательности элементов поэлементно равны</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="A">Первая последовательность</param>
            <param name="B">Вторая последовательность</param>
            <returns>Истина, если последовательности равны с точностью до элементов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.NotIntersection``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Определение объектов, которые не входят в пересечение двух последовательностей</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="A">Исходная последовательность</param>
            <param name="B">Вторичная последовательность</param>
            <returns>Массив элементов, входящих либо в первую, либо во вторую последовательность</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Xor``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},``0[]@,``0[]@,``0[]@,``0[]@,``0[]@,``0[]@)">
            <summary>Нахождение пересечения элементов двух последовательностей</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="A">Исходная последовательность</param>
            <param name="B">Вторичная последовательность</param>
            <param name="MissingInAFromB">Массив элементов, отсутствующих в первой последовательности</param>
            <param name="MissingInBFromA">Массив элементов, отсутствующих во второй последовательности</param>
            <param name="ExistingInAFromB">Массив элементов, присутствующих в первой последовательности</param>
            <param name="ExistingInBFromA">Массив элементов, присутствующих во второй последовательности</param>
            <param name="Intersection">Пересечение элементов</param>
            <param name="NotIntersection">Остаток от пересечения элементов</param>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ToSeparatedStr``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>Преобразовать последовательность в строку с указанной строкой-разделителем</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность объектов, преобразуемая в строку с разделителями</param>
            <param name="Separator">Разделитель элементов в строке</param>
            <returns>Строка, составленная из строковых представлений объектов последовательности, разделённых указанной строкой-разделителем</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMinMax(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Найти минимум и максимум последовательности вещественных чисел</summary>
            <param name="values">Последовательность вещественных чисел</param>
            <returns>Интервал, границы которого определяют минимум и максимум значений, которые принимала входная последовательность</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.AppendLast``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Добавить элемент в конец последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Исходная последовательность элементов</param>
            <param name="obj">Добавляемый объект</param>
            <returns>Последовательность, составленная из элементов исходной последовательности и добавленного элемента</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.AppendLast``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Добавить последовательность элементов в конец последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="first_collection">Начальная последовательность элементов</param>
            <param name="last_collection">Завершающая последовательность элементов</param>
            <returns>Последовательность элементов, составленная из элементов первичной и вторичной последовательностей</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.AppendFirst``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Добавить объект в начало перечисления</summary>
            <typeparam name="T">Тип объектов перечисления</typeparam>
            <param name="collection">Основное перечисление</param>
            <param name="obj">Объект, добавляемый в начало перечисления</param>
            <returns>Перечисление объектов, составленное из первого объекта и остального перечисления</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.AppendFirst``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Добавить перечисление объектов в начало основного перечисления</summary>
            <typeparam name="T">Тип объектов перечисления</typeparam>
            <param name="last_collection">Первая последовательность объектов</param>
            <param name="first_collection">Вторая последовательность объектов</param>
            <returns>Последовательность объектов, составленная из первой последовательности, за которой следует вторая последовательность</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.InsertAtPos``1(System.Collections.Generic.IEnumerable{``0},``0,System.Int32)">
            <summary>Вставить элемент в указанное положение в последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов, в которую требуется вставить новый элемент</param>
            <param name="obj">Элемент, добавляемый в последовательность</param>
            <param name="pos">Положение в которое требуется вставить элемент</param>
            <returns>Последовательность элементов, в указанной позиции которой будет размещён указанный элемент</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ConcatInverted``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Инверсная конкатенация перечислений</summary>
            <typeparam name="T">Тип элементов перечислений</typeparam>
            <param name="FirstCollection">Исходная последовательность, добавляемая в конец</param>
            <param name="SecondCollection">Вторичная последовательность, добавляемая в начало</param>
            <returns>Последовательность элементов, составленная из элементов вторичной последовательности и элементов первичной последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Sum(System.Collections.Generic.IEnumerable{MathCore.Polynom})">
            <summary>Сумма перечисления полиномов</summary>
            <param name="P">Перечисление полиномов, которые надо сложить</param>
            <returns>Полином, являющийся суммой полиномов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Multiply(System.Collections.Generic.IEnumerable{MathCore.Polynom})">
            <summary>Произведение перечисления полиномов</summary>
            <param name="P">Перечисление полиномов, которые надо перемножить</param>
            <returns>Полином, являющийся произведением полиномов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Decimate``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
            <summary>Проредить последовательность</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Прореживаемая последовательность</param>
            <param name="N">Размер выборки > 0</param>
            <param name="k">Положение в выборке (от 0 до N-1)</param>
            <returns>Последовательность из N-ых элементов выборки, стоящих на k-ом месте</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.TakeFirstAndLast``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Получить первый и последний элементы перечисления</summary>
            <typeparam name="T">Тип элементов перечисления</typeparam>
            <param name="enumerable">Перечисление</param>
            <returns>Перечисление, состоящее из первого и последнего элементов исходного перечисления</returns>
        </member>
        <member name="T:System.Linq.Reactive.IObservableEx`1">
            <summary>Обозреваемый объект</summary>
            <typeparam name="T">Тип объектов последовательности событий</typeparam>
        </member>
        <member name="M:System.Linq.Reactive.IObservableEx`1.Subscribe(System.Linq.Reactive.IObserverEx{`0})">
            <summary>Метод получения наблюдателя</summary>
            <param name="observer">Наблюдатель объекта</param>
            <returns>Объект, реализующий возможность разрушения связи с наблюдаемым объектом</returns>
        </member>
        <member name="T:System.Linq.Reactive.IObserverEx`1">
            <summary>Интерфейс наблюдателя</summary>
            <typeparam name="T">Тип объектов последовательности событий</typeparam>
        </member>
        <member name="E:System.Linq.Reactive.IObserverEx`1.Next">
            <summary>Событие появления следующего объекта последовательности</summary>
        </member>
        <member name="E:System.Linq.Reactive.IObserverEx`1.Completed">
            <summary>Событие завершения последовательности</summary>
        </member>
        <member name="E:System.Linq.Reactive.IObserverEx`1.Reset">
            <summary>Событие сброса последовательности</summary>
        </member>
        <member name="E:System.Linq.Reactive.IObserverEx`1.Error">
            <summary>Событие появления исключения</summary>
        </member>
        <member name="M:System.Linq.Reactive.IObserverEx`1.OnReset">
            <summary>Метод генерации события сброса последовательности</summary>
        </member>
        <member name="T:System.Linq.Reactive.LambdaObservable`1">
            <summary>Наблюдаемый объект с методами обработки событий, задаваемыми лямбда-синтаксисом</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:System.Linq.Reactive.LambdaObservable`1._Observer">
            <summary>Присоединённый наблюдатель</summary>
        </member>
        <member name="F:System.Linq.Reactive.LambdaObservable`1._OnNext">
            <summary>Действие обработки следующего объекта наблюдения</summary>
        </member>
        <member name="F:System.Linq.Reactive.LambdaObservable`1._OnCompleted">
            <summary>Действие обработки завершения процесса наблюдения</summary>
        </member>
        <member name="F:System.Linq.Reactive.LambdaObservable`1._OnReset">
            <summary>Действие обработки сброса состояния наблюдаемого объекта</summary>
        </member>
        <member name="M:System.Linq.Reactive.LambdaObservable`1.OnNext(System.IObserver{`0},`0)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Reactive.LambdaObservable`1.OnCompleted(System.IObserver{`0})">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Reactive.LambdaObservable`1.OnReset(System.Linq.Reactive.IObserverEx{`0})">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Reactive.LambdaObservable`1.OnError(System.IObserver{`0},System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Reactive.LambdaObservable`1.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:System.Linq.Reactive.ObservableExtensions">
            <summary>Методы-расширения интерфейса наблюдаемых объектов <see cref="T:System.Linq.Reactive.IObservableEx`1"/></summary>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.AddObserver``1(System.Collections.Generic.ICollection{System.IObserver{``0}},System.IObserver{``0})">
            <summary>Добавить наблюдатель в список наблюдателей и получить объект-отписчик</summary>
            <typeparam name="T">Тип значений наблюдаемого объекта</typeparam>
            <param name="Observers">Коллекция наблюдателей</param>
            <param name="Observer">Добавляемый наблюдатель</param>
            <returns>Объект, удаляющий наблюдатель из списка наблюдателей в случае своей отписки</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.FromProperty``1(System.ComponentModel.INotifyPropertyChanged,System.String)">
            <summary>Метод получения наблюдаемого объекта для объекта, реализующего интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/>  для указанного имени свойства</summary>
            <typeparam name="T">Тип значения свойства</typeparam>
            <param name="Obj">Наблюдаемый объект</param>
            <param name="ProperName">Имя свойства</param>
            <returns>Объект-наблюдатель за свойством</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.Where``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>Метод фильтрации событий</summary>
            <typeparam name="T">Тип объектов событий</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="Predicate">Метод фильтрации</param>
            <returns>Объект-наблюдатель с установленным методом фильтрации</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.Where``1(System.IObservable{``0},System.Func{``0,System.Boolean},System.Action{``0})">
            <summary>Метод фильтрации событий</summary>
            <typeparam name="T">Тип объектов событий</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="Predicate">Метод фильтрации</param>
            <param name="ElseAction">Метод обработки невошедших событий</param>
            <returns>Объект-наблюдатель с установленным методом фильтрации</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.Select``2(System.IObservable{``0},System.Func{``0,``1})">
            <summary>Метод преобразования объектов событий</summary>
            <typeparam name="T">Тип исходных объектов событий</typeparam>
            <typeparam name="TResult">Тип результирующих объектов событий</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="Selector">Объект-наблюдатель с преобразованными объектами событий</param>
            <returns>Объект-наблюдатель с преобразованными типами объектов</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.WhitSync``1(System.IObservable{``0},System.TimeSpan)">
            <summary>Метод получения синхронно задержанных во времени событий</summary>
            <typeparam name="T">Тип объектов событий</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="Interval">Интервал времени задержки событий</param>
            <returns>Объект-наблюдатель, события которого синхронно задержаны во времени на указанный интервал</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.WhitAsync``1(System.IObservable{``0},System.TimeSpan)">
            <summary>Метод получения задержанных во времени событий</summary>
            <typeparam name="T">Тип объектов событий</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="Interval">Интервал времени задержки событий</param>
            <returns>Объект-наблюдатель, события которого задержаны во времени на указанный интервал</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.FromEvent``1(System.Object,System.String)">
            <summary>Метод получения объекта-наблюдателя для указанного события</summary>
            <typeparam name="TEventArgs">Тип аргументов события</typeparam>
            <param name="Obj">Наблюдаемый объект</param>
            <param name="EventName">Имя события</param>
            <returns>Объект-наблюдатель за событием</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.GetObservable``1(System.Collections.Generic.IEnumerable{``0},System.IObservable{``0}@)">
            <summary>Метод получения объекта-наблюдателя из объекта-перечисления</summary>
            <typeparam name="T">Тип объектов перечисления</typeparam>
            <param name="Enumerable">Перечисление объектов</param>
            <param name="Observable">Созданный объект-наблюдатель за перечислением объектов коллекции</param>
            <returns>Новое перечисление объектов, перечисление объектов которого вызывает события в наблюдателе</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.Take``1(System.IObservable{``0},System.Int32)">
            <summary>Метод получения объекта-наблюдателя, пропускающего после создания указанное число событий</summary>
            <typeparam name="T">Тип объектов события</typeparam>
            <param name="Source">Исходный объект-наблюдатель</param>
            <param name="Count">Количество пропускаемых событий</param>
            <returns>Объект-наблюдатель с указанным количеством пропускаемых событий</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.Take``3(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.Boolean)">
            <summary>Метод обработки последовательности событий с учётом разрешающей и запрещающей последовательностей</summary>
            <typeparam name="TSource">Тип объектов событий наблюдаемого объекта</typeparam>
            <typeparam name="TOpen">Тип объектов событий разрешающей последовательности</typeparam>
            <typeparam name="TClose">Тип объектов событий запрещающей последовательности</typeparam>
            <param name="Observable">Объект-наблюдатель источник событий</param>
            <param name="Open">Объект-наблюдатель разрешающий событий в выходной последовательности</param>
            <param name="Close">Объект-наблюдатель запрещающий событий в выходной последовательности</param>
            <param name="InitialState">Исходное состояния разрешения событий в выходной последовательности (по умолчанию разрешено)</param>
            <returns>Управляемый объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.TakeUntil``2(System.IObservable{``0},System.IObservable{``1},System.Boolean)">
            <summary>Метод получения объекта-наблюдателя, события в котором пропускаются в выходную последовательность только до появления события в управляющей последовательности</summary>
            <typeparam name="T">Тип исходных объектов события</typeparam>
            <typeparam name="TResult">Тип события управляющей последовательности</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="Selector">Объект-наблюдатель управляющей последовательности</param>
            <param name="IsOpen">Исходное состояние выходной последовательности</param>
            <returns>Объект-наблюдатель управляемый управляющей последовательностью</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.SkipWhile``2(System.IObservable{``0},System.IObservable{``1},System.Boolean)">
            <summary>Метод получения объекта-наблюдателя, события в котором пропускаются в выходную последовательность только после появления события в управляющей последовательности</summary>
            <typeparam name="T">Тип исходных объектов события</typeparam>
            <typeparam name="TResult">Тип события управляющей последовательности</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="Selector">Объект-наблюдатель управляющей последовательности</param>
            <param name="IsOpen">Исходное состояние выходной последовательности</param>
            <returns>Объект-наблюдатель управляемый управляющей последовательностью</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.ForeachAction``1(System.IObservable{``0},System.Action{``0})">
            <summary>Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></summary>
            <typeparam name="T">Тип объектов наблюдения</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="Action">Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></param>
            <returns>Исходный объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.Subscribe``1(System.IObservable{``0},System.Action{``0})">
            <summary>Подписаться на уведомления наблюдаемого объекта <see cref="T:System.IObservable`1"/></summary>
            <param name="Source">Источник событий</param>
            <param name="Action">Действие, выполняемое при возникновении события</param>
            <typeparam name="T">Тип значения событий</typeparam>
            <returns>Объект отписки</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.ForeachAction``1(System.IObservable{``0},System.Action{``0},System.Func{``0,System.Boolean})">
            <summary>Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></summary>
            <typeparam name="T">Тип объектов наблюдения</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="Action">Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></param>
            <param name="Where">Метод выборки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></param>
            <returns>Исходный объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.ForeachAction``1(System.IObservable{``0},System.Action{``0,System.Int32})">
            <summary>Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></summary>
            <typeparam name="T">Тип объектов наблюдения</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="Action">Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></param>
            <returns>Исходный объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.ForeachAction``1(System.IObservable{``0},System.Action{``0,System.Int32},System.Func{``0,System.Int32,System.Boolean})">
            <summary>Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></summary>
            <typeparam name="T">Тип объектов наблюдения</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="Action">Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></param>
            <param name="Where">Метод выборки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></param>
            <returns>Исходный объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.OnError``1(System.IObservable{``0},System.Action{System.Exception})">
            <summary>Метод обработки события <see cref="T:System.Exception"/></summary>
            <typeparam name="T">Тип объектов наблюдения</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="OnError">Метод обработки события <see cref="T:System.Exception"/></param>
            <returns>Исходный объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.OnCompleted``1(System.IObservable{``0},System.Action)">
            <summary>Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Completed"/></summary>
            <typeparam name="T">Тип объектов наблюдения</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="OnCompleted">Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Completed"/></param>
            <returns>Исходный объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.OnReset``1(System.IObservable{``0},System.Action)">
            <summary>Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Reset"/></summary>
            <typeparam name="T">Тип объектов наблюдения</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="OnReset">Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Reset"/></param>
            <returns>Исходный объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.FromAsyncPattern``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0})">
            <summary>Создать метод генерации наблюдаемого объекта из шаблона асинхронной операции</summary>
            <typeparam name="T">Тип результата</typeparam>
            <param name="BeginInvoke">Метод начала асинхронной операции</param>
            <param name="EndInvoke">Метод завершения асинхронной операции</param>
            <returns>Функция, возвращающая наблюдаемый объект, генерирующий своё значение в момент завершения асинхронной операции</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.SelectMany``1(System.IObservable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>Метод-лианиризатор событий для наблюдаемого объекта, возвращающего коллекцию объектов типа <see cref="!:T"/></summary>
            <typeparam name="T">Тип результирующих объектов</typeparam>
            <param name="Observable">Объект-наблюдатель коллекции</param>
            <returns>Объект-наблюдатель элементов коллекции</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.Single``1(System.IObservable{``0})">
            <summary>Получить первое значение наблюдаемого объекта</summary>
            <typeparam name="T">Тип значений объекта</typeparam>
            <param name="Observable">Наблюдаемый объект</param>
            <returns>Первое значение наблюдаемого объекта</returns>
        </member>
        <member name="T:System.Linq.Reactive.ObserverLink`1">
            <summary>Класс объектов-связей между наблюдателем и списком наблюдателей, позволяющих удалять наблюдатель из писка наблюдателей в случае если объект удаляется из памяти</summary>
            <typeparam name="T">Тип значений наблюдаемого объекта</typeparam>
        </member>
        <member name="M:System.Linq.Reactive.ObserverLink`1.GetHash(System.Collections.Generic.ICollection{System.IObserver{`0}},System.IObserver{`0})">
            <summary>Получить хэш-код связи</summary>
            <param name="Observers">Коллекция наблюдателей</param>
            <param name="Observer">Добавляемый наблюдатель</param>
            <returns>Хэш-код связи</returns>
        </member>
        <member name="F:System.Linq.Reactive.ObserverLink`1.__Links">
            <summary>Словарь связей</summary>
        </member>
        <member name="M:System.Linq.Reactive.ObserverLink`1.GetLink(System.Collections.Generic.ICollection{System.IObserver{`0}},System.IObserver{`0})">
            <summary>Получить связь между наблюдателем и списком наблюдателей</summary>
            <param name="Observers">Коллекция наблюдателей</param>
            <param name="Observer">Добавляемый наблюдатель</param>
            <returns>Связь между наблюдателем и списком наблюдателей</returns>
        </member>
        <member name="F:System.Linq.Reactive.ObserverLink`1._Observer">
            <summary>Удаляемый наблюдатель</summary>
        </member>
        <member name="F:System.Linq.Reactive.ObserverLink`1._Observers">
            <summary>Коллекция наблюдателей, из которой требуется удалить отслеживаемый наблюдатель</summary>
        </member>
        <member name="F:System.Linq.Reactive.ObserverLink`1._SyncRoot">
            <summary>Объект межпотоковой синхронизации</summary>
        </member>
        <member name="M:System.Linq.Reactive.ObserverLink`1.#ctor(System.Collections.Generic.ICollection{System.IObserver{`0}},System.IObserver{`0})">
            <summary>Инициализация новой связи между списком наблюдателей и отслеживаемым наблюдателем</summary>
            <param name="Observers">Список наблюдателей</param>
            <param name="Observer">Отслеживаемый наблюдатель</param>
        </member>
        <member name="T:System.Linq.Reactive.SimpleObservableEx`1">
            <summary>Простейший наблюдаемый объект</summary><typeparam name="T">Тип объектов событий</typeparam>
        </member>
        <member name="F:System.Linq.Reactive.SimpleObservableEx`1._Observers">
            <summary>Список объектов наблюдателей</summary>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.OnNext(`0)">
            <summary>Метод генерации следующего события</summary>
            <param name="item">Объект события</param>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.OnCompleted">
            <summary>Метод генерации события завершения последовательности</summary>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.OnReset">
            <summary>Метод генерации события сброса последовательности</summary>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.OnError(System.Exception)">
            <summary>Метод генерации события возникновения ошибки</summary>
            <param name="error">Возникшее исключение</param>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.OnError(System.IObserver{`0},System.Exception)">
            <summary>Генерация события возникновения исключения</summary>
            <param name="observer">Наблюдаемый объект, в котором возникло исключение</param>
            <param name="error">Возникшее исключение</param>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.Subscribe(System.Linq.Reactive.IObserverEx{`0})">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.Subscribe(System.IObserver{`0})">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.Dispose">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.Dispose(System.Boolean)">
            <summary>Освобождение ресурсов</summary>
            <param name="Disposing">Если <see langword="true"/>, то выполнить освобождение управляемых ресурсов</param>
        </member>
        <member name="T:System.Linq.Reactive.SimpleObserverEx`1">
            <summary>Простейший наблюдатель</summary>
            <typeparam name="T">Объект события</typeparam>
        </member>
        <member name="E:System.Linq.Reactive.SimpleObserverEx`1.Next">
            <summary>События появления следующего объекта в последовательности</summary>
        </member>
        <member name="E:System.Linq.Reactive.SimpleObserverEx`1.Completed">
            <summary>Событие завершения последовательности</summary>
        </member>
        <member name="E:System.Linq.Reactive.SimpleObserverEx`1.Reset">
            <summary>Событие сброса последовательности</summary>
        </member>
        <member name="E:System.Linq.Reactive.SimpleObserverEx`1.Error">
            <summary>Событие появления исключения</summary>
        </member>
        <member name="P:System.Linq.Reactive.SimpleObserverEx`1.Tag">
            <summary>Тэг наблюдателя</summary>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObserverEx`1.#ctor(System.IObservable{`0})">
            <summary>Инициализация нового простейшего наблюдателя</summary>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObserverEx`1.OnNext(`0)">
            <summary>Метод генерации события появления следующего объекта</summary>
            <param name="item">Следующий объект в последовательности</param>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObserverEx`1.OnError(System.Exception)">
            <summary>Метод генерации события исключительной ситуации</summary>
            <param name="error">Исключительная ситуация</param>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObserverEx`1.OnCompleted">
            <summary>Метод генерации события завершения последовательности</summary>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObserverEx`1.OnReset">
            <summary>Метод генерации события сброса последовательности</summary>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObserverEx`1.Dispose">
            <summary>Освобождение ресурсов и отписка от наблюдаемых объектов</summary>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObserverEx`1.Dispose(System.Boolean)">
            <summary>Освобождение ресурсов и отписка от наблюдаемых объектов</summary>
            <param name="Disposing">Если истина, то выполнить освобождение ресурсов и отписку</param>
        </member>
        <member name="T:System.Linq.Reactive.TakeObservable`1">
            <summary>Наблюдаемый объект с указанным числом генерации событий</summary>
            <typeparam name="T">Тип объектов последовательности</typeparam>
        </member>
        <member name="F:System.Linq.Reactive.TakeObservable`1._Observer">
            <summary>Исходный наблюдатель</summary>
        </member>
        <member name="M:System.Linq.Reactive.TakeObservable`1.#ctor(System.IObservable{`0},System.Int32)">
            <summary>Наблюдаемый объект с указанным числом генерации событий</summary>
            <param name="observable">Исходный наблюдаемый объект</param>
            <param name="Count">Количество извлекаемых событий</param>
        </member>
        <member name="M:System.Linq.Reactive.TimeIntervalObservable.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:System.Linq.Reactive.TriggeredObservable`1">
            <summary>Управляемый наблюдаемый объект</summary>
            <typeparam name="T">Тип объекта последовательности</typeparam>
        </member>
        <member name="F:System.Linq.Reactive.TriggeredObservable`1._Observer">
            <summary>Наблюдатель</summary>
        </member>
        <member name="P:System.Linq.Reactive.TriggeredObservable`1.State">
            <summary>Признак разрешения потока элементов последовательности</summary>
        </member>
        <member name="M:System.Linq.Reactive.TriggeredObservable`1.#ctor(System.IObservable{`0},System.Boolean)">
            <summary>Управляемый наблюдаемый объект</summary>
            <param name="observable">Наблюдаемый объект</param>
            <param name="InitialState">Исходное состояние</param>
        </member>
        <member name="M:System.Linq.Reactive.TriggeredObservable`1.OnNext(`0)">
            <summary>Если состояние <see langword="true"/>, то значения пропускаются в выходную последовательность</summary>
            <param name="item">Объект события</param>
        </member>
        <member name="M:System.Linq.Reactive.TriggeredObservable`1.OnCompleted">
            <summary>Если состояние <see langword="true"/>, то генерирует событие завершения последовательности</summary>
        </member>
        <member name="M:System.Linq.Reactive.TriggeredObservable`1.OnReset">
            <summary>Если состояние <see langword="true"/>, то генерирует событие сброса последовательности</summary>
        </member>
        <member name="M:System.Linq.Reactive.TriggeredObservable`1.OnError(System.Exception)">
            <summary>Если состояние <see langword="true"/>, то генерирует событие возникновения ошибки</summary>
            <param name="error">Возникшее исключение</param>
        </member>
        <member name="M:System.Linq.Reactive.TriggeredObservable`1.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:System.Linq.Reactive.Unit">
            <summary>
            Represents a type with a single value.
            This type is often used to denote the successful completion of a void-returning method (C#)
            or a Sub procedure (Visual Basic).
            </summary>
        </member>
        <member name="P:System.Linq.Reactive.Unit.Default">
            <summary>Gets the single unit value</summary>
        </member>
        <member name="M:System.Linq.Reactive.Unit.op_Equality(System.Linq.Reactive.Unit,System.Linq.Reactive.Unit)">
            <summary>
            Determines whether the two specified Unit values are equal.
            Because Unit has a single value, this always returns true.
            </summary>
            <param name="first">The first Unit value to compare</param>
            <param name="second">The second Unit value to compare</param>
            <returns>Because Unit has a single value, this always returns true</returns>
        </member>
        <member name="M:System.Linq.Reactive.Unit.op_Inequality(System.Linq.Reactive.Unit,System.Linq.Reactive.Unit)">
            <summary>
            Determines whether the two specified Unit values are not equal.
            Because Unit has a single value, this always returns false.
            </summary>
            <param name="first">The first Unit value to compare</param>
            <param name="second">The second Unit value to compare</param>
            <returns>Because Unit has a single value, this always returns false</returns>
        </member>
        <member name="M:System.Linq.Reactive.Unit.Equals(System.Linq.Reactive.Unit)">
            <summary>
            Determines whether the specified Unit values is equal to the current Unit.
            Because Unit has a single value, this always returns true.
            </summary>
            <param name="other">An object to compare to the current Unit value</param>
            <returns>Because Unit has a single value, this always returns true</returns>
        </member>
        <member name="M:System.Linq.Reactive.Unit.Equals(System.Object)">
            <summary>Determines whether the specified System.Object is equal to the current Unit</summary>
            <param name="obj">The System.Object to compare with the current Unit</param>
            <returns>true if the specified System.Object is a Unit value; otherwise, false</returns>
        </member>
        <member name="M:System.Linq.Reactive.Unit.GetHashCode">
            <summary>Returns the hash code for the current Unit value</summary>
            <returns>A hash code for the current Unit value</returns>
        </member>
        <member name="M:System.Linq.Reactive.Unit.ToString">
            <summary>Returns a string representation of the current Unit value</summary>
            <returns>String representation of the current Unit value</returns>
        </member>
        <member name="T:System.ArrayExtensions">
            <summary>Методы расширения для массивов</summary>
        </member>
        <member name="M:System.ArrayExtensions.Deconstruct``1(``0[0:,0:],System.Int32@,System.Int32@)">
            <summary>Деконструктор двумерного массива на размеры по первому и второму измерению</summary>
            <param name="array">Деконструируемый массив</param>
            <param name="N">Число строк (первое измерение)</param>
            <param name="M">Число столбцов (второе измерение)</param>
            <typeparam name="T">Тип элементов массива</typeparam>
        </member>
        <member name="M:System.ArrayExtensions.Deconstruct``1(``0[0:,0:,0:],System.Int32@,System.Int32@,System.Int32@)">
            <summary>Деконструктор трёхмерного массива на размеры по первому, второму и третьему измерению</summary>
            <param name="array">Деконструируемый массив</param>
            <param name="N">Число строк (первое измерение)</param>
            <param name="M">Число столбцов (второе измерение)</param>
            <param name="K">Глубина (третье измерение)</param>
            <typeparam name="T">Тип элементов массива</typeparam>
        </member>
        <member name="M:System.ArrayExtensions.AsRandomEnumerable``1(``0[],System.Random)">
            <summary>Перебрать элементы массива случайным образом без повторений</summary>
            <param name="Items">Массив элементов</param>
            <param name="Rnd">Генератор случайных чисел</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Перечисление элементов массива в случайном порядке</returns>
        </member>
        <member name="M:System.ArrayExtensions.TakeLast``1(``0[],System.Int32)">
            <summary>Получить последовательность из последних элементов массива (в прямом порядке)</summary>
            <param name="Items">Перебираемый массив элементов</param>
            <param name="Count">Число элементов с конца, которые надо перебрать</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Перечисление элементов в конце массива в указанном количестве</returns>
        </member>
        <member name="M:System.ArrayExtensions.TakeLastInverted``1(``0[],System.Int32)">
            <summary>Получить последовательность из последних элементов массива (в обратном порядке)</summary>
            <param name="Items">Перебираемый массив элементов</param>
            <param name="Count">Число элементов с конца, которые надо перебрать</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Перечисление элементов в конце массива в указанном количестве</returns>
        </member>
        <member name="M:System.ArrayExtensions.TakeLastElements``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Получить последние элементы перечисления</summary>
            <param name="Items">Перечисление элементов</param>
            <param name="Count">Количество элементов с конца перечисления, которые требуется получить</param>
            <typeparam name="T">Тип элементов перечисления</typeparam>
            <returns>Перечисление последних <paramref name="Count"/> элементов <paramref name="Items"/></returns>
        </member>
        <member name="M:System.ArrayExtensions.EnumerateElementsByRows``1(``0[0:,0:])">
            <summary>Перечисление элементов двумерного массива по строкам</summary>
            <param name="array">Двумерный массив, элементы которого требуется перечислить</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Перечисление элементов двумерного массива по строкам</returns>
        </member>
        <member name="M:System.ArrayExtensions.EnumerateElementsByCols``1(``0[0:,0:])">
            <summary>Перечисление элементов двумерного массива по столбцам</summary>
            <param name="array">Двумерный массив, элементы которого требуется перечислить</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Перечисление элементов двумерного массива по столбцам</returns>
        </member>
        <member name="M:System.ArrayExtensions.Exist``1(``0[],``0)">
            <summary>Проверка на наличие элемента в массиве</summary>
            <param name="array">Массив, проверка наличия элемента в котором выполняется</param>
            <param name="value">Искомый элемент</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Истина, если элемент найден</returns>
        </member>
        <member name="M:System.ArrayExtensions.NotExist``1(``0[],``0)">
            <summary>Проверка на отсутствие элемента в массиве</summary>
            <param name="array">Массив, проверка отсутствия элемента в котором выполняется</param>
            <param name="value">Искомый элемент</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Истина, если элемент в массиве отсутствует</returns>
        </member>
        <member name="M:System.ArrayExtensions.Split``1(``0[],System.Func{``0,System.Boolean})">
            <summary>Разделить входной массив на подмассивы указанным методом</summary>
            <typeparam name="T">Тип элементов массива</typeparam>
            <param name="array">Разделяемый массив</param>
            <param name="Splitter">Метод, возвращающий истину, когда надо начать новый подмассив</param>
            <returns>
            Массив подмассивов элементов исходного массива, разделённый выбранными указанным методом элементами.
            Выбранные элементы в результат не входят.
            </returns>
        </member>
        <member name="M:System.ArrayExtensions.QuickSort``1(``0[],System.Int32,System.Int32)">
            <summary>Быстрая сортировка Хоара</summary>
            <typeparam name="T">Тип сортируемых элементов</typeparam>
            <param name="A">Сортируемый массив элементов</param>
            <param name="low">Нижняя граница индекса сортировки</param>
            <param name="high">Верхняя граница индекса сортировки</param>
        </member>
        <member name="M:System.ArrayExtensions.QuickSortAsync``1(``0[],System.Int32,System.Int32)">
            <summary>Асинхронная быстрая сортировка Хоара</summary>
            <typeparam name="T">Тип сортируемых элементов</typeparam>
            <param name="A">Сортируемый массив элементов</param>
            <param name="low">Нижняя граница индекса сортировки</param>
            <param name="high">Верхняя граница индекса сортировки</param>
            <returns>Задача, выполняющая процесс быстрой сортировки</returns>
        </member>
        <member name="M:System.ArrayExtensions.QuickSort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>Быстрая сортировка Хоара</summary>
            <typeparam name="T">Тип сортируемых элементов</typeparam>
            <param name="A">Сортируемый массив элементов</param>
            <param name="low">Нижняя граница индекса сортировки</param>
            <param name="high">Верхняя граница индекса сортировки</param>
            <param name="Comparer">Объект, обеспечивающий сравнение двух объектов <typeparamref name="T"/></param>
        </member>
        <member name="M:System.ArrayExtensions.QuickSortAsync``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>Асинхронная быстрая сортировка Хоара</summary>
            <typeparam name="T">Тип сортируемых элементов</typeparam>
            <param name="A">Сортируемый массив элементов</param>
            <param name="low">Нижняя граница индекса сортировки</param>
            <param name="high">Верхняя граница индекса сортировки</param>
            <param name="Comparer">Объект, обеспечивающий сравнение двух объектов <typeparamref name="T"/></param>
            <returns>Задача, выполняющая процесс быстрой сортировки</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetComplexHashCode``1(``0[])">
            <summary>Расчёт хеш-суммы всех элементов массива</summary>
            <typeparam name="T">Тип элементов</typeparam>
            <param name="Objects">Массив элементов</param>
            <returns>Хеш-сумма элементов массива</returns>
        </member>
        <member name="M:System.ArrayExtensions.Concatenate``1(``0[],``0[])">
            <summary>Объединение с массивом элементов</summary>
            <param name="A">Исходный массив</param>
            <param name="B">Присоединяемый массив</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <returns>Массив из объединенных элементов</returns>
        </member>
        <member name="M:System.ArrayExtensions.Concatenate``1(``0[],``0[][])">
            <summary>Конкатенация массивов</summary>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <param name="A">Исходный массив</param>
            <param name="B">Присоединяемые массивы</param>
            <returns>Массив, содержащий все элементы объединяемых массивов</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetSelectedValue``2(``0[],System.Func{``0,``1,``1})">
            <summary>Получить элемент массива</summary>
            <param name="A">Массив элементов</param>
            <param name="Selector">Метод выбора элемента массива</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <typeparam name="TOut">Тип выходного элемента</typeparam>
            <returns>Выбранный элемент массива</returns>
        </member>
        <member name="M:System.ArrayExtensions.ConvertTo``2(``0[],System.Converter{``0,``1})">
            <summary>Преобразовать тип элементов массива</summary>
            <param name="In">Исходный массив элементов</param>
            <param name="converter">Метод преобразования элемента массива</param>
            <typeparam name="TIn">Исходный тип элементов массива</typeparam>
            <typeparam name="TOut">Требуемый тип элементов массива</typeparam>
            <returns>Массив преобразованных элементов</returns>
        </member>
        <member name="M:System.ArrayExtensions.Foreach``1(``0[],System.Action{``0})">
            <summary>Выполнение действия для всех элементов массива</summary>
            <param name="array">Массив элементов</param>
            <param name="action">Выполняемой действие</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
        </member>
        <member name="M:System.ArrayExtensions.Foreach``1(``0[],System.Action{``0},System.Func{System.Exception,System.Boolean})">
            <summary>Выполнение действия для всех элементов массива с обработкой исключений</summary>
            <param name="array">Массив элементов</param>
            <param name="action">Выполняемое действие</param>
            <param name="ErrorHandler">Обработчик исключения</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
        </member>
        <member name="M:System.ArrayExtensions.Foreach``2(``0[],System.Action{``0},System.Func{``1,System.Boolean})">
            <summary>Выполнение действия для всех элементов массива</summary>
            <param name="array">Массив элементов</param>
            <param name="action">Выполняемое действие</param>
            <param name="ErrorHandler">Обработчик исключений</param>
            <exception cref="T:System.ApplicationException">Возникает в случае если в методе action возникшее исключение не было обработано</exception>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <typeparam name="TException">Тип исключений</typeparam>
        </member>
        <member name="M:System.ArrayExtensions.Function``2(``0[],System.Func{``0,``1})">
            <summary>Определение значения функции для всех элементов массива</summary>
            <param name="array">Массив элементов</param>
            <param name="f">Вычисляемая функция</param>
            <typeparam name="TIn">Тип элементов массива области определения</typeparam>
            <typeparam name="TOut">Тип элементов массива области значения</typeparam>
            <returns>Массив значений функции</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetReversed``1(``0[])">
            <summary>Получить массив, индексы элементов которого имеют обратный порядок</summary>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <param name="array">Переворачиваемый массив</param>
            <returns>Перевёрнутый массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetSubArray``1(``0[],System.Int32,System.Int32)">
            <summary>Извлечь подмассив</summary>
            <param name="array">Исходный массив</param>
            <param name="Length">Длина извлекаемого участка</param>
            <param name="Start">Начальное положение</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <returns>
            Новый экземпляр массива, содержащий последовательность элементов
            начиная с указанного <paramref name="Start"/> положения и указанной длины <paramref name="Length"/>
            </returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``1(``0[],System.Func{System.Int32,``0})">
            <summary>Инициализация массива</summary>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <param name="array">Инициализируемый массив</param>
            <param name="Initializer">
            Метод инициализации, получающий в качестве параметра номер элемента,
            а результатом его вызова должно быть значение, помещаемое в ячейку массива
            </param>
            <returns>Инициализированный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``1(``0[],``0)">
            <summary>Инициализация массива одним значением</summary>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <param name="array">Инициализируемый массив</param>
            <param name="value">Значение, размещаемое во всех элементах массива</param>
            <returns>Инициализированный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``2(``0[],``1,System.Func{System.Int32,``1,``0})">
            <summary>Инициализация массива</summary>
            <typeparam name="TValue">Тип элементов массива</typeparam>
            <typeparam name="TP">Тип параметра инициализации</typeparam>
            <param name="array">Инициализируемый массив</param>
            <param name="p">Параметр инициализации</param>
            <param name="Initializer">Метод инициализации</param>
            <returns>Инициализированный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``3(``0[],``1,``2,System.Func{System.Int32,``1,``2,``0})">
            <summary>Инициализация массива</summary>
            <typeparam name="TValue">Тип элементов массива</typeparam>
            <typeparam name="TP1">Тип первого параметра инициализации</typeparam>
            <typeparam name="TP2">Тип второго параметра инициализации</typeparam>
            <param name="array">Инициализируемый массив</param>
            <param name="p1">Первый параметр инициализации</param>
            <param name="p2">Второй параметр инициализации</param>
            <param name="Initializer">Метод инициализации</param>
            <returns>Инициализированный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``1(``0[],System.Func{``0,System.Int32,``0})">
            <summary>Инициализация массива</summary>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <param name="array">Инициализируемый массив</param>
            <param name="Initializer">
            Метод инициализации, получающий в качестве параметров инициализируемый массив и номер элемента,
            а результатом его вызова должно быть значение, помещаемое в ячейку массива
            </param>
            <returns>Инициализированный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``2(``0[],``1,System.Func{``0,System.Int32,``1,``0})">
            <summary>Инициализация массива</summary>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <typeparam name="TP">Тип параметра инициализации</typeparam>
            <param name="array">Инициализируемый массив</param>
            <param name="p">Параметр инициализации</param>
            <param name="Initializer">
            Метод инициализации, получающий в качестве параметров инициализируемый массив
            и номер элемента и параметр <paramref name="p"/>, 
            а результатом его вызова должно быть значение, помещаемое в ячейку массива
            </param>
            <returns>Инициализированный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``3(``0[],``1,``2,System.Func{``0,System.Int32,``1,``2,``0})">
            <summary>Инициализация массива</summary>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <typeparam name="TP1">Тип 1 параметра инициализации</typeparam>
            <typeparam name="TP2">Тип 2 параметра инициализации</typeparam>
            <param name="array">Инициализируемый массив</param>
            <param name="p1">Параметр 1 инициализации</param>
            <param name="p2">Параметр 2 инициализации</param>
            <param name="Initializer">
            Метод инициализации, получающий в качестве параметров инициализируемый массив
            и номер элемента, параметр <paramref name="p1"/> и параметр <paramref name="p2"/>, 
            а результатом его вызова должно быть значение, помещаемое в ячейку массива
            </param>
            <returns>Инициализированный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``1(``0[0:,0:],System.Func{System.Int32,System.Int32,``0})">
            <summary>Инициализация двумерного массива</summary>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <param name="array">Инициализируемый двумерный массив</param>
            <param name="Initializer">
            Метод инициализации, получающий в качестве параметра номер строки и номер столбца элемента,
            а результатом его вызова должно быть значение, помещаемое в ячейку массива
            </param>
            <returns>Инициализированный двумерный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``2(``0[0:,0:],``1,System.Func{System.Int32,System.Int32,``1,``0})">
            <summary>Инициализация двумерного массива</summary>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <typeparam name="TP">Тип параметра инициализации</typeparam>
            <param name="array">Инициализируемый двумерный массив</param>
            <param name="p">Параметр инициализации</param>
            <param name="Initializer">
            Метод инициализации, получающий в качестве параметра номер строки и номер столбца элемента,
            параметр инициализации <paramref name="p"/>
            а результатом его вызова должно быть значение, помещаемое в ячейку массива
            </param>
            <returns>Инициализированный двумерный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``3(``0[0:,0:],``1,``2,System.Func{System.Int32,System.Int32,``1,``2,``0})">
            <summary>Инициализация двумерного массива</summary>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <typeparam name="TP1">Тип 1 параметра инициализации</typeparam>
            <typeparam name="TP2">Тип 2 параметра инициализации</typeparam>
            <param name="array">Инициализируемый двумерный массив</param>
            <param name="p1">Параметр 1 инициализации</param>
            <param name="p2">Параметр 2 инициализации</param>
            <param name="Initializer">
            Метод инициализации, получающий в качестве параметра номер строки и номер столбца элемента,
            параметры инициализации <paramref name="p1"/> и <paramref name="p2"/>
            а результатом его вызова должно быть значение, помещаемое в ячейку массива
            </param>
            <returns>Инициализированный двумерный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``4(``0[0:,0:],``1,``2,``3,System.Func{System.Int32,System.Int32,``1,``2,``3,``0})">
            <summary>Инициализация двумерного массива</summary>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <typeparam name="TP1">Тип 1 параметра инициализации</typeparam>
            <typeparam name="TP2">Тип 2 параметра инициализации</typeparam>
            <typeparam name="TP3">Тип 3 параметра инициализации</typeparam>
            <param name="array">Инициализируемый двумерный массив</param>
            <param name="p1">Параметр 1 инициализации</param>
            <param name="p2">Параметр 2 инициализации</param>
            <param name="p3">Параметр 3 инициализации</param>
            <param name="Initializer">
            Метод инициализации, получающий в качестве параметра номер строки и номер столбца элемента,
            параметры инициализации <paramref name="p1"/>, <paramref name="p2"/> и <paramref name="p3"/>
            а результатом его вызова должно быть значение, помещаемое в ячейку массива
            </param>
            <returns>Инициализированный двумерный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``1(``0[][],System.Func{System.Int32,``0[]},System.Func{System.Int32,System.Int32,``0})">
            <summary>Инициализация невыровненного двумерного массива элементов</summary>
            <typeparam name="TArray">Тип элементов массивов</typeparam>
            <param name="array">Инициализируемый невыровненный массив</param>
            <param name="ArrayInitializer">
            Метод создания очередного одномерного массива, получающий в качестве параметра индекс инициализируемого
            одномерного массива, а в результате своей работы он должен вернуть одномерный массив элементов,
            который будет помещён в ячейку массива верхнего уровня
            </param>
            <param name="Initializer">
            Метод инициализации, получающий в качестве параметра индекс массива и индекс элемента
            в одномерном массиве, а результатом его вызова должно быть значение, помещаемое в ячейку массива
            </param>
            <returns>Инициализированный невыровненный двумерный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``2(``0[][],``1,System.Func{System.Int32,``1,``0[]},System.Func{System.Int32,System.Int32,``1,``0})">
            <summary>Инициализация невыровненного двумерного массива элементов</summary>
            <typeparam name="TArray">Тип элементов массивов</typeparam>
            <typeparam name="TP">Тип параметра инициализации</typeparam>
            <param name="array">Инициализируемый невыровненный массив</param>
            <param name="p">Параметр процесса инициализации</param>
            <param name="ArrayInitializer">
            Метод создания очередного одномерного массива, получающий в качестве параметра индекс инициализируемого
            одномерного массива и параметр, а в результате своей работы он должен вернуть одномерный массив
            элементов, который будет помещён в ячейку массива верхнего уровня
            </param>
            <param name="Initializer">
            Метод инициализации, получающий в качестве параметра индекс массива и индекс элемента
            в одномерном массиве, а также параметр инициализации, а результатом его вызова должно быть значение,
            помещаемое в ячейку массива
            </param>
            <returns>Инициализированный невыровненный двумерный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``3(``0[][],``1,``2,System.Func{System.Int32,``1,``2,``0[]},System.Func{System.Int32,System.Int32,``1,``2,``0})">
            <summary>Инициализация невыровненного двумерного массива элементов</summary>
            <typeparam name="TArray">Тип элементов массивов</typeparam>
            <typeparam name="TP1">Тип 1 параметра инициализации</typeparam>
            <typeparam name="TP2">Тип 2 параметра инициализации</typeparam>
            <param name="array">Инициализируемый невыровненный массив</param>
            <param name="p1">Параметр 1 процесса инициализации</param>
            <param name="p2">Параметр 2 процесса инициализации</param>
            <param name="ArrayInitializer">
            Метод создания очередного одномерного массива, получающий в качестве параметра индекс инициализируемого
            одномерного массива и два параметра, а в результате своей работы он должен вернуть одномерный массив
            элементов, который будет помещён в ячейку массива верхнего уровня
            </param>
            <param name="Initializer">
            Метод инициализации, получающий в качестве параметра индекс массива и индекс элемента
            в одномерном массиве, а также два параметра инициализации, а результатом его вызова должно быть
            значение, помещаемое в ячейку массива
            </param>
            <returns>Инициализированный невыровненный двумерный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``4(``0[][],``1,``2,``3,System.Func{System.Int32,``1,``2,``3,``0[]},System.Func{System.Int32,System.Int32,``1,``2,``3,``0})">
            <summary>Инициализация невыровненного двумерного массива элементов</summary>
            <typeparam name="TArray">Тип элементов массивов</typeparam>
            <typeparam name="TP1">Тип 1 параметра инициализации</typeparam>
            <typeparam name="TP2">Тип 2 параметра инициализации</typeparam>
            <typeparam name="TP3">Тип 3 параметра инициализации</typeparam>
            <param name="array">Инициализируемый невыровненный массив</param>
            <param name="p1">Параметр 1 процесса инициализации</param>
            <param name="p2">Параметр 2 процесса инициализации</param>
            <param name="p3">Параметр 3 процесса инициализации</param>
            <param name="ArrayInitializer">
            Метод создания очередного одномерного массива, получающий в качестве параметра индекс инициализируемого
            одномерного массива и три параметра, а в результате своей работы он должен вернуть одномерный массив
            элементов, который будет помещён в ячейку массива верхнего уровня
            </param>
            <param name="Initializer">
            Метод инициализации, получающий в качестве параметра индекс массива и индекс элемента
            в одномерном массиве, а также три параметра инициализации, а результатом его вызова должно быть
            значение, помещаемое в ячейку массива
            </param>
            <returns>Инициализированный невыровненный двумерный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Reverse``1(``0[])">
            <summary>Обращение порядка элементов в массиве</summary>
            <param name="array">
            Обращаемый массив, порядок следования элементов которого требуется перевернуть
            </param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на исходный массив</exception>
        </member>
        <member name="M:System.ArrayExtensions.SetValues``1(``0[],System.Int32,``0[])">
            <summary>Установить значения ячеек массива</summary>
            <param name="array">Массив, значения ячеек которого требуется установить</param>
            <param name="StartIndex">Индекс первой устанавливаемой ячейки</param>
            <param name="Values">Значения, Которые требуется внести с <paramref name="array"/></param>
            <typeparam name="TArray">Тип ячеек массива</typeparam>
        </member>
        <member name="M:System.ArrayExtensions.ToAlignedRows``1(``0[][])">
            <summary>
            Преобразование массива массивов в двумерный массив, где исходные массивы располагаются построчно
            </summary>
            <param name="array">Массив массивов элементов</param>
            <typeparam name="TArray">Тим элементов</typeparam>
            <returns>Двумерный массив, составленный построчно из исходных массивов</returns>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на исходный массив</exception>
        </member>
        <member name="M:System.ArrayExtensions.ToAlignedCols``1(``0[][])">
            <summary>
            Преобразование массива массивов в двумерный массив, где исходные массивы располагаются по столбцам
            </summary>
            <param name="array">Массив массивов элементов</param>
            <typeparam name="TArray">Тим элементов</typeparam>
            <returns>Двумерный массив, составленный из исходных массивов, расположенных по столбцам</returns>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на исходный массив</exception>
        </member>
        <member name="M:System.ArrayExtensions.ToNonAlignedRows``1(``0[0:,0:])">
            <summary>Преобразовать двумерный массив в массив массивов элементов строк</summary>
            <param name="array">Исходный двумерный массив</param>
            <typeparam name="TArray">Тип элементов массивов</typeparam>
            <returns>Массив строк двумерного массива <paramref name="array"/></returns>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на исходный массив</exception>
        </member>
        <member name="M:System.ArrayExtensions.ToNonAlignedCols``1(``0[0:,0:])">
            <summary>Преобразовать двумерный массив в массив массивов элементов столбцов</summary>
            <param name="array">Исходный двумерный массив</param>
            <typeparam name="TArray">Тип элементов массивов</typeparam>
            <returns>Массив столбцов двумерного массива <paramref name="array"/></returns>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на исходный массив</exception>
        </member>
        <member name="M:System.ArrayExtensions.SetCol``1(``0[0:,0:],``0[],System.Int32)">
            <summary>Установить значения колонки (второй индекс) двумерного массива</summary>
            <param name="array">Двумерный массив, значение столбца которого требуется установить</param>
            <param name="Col">Массив элементов столбца, которые надо установить в <paramref name="array"/></param>
            <param name="m">Номер колонки (второй индекс массива)</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на исходный массив</exception>
            <exception cref="T:System.ArgumentException">
            Если длина <paramref name="Col"/> неравна числу строк (первая размерность) <paramref name="array"/>
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Если номер колонки <paramref name="m"/> больше, либо равен числу колонок массива (вторая размерность)
            <paramref name="array"/>, либо меньше 0
            </exception>
        </member>
        <member name="M:System.ArrayExtensions.SetRow``1(``0[0:,0:],``0[],System.Int32)">
            <summary>Установить значения строки (первый индекс) двумерного массива</summary>
            <param name="array">Двумерный массив, значение строки которого требуется установить</param>
            <param name="Row">Массив элементов строки, которые надо установить в <paramref name="array"/></param>
            <param name="n">Номер строки (первый индекс массива)</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на исходный массив</exception>
            <exception cref="T:System.ArgumentException">Если длина <paramref name="Row"/> неравна числу столбцов (вторая размерность) <paramref name="array"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Если номер колонки <paramref name="n"/> больше, либо равен числу строк массива (первая размерность)
            <paramref name="array"/>, либо меньше 0
            </exception>
        </member>
        <member name="M:System.ArrayExtensions.GetCol``1(``0[0:,0:],System.Int32)">
            <summary>Получить столбец двумерного массива (второй индекс)</summary>
            <param name="array">Двумерный массив из которого требуется извлечь столбец значений</param>
            <param name="m">Номер столбца массива (второй индекс)</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <returns>
            Новый массив, значения которого скопированы из столбца элементов двумерного массива
            с выбранным индексом <paramref name="m"/>
            </returns>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на исходный массив</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Если номер столбца больше, либо равен числу столбцов массива (вторая размерность), либо меньше 0
            </exception>
        </member>
        <member name="M:System.ArrayExtensions.GetCol``1(``0[0:,0:],System.Int32,``0[]@)">
            <summary>Получить столбец двумерного массива (второй индекс)</summary>
            <param name="array">Двумерный массив из которого требуется извлечь столбец значений</param>
            <param name="m">Номер столбца массива (второй индекс)</param>
            <param name="Col">Массив столбца (если передана пустая ссылка, то будет создан новый)</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на исходный массив</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Если номер столбца больше, либо равен числу столбцов массива (вторая размерность), либо меньше 0
            </exception>
            <exception cref="T:System.ArgumentException">
            Если размер массива, переданного для копирования элементов столбца,
            не равен числу строк исходного двумерного массива
            </exception>
        </member>
        <member name="M:System.ArrayExtensions.GetRow``1(``0[0:,0:],System.Int32)">
            <summary>Получить строку двумерного массива (первый индекс)</summary>
            <param name="array">Двумерный массив из которого требуется извлечь строку значений</param>
            <param name="n">Номер строки массива (первый индекс)</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <returns>Новый массив, значения которого скопированы из строки элементов двумерного массива с выбранным индексом <paramref name="n"/></returns>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на исходный массив</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Если номер строки больше, либо равен числу строк массива (первая размерность), либо меньше 0</exception>
        </member>
        <member name="M:System.ArrayExtensions.GetRow``1(``0[0:,0:],System.Int32,``0[]@)">
            <summary>Получить строку двумерного массива (первый индекс)</summary>
            <param name="array">Двумерный массив из которого требуется извлечь строку значений</param>
            <param name="n">Номер строки массива (первый индекс)</param>
            <param name="Row">Массив строки (если передана пустая ссылка, то будет создан новый)</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на исходный массив</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Если номер строки больше, либо равен числу строк массива (первая размерность), либо меньше 0
            </exception>
        </member>
        <member name="M:System.ArrayExtensions.SwapRows``1(``0[0:,0:],System.Int32,System.Int32)">
            <summary>Поменять местами элементы двух строк двумерного массива</summary>
            <param name="array">Массив в котором требуется поменять местами две строки</param>
            <param name="i1">Индекс первой строки</param>
            <param name="i2">Индекс второй строки</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на исходный массив</exception>
        </member>
        <member name="M:System.ArrayExtensions.SwapCols``1(``0[0:,0:],System.Int32,System.Int32)">
            <summary>Поменять местами два столбца двумерного массива</summary>
            <param name="array">Массив в котором требуется поменять местами два столбца</param>
            <param name="j1">Индекс первого столбца</param>
            <param name="j2">Индекс второго столбца</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на исходный массив</exception>
        </member>
        <member name="M:System.ArrayExtensions.GetMinIndex``1(``0[],System.Comparison{``0})">
            <summary>Найти индекс минимального элемента в массиве</summary>
            <param name="array">Массив элементов</param>
            <param name="compare">Метод сравнения двух объектов между собой</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Индекс минимального элемента</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinRef``1(``0[],System.Comparison{``0})">
            <summary>Найти минимальный элемента в массиве и получить ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <param name="compare">Метод сравнения двух объектов между собой</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Минимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinRef``1(``0[],System.Comparison{``0},System.Int32@)">
            <summary>Найти минимальный элемента в массиве и получить ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <param name="compare">Метод сравнения двух объектов между собой</param>
            <param name="MinIndex">Индекс минимального элемента</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Минимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinIndex``1(``0[],System.Collections.Generic.IComparer{``0})">
            <summary>Найти индекс минимального элемента в массиве</summary>
            <param name="array">Массив элементов</param>
            <param name="Comparer">Объект, обеспечивающий сравнение двух элементов в массиве</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Индекс минимального элемента</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinRef``1(``0[],System.Collections.Generic.IComparer{``0})">
            <summary>Найти минимальный элемент в массиве и получить ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <param name="Comparer">Объект, обеспечивающий сравнение двух элементов в массиве</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Минимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinRef``1(``0[],System.Collections.Generic.IComparer{``0},System.Int32@)">
            <summary>Найти минимальный элемент в массиве и получить ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <param name="Comparer">Объект, обеспечивающий сравнение двух элементов в массиве</param>
            <param name="MinIndex">Индекс минимального элемента</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Минимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinIndex``1(``0[],System.Func{``0,System.Double})">
            <summary>Найти индекс минимального элемента в массиве</summary>
            <param name="array">Массив элементов</param>
            <param name="converter">Функция, обеспечивающая преобразования элемента в численное значение для сравнения</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Индекс минимального элемента</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinRef``1(``0[],System.Func{``0,System.Double})">
            <summary>Найти минимальный элемент в массиве и получить ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <param name="converter">Функция, обеспечивающая преобразования элемента в численное значение для сравнения</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Минимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinRef``1(``0[],System.Func{``0,System.Double},System.Int32@)">
            <summary>Найти минимальный элемент в массиве и получить ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <param name="converter">Функция, обеспечивающая преобразования элемента в численное значение для сравнения</param>
            <param name="MinIndex">Индекс минимального элемента</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Минимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinIndex``1(``0[])">
            <summary>Найти индекс минимального элемента в массиве</summary>
            <param name="array">Массив элементов</param>
            <typeparam name="T">Тип элементов массива, поддерживающий возможность сравнения</typeparam>
            <returns>Индекс минимального элемента</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinRef``1(``0[])">
            <summary>Найти минимальный элемент в массиве и получить ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <typeparam name="T">Тип элементов массива, поддерживающий возможность сравнения</typeparam>
            <returns>Минимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinRef``1(``0[],System.Int32@)">
            <summary>Найти минимальный элемент в массиве и получить ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <typeparam name="T">Тип элементов массива, поддерживающий возможность сравнения</typeparam>
            <param name="MinIndex">Индекс минимального элемента</param>
            <returns>Минимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMaxIndex``1(``0[],System.Comparison{``0})">
            <summary>Найти индекс максимального элемента в массиве</summary>
            <param name="array">Массив элементов</param>
            <param name="compare">Метод сравнения двух объектов между собой</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Индекс максимального элемента</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMaxRef``1(``0[],System.Comparison{``0})">
            <summary>Найти максимальный элемент в массиве и вернуть ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <param name="compare">Метод сравнения двух объектов между собой</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Максимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMaxRef``1(``0[],System.Comparison{``0},System.Int32@)">
            <summary>Найти максимальный элемент в массиве и вернуть ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <param name="compare">Метод сравнения двух объектов между собой</param>
            <param name="MaxIndex">Индекс максимального элемента</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Максимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMaxIndex``1(``0[],System.Collections.Generic.IComparer{``0})">
            <summary>Найти индекс максимального элемента в массиве</summary>
            <param name="array">Массив элементов</param>
            <param name="Comparer">Объект, обеспечивающий сравнение двух элементов в массиве</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Индекс максимального элемента</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMaxRef``1(``0[],System.Collections.Generic.IComparer{``0})">
            <summary>Найти максимальный элемент в массиве и вернуть ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <param name="Comparer">Объект, обеспечивающий сравнение двух элементов в массиве</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Максимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMaxRef``1(``0[],System.Collections.Generic.IComparer{``0},System.Int32@)">
            <summary>Найти максимальный элемент в массиве и вернуть ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <param name="Comparer">Объект, обеспечивающий сравнение двух элементов в массиве</param>
            <param name="MaxIndex">Индекс максимального элемента</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Максимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMaxIndex``1(``0[],System.Func{``0,System.Double})">
            <summary>Найти индекс максимального элемента в массиве</summary>
            <param name="array">Массив элементов</param>
            <param name="converter">Функция, обеспечивающая преобразования элемента в численное значение для сравнения</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Индекс максимального элемента</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMaxRef``1(``0[],System.Func{``0,System.Double})">
            <summary>Найти максимальный элемент в массиве и вернуть ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <param name="converter">Функция, обеспечивающая преобразования элемента в численное значение для сравнения</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Максимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMaxRef``1(``0[],System.Func{``0,System.Double},System.Int32@)">
            <summary>Найти максимальный элемент в массиве и вернуть ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <param name="converter">Функция, обеспечивающая преобразования элемента в численное значение для сравнения</param>
            <param name="MaxIndex">Индекс максимального элемента</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Максимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMaxIndex``1(``0[])">
            <summary>Найти индекс максимального элемента в массиве</summary>
            <param name="array">Массив элементов</param>
            <typeparam name="T">Тип элементов массива, поддерживающий возможность сравнения</typeparam>
            <returns>Индекс максимального элемента</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMaxRef``1(``0[])">
            <summary>Найти максимальный элемент в массиве и вернуть ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <typeparam name="T">Тип элементов массива, поддерживающий возможность сравнения</typeparam>
            <returns>Максимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMaxRef``1(``0[],System.Int32@)">
            <summary>Найти максимальный элемент в массиве и вернуть ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <param name="MaxIndex">Индекс максимального элемента</param>
            <typeparam name="T">Тип элементов массива, поддерживающий возможность сравнения</typeparam>
            <returns>Максимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinMaxIndex``1(``0[],System.Comparison{``0})">
            <summary>Найти индексы минимального и максимального элементов</summary>
            <param name="array">Массив элементов</param>
            <param name="compare">Метод сравнения двух объектов между собой</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Индекс минимального и максимального элементов массива</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinMaxIndex``1(``0[],System.Collections.Generic.IComparer{``0})">
            <summary>Найти индексы минимального и максимального элементов</summary>
            <param name="array">Массив элементов</param>
            <param name="Comparer">Объект, обеспечивающий сравнение двух элементов в массиве</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Индекс минимального и максимального элементов массива</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinMaxIndex``1(``0[],System.Func{``0,System.Double})">
            <summary>Найти индексы минимального и максимального элементов</summary>
            <param name="array">Массив элементов</param>
            <param name="converter">Функция, обеспечивающая преобразования элемента в численное значение для сравнения</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Индекс минимального и максимального элементов массива</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinMaxIndex``1(``0[])">
            <summary>Найти индексы минимального и максимального элементов</summary>
            <param name="array">Массив элементов</param>
            <typeparam name="T">Тип элементов массива, поддерживающий возможность сравнения</typeparam>
            <returns>Индекс минимального и максимального элементов массива</returns>
        </member>
        <member name="M:System.ArrayExtensions.CreateSequence(System.Int32,System.Int32)">
            <summary>Создать массив последовательных значений длины <paramref name="length"/> начиная с <paramref name="offset"/></summary>
            <param name="length">Длина массива</param>
            <param name="offset">Начальное значение</param>
            <returns>Массив чисел длины <paramref name="length"/> начиная с <paramref name="offset"/></returns>
        </member>
        <member name="M:System.ArrayExtensions.Mix``1(``0[])">
            <summary>Создать копию массива с перемешанным содержимым</summary>
            <param name="array">Исходный массив</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Копия исходного массива с перемешанным содержимым</returns>
        </member>
        <member name="M:System.ArrayExtensions.Mix``1(``0[],System.Random)">
            <summary>Создать копию массива с перемешанным содержимым</summary>
            <param name="array">Исходный массив</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <param name="rnd">Генератор случайных чисел</param>
            <returns>Копия исходного массива с перемешанным содержимым</returns>
        </member>
        <member name="M:System.ArrayExtensions.MixRef``1(``0[],System.Random)">
            <summary>Перемешать массив</summary>
            <typeparam name="T">Тип элементов массива</typeparam>
            <param name="array">Перемешиваемый массив</param>
            <param name="rnd">Генератор случайных чисел</param>
            <returns>Исходный массив с перемешанным содержимым</returns>
        </member>
        <member name="M:System.ArrayExtensions.MixRef``1(``0[])">
            <summary>Перемешать массив</summary>
            <typeparam name="T">Тип элементов массива</typeparam>
            <param name="array">Перемешиваемый массив</param>
            <returns>Исходный массив с перемешанным содержимым</returns>
        </member>
        <member name="M:System.ArrayExtensions.SetSubArrays``1(``0[],``0[][])">
            <summary>Последовательно скопировать набор массивов в буфер</summary>
            <param name="A">Буферный массив соответствующей длины</param>
            <param name="B">Перечень устанавливаемых значений</param>
            <typeparam name="T">Тип элементов массива</typeparam>
        </member>
        <member name="M:System.ArrayExtensions.IsContains``1(``0[],``0)">
            <summary>Проверка, что элемент входит в состав массива</summary>
            <param name="array">Проверяемый массив элементов</param>
            <param name="item">Элемент, вхождение в состав массива <paramref name="array"/> которого проверяется</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Истина, если массив <paramref name="array"/> содержит среди своих элементов <paramref name="item"/></returns>
        </member>
        <member name="M:System.ArrayExtensions.Linearize``1(``0[][])">
            <summary>Создать одномерный массив, содержащий все элементы указанных массивов</summary>
            <param name="array">Массив массивов элементов</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Одномерный массив, содержащий все элементы массивов из <paramref name="array"/></returns>
        </member>
        <member name="M:System.ArrayExtensions.Foreach``1(``0[0:,0:],System.Action{``0})">
            <summary>Выполнить действие для всех элементов двумерного массива</summary>
            <param name="array">Двумерный массив элементов, действие для всех элементов которого следует выполнить</param>
            <param name="action">Выполняемое действие, получающее в качестве параметра элемент массива</param>
            <typeparam name="T">Тип элементов массива</typeparam>
        </member>
        <member name="M:System.ArrayExtensions.Foreach``1(``0[0:,0:],System.Action{System.Int32,System.Int32,``0})">
            <summary>Выполнить действие для всех элементов двумерного массива</summary>
            <param name="array">Двумерный массив элементов, действие для всех элементов которого следует выполнить</param>
            <param name="action">
            Выполняемое действие, получающее в качестве параметра номер строки (первый индекс),
            номер столбца (второй индекс) и элемент массива
            </param>
            <typeparam name="T">Тип элементов массива</typeparam>
        </member>
        <member name="M:System.ArrayExtensions.Select``2(``0[0:,0:],System.Func{``0,``1})">
            <summary>Получить перечисление значений на основе элементов двумерного массива</summary>
            <param name="array">Двумерный массив элементов</param>
            <param name="selector">
            Метод конвертации элемента массива <typeparamref name="TItem"/> в его значение
            <typeparamref name="TValue"/>, получающий в качестве параметра значение элемента массива
            </param>
            <typeparam name="TItem">Тип элементов массива</typeparam>
            <typeparam name="TValue">Тип результата элементов перечисления</typeparam>
            <returns>Перечисление значений, сформированное на основе элементов двумерного массива</returns>
        </member>
        <member name="M:System.ArrayExtensions.Select``2(``0[0:,0:],System.Func{System.Int32,System.Int32,``0,``1})">
            <summary>Получить перечисление значений на основе элементов двумерного массива</summary>
            <param name="array">Двумерный массив элементов</param>
            <param name="selector">
            Метод конвертации элемента массива <typeparamref name="TItem"/> в его значение
            <typeparamref name="TValue"/>, получающий в качестве параметров номер строки (первый индекс),
            номер столбца (второй индекс) и значение элемента массива
            </param>
            <typeparam name="TItem">Тип элементов массива</typeparam>
            <typeparam name="TValue">Тип результата элементов перечисления</typeparam>
            <returns>Перечисление значений, сформированное на основе элементов двумерного массива</returns>
        </member>
        <member name="M:System.ArrayExtensions.ToStringView``1(``0[0:,0:],System.String)">
            <summary>Представить двумерный массив в текстовом виде в виде матрицы</summary>
            <param name="array">Двумерный массив, текстовое представление которого требуется выполнить</param>
            <param name="Splitter">Строка-разделитель элементов матрицы</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>
            Строковое представление двумерного массива в котором строки массива разделены переносом строки
            </returns>
        </member>
        <member name="M:System.ArrayExtensions.ToStringView``2(``0[0:,0:],System.Func{``0,``1},System.String)">
            <summary>Представить двумерный массив в текстовом виде в виде матрицы</summary>
            <param name="array">Двумерный массив, текстовое представление которого требуется выполнить</param>
            <param name="Selector">Метод преобразования значения элемента массива перед его записью</param>
            <param name="Splitter">Строка-разделитель элементов матрицы</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <typeparam name="TValue">Тип данных, записываемых в текстовую форму представления</typeparam>
            <returns>
            Строковое представление двумерного массива в котором строки массива разделены переносом строки
            </returns>
        </member>
        <member name="M:System.ArrayExtensions.ToStringFormatView``1(``0[0:,0:],System.String,System.String,System.IFormatProvider)">
            <summary>Представить двумерный массив в текстовом виде в виде матрицы</summary>
            <param name="array">Двумерный массив, текстовое представление которого требуется выполнить</param>
            <param name="Format">Строка формата данных каждого элемента</param>
            <param name="Splitter">Строка-разделитель элементов матрицы</param>
            <param name="provider">
            Объект, осуществляющий конечное форматирование элемента массива перед его выводом в текстовую форму
            </param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>
            Строковое представление двумерного массива в котором строки массива разделены переносом строки
            </returns>
        </member>
        <member name="M:System.ArrayExtensions.ToStringFormatView``2(``0[0:,0:],System.Func{``0,``1},System.String,System.String,System.IFormatProvider)">
            <summary>Представить двумерный массив в текстовом виде в виде матрицы</summary>
            <param name="array">Двумерный массив, текстовое представление которого требуется выполнить</param>
            <param name="Selector">Метод преобразования значения элемента массива перед его записью</param>
            <param name="Format">Строка формата данных каждого элемента</param>
            <param name="Splitter">Строка-разделитель элементов матрицы</param>
            <param name="provider">
            Объект, осуществляющий конечное форматирование элемента массива перед его выводом в текстовую форму
            </param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <typeparam name="TValue">Тип данных, записываемых в текстовую форму представления</typeparam>
            <returns>
            Строковое представление двумерного массива в котором строки массива разделены переносом строки
            </returns>
        </member>
        <member name="T:System.Threading.Tasks.CancellationTokenExtensions">
            <summary>Extension methods for CancellationToken.</summary>
        </member>
        <member name="M:System.Threading.Tasks.CancellationTokenExtensions.CancelAndThrow(System.Threading.CancellationTokenSource)">
            <summary>Cancels a CancellationTokenSource and throws a corresponding OperationCanceledException.</summary>
            <param name="source">The source to be canceled.</param>
        </member>
        <member name="M:System.Threading.Tasks.CancellationTokenExtensions.CreateLinkedSource(System.Threading.CancellationToken)">
            <summary>Creates a CancellationTokenSource that will be canceled when the specified token has cancellation requested.</summary>
            <param name="token">The token.</param>
            <returns>The created CancellationTokenSource.</returns>
        </member>
        <member name="T:System.Threading.Tasks.TaskCompletionSourceExtensions">
            <summary>Extension methods for TaskCompletionSource.</summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSourceExtensions.SetFromTask``1(System.Threading.Tasks.TaskCompletionSource{``0},System.Threading.Tasks.Task)">
            <summary>Transfers the result of a Task to the TaskCompletionSource.</summary>
            <typeparam name="TResult">Specifies the type of the result.</typeparam>
            <param name="ResultSetter">The TaskCompletionSource.</param>
            <param name="task">The task whose completion results should be transferred.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSourceExtensions.SetFromTask``1(System.Threading.Tasks.TaskCompletionSource{``0},System.Threading.Tasks.Task{``0})">
            <summary>Transfers the result of a Task to the TaskCompletionSource.</summary>
            <typeparam name="TResult">Specifies the type of the result.</typeparam>
            <param name="ResultSetter">The TaskCompletionSource.</param>
            <param name="task">The task whose completion results should be transferred.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSourceExtensions.TrySetFromTask``1(System.Threading.Tasks.TaskCompletionSource{``0},System.Threading.Tasks.Task)">
            <summary>Attempts to transfer the result of a Task to the TaskCompletionSource.</summary>
            <typeparam name="TResult">Specifies the type of the result.</typeparam>
            <param name="ResultSetter">The TaskCompletionSource.</param>
            <param name="task">The task whose completion results should be transferred.</param>
            <returns>Whether the transfer could be completed.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSourceExtensions.TrySetFromTask``1(System.Threading.Tasks.TaskCompletionSource{``0},System.Threading.Tasks.Task{``0})">
            <summary>Attempts to transfer the result of a Task to the TaskCompletionSource.</summary>
            <typeparam name="TResult">Specifies the type of the result.</typeparam>
            <param name="ResultSetter">The TaskCompletionSource.</param>
            <param name="task">The task whose completion results should be transferred.</param>
            <returns>Whether the transfer could be completed.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.YieldAsync">
            <summary>Переход в асинхронную область - в новый поток из пула потоков</summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.SwitchContext(System.Threading.Tasks.TaskScheduler)">
            <summary>Переключиться в контекст планировщика потоков</summary>
            <param name="scheduler">Планировщик потоков, распределяющий процессы выполнения задач</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Select``2(System.Threading.Tasks.Task{``0},System.Func{``0,``1})">
            https://blogs.msdn.microsoft.com/pfxteam/2010/04/04/a-tour-of-parallelextensionsextras/
        </member>
        <member name="T:System.Threading.Tasks.TaskEx.OneElementGrouping`2">
            <summary>Represents a grouping of one element.</summary>
            <typeparam name="TKey">The type of the key for the element.</typeparam>
            <typeparam name="TElement">The type of the element.</typeparam>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.ContinueWith(System.Threading.Tasks.Task,System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskFactory)">
            <summary>Creates a continuation task using the specified TaskFactory.</summary>
            <param name="task">The antecedent Task.</param>
            <param name="ContinuationAction">The continuation action.</param>
            <param name="factory">The TaskFactory.</param>
            <returns>A continuation task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.ContinueWith``1(System.Threading.Tasks.Task,System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskFactory)">
            <summary>Creates a continuation task using the specified TaskFactory.</summary>
            <param name="task">The antecedent Task.</param>
            <param name="ContinuationFunction">The continuation function.</param>
            <param name="factory">The TaskFactory.</param>
            <returns>A continuation task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.ContinueWith``1(System.Threading.Tasks.Task{``0},System.Action{System.Threading.Tasks.Task{``0}},System.Threading.Tasks.TaskFactory{``0})">
            <summary>Creates a continuation task using the specified TaskFactory.</summary>
            <param name="task">The antecedent Task.</param>
            <param name="ContinuationAction">The continuation action.</param>
            <param name="factory">The TaskFactory.</param>
            <returns>A continuation task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.ContinueWith``2(System.Threading.Tasks.Task{``0},System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.Tasks.TaskFactory{``0})">
            <summary>Creates a continuation task using the specified TaskFactory.</summary>
            <param name="task">The antecedent Task.</param>
            <param name="ContinuationFunction">The continuation function.</param>
            <param name="factory">The TaskFactory.</param>
            <returns>A continuation task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.ToAsync(System.Threading.Tasks.Task,System.AsyncCallback,System.Object)">
            <summary>
            Creates a Task that represents the completion of another Task, and 
            that schedules an AsyncCallback to run upon completion.
            </summary>
            <param name="task">The antecedent Task.</param>
            <param name="callback">The AsyncCallback to run.</param>
            <param name="state">The object state to use with the AsyncCallback.</param>
            <returns>The new task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.ToAsync``1(System.Threading.Tasks.Task{``0},System.AsyncCallback,System.Object)">
            <summary>
            Creates a Task that represents the completion of another Task, and 
            that schedules an AsyncCallback to run upon completion.
            </summary>
            <param name="task">The antecedent Task.</param>
            <param name="callback">The AsyncCallback to run.</param>
            <param name="state">The object state to use with the AsyncCallback.</param>
            <returns>The new task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.IgnoreExceptions(System.Threading.Tasks.Task)">
            <summary>Suppresses default exception handling of a Task that would otherwise reraise the exception on the finalizer thread.</summary>
            <param name="task">The Task to be monitored.</param>
            <returns>The original Task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.IgnoreExceptions``1(System.Threading.Tasks.Task{``0})">
            <summary>Suppresses default exception handling of a Task that would otherwise reraise the exception on the finalizer thread.</summary>
            <param name="task">The Task to be monitored.</param>
            <returns>The original Task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.FailFastOnException(System.Threading.Tasks.Task)">
            <summary>Fails immediately when an exception is encountered.</summary>
            <param name="task">The Task to be monitored.</param>
            <returns>The original Task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.FailFastOnException``1(System.Threading.Tasks.Task{``0})">
            <summary>Fails immediately when an exception is encountered.</summary>
            <param name="task">The Task to be monitored.</param>
            <returns>The original Task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.PropagateExceptions(System.Threading.Tasks.Task)">
            <summary>Propagates any exceptions that occurred on the specified task.</summary>
            <param name="task">The Task whose exceptions are to be propagated.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.PropagateExceptions(System.Threading.Tasks.Task[])">
            <summary>Propagates any exceptions that occurred on the specified tasks.</summary>
            <param name="tasks">The Task whose exceptions are to be propagated.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.ToObservable``1(System.Threading.Tasks.Task{``0})">
            <summary>Creates an IObservable that represents the completion of a Task.</summary>
            <typeparam name="TResult">Specifies the type of data returned by the Task.</typeparam>
            <param name="task">The Task to be represented as an IObservable.</param>
            <returns>An IObservable that represents the completion of the Task.</returns>
        </member>
        <member name="T:System.Threading.Tasks.TaskEx.TaskObservable`1">
            <summary>An implementation of IObservable that wraps a Task.</summary>
            <typeparam name="TResult">The type of data returned by the task.</typeparam>
        </member>
        <member name="T:System.Threading.Tasks.TaskEx.CancelOnDispose">
            <summary>Translate a call to IDisposable.Dispose to a CancellationTokenSource.Cancel.</summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.WithTimeout(System.Threading.Tasks.Task,System.TimeSpan@)">
            <summary>Creates a new Task that mirrors the supplied task but that will be canceled after the specified timeout.</summary>
            <param name="task">The task.</param>
            <param name="timeout">The timeout.</param>
            <returns>The new Task that may time out.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.WithTimeout``1(System.Threading.Tasks.Task{``0},System.TimeSpan)">
            <summary>Creates a new Task that mirrors the supplied task but that will be canceled after the specified timeout.</summary>
            <typeparam name="TResult">Specifies the type of data contained in the task.</typeparam>
            <param name="task">The task.</param>
            <param name="timeout">The timeout.</param>
            <returns>The new Task that may time out.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.AttachToParent(System.Threading.Tasks.Task)">
            <summary>
            Ensures that a parent task can't transition into a completed state
            until the specified task has also completed, even if it's not
            already a child task.
            </summary>
            <param name="task">The task to attach to the current task as a child.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.WaitForCompletionStatus(System.Threading.Tasks.Task)">
            <summary>Waits for the task to complete execution, returning the task's final status.</summary>
            <param name="task">The task for which to wait.</param>
            <returns>The completion status of the task.</returns>
            <remarks>Unlike Wait, this method will not throw an exception if the task ends in the Faulted or Canceled state.</remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Then(System.Threading.Tasks.Task,System.Action)">
            <summary>Creates a task that represents the completion of a follow-up action when a task completes.</summary>
            <param name="task">The task.</param>
            <param name="next">The action to run when the task completes.</param>
            <returns>The task that represents the completion of both the task and the action.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Then``1(System.Threading.Tasks.Task,System.Func{``0})">
            <summary>Creates a task that represents the completion of a follow-up function when a task completes.</summary>
            <param name="task">The task.</param>
            <param name="next">The function to run when the task completes.</param>
            <returns>The task that represents the completion of both the task and the function.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Then``1(System.Threading.Tasks.Task{``0},System.Action{``0})">
            <summary>Creates a task that represents the completion of a follow-up action when a task completes.</summary>
            <param name="task">The task.</param>
            <param name="next">The action to run when the task completes.</param>
            <returns>The task that represents the completion of both the task and the action.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Then``2(System.Threading.Tasks.Task{``0},System.Func{``0,``1})">
            <summary>Creates a task that represents the completion of a follow-up function when a task completes.</summary>
            <param name="task">The task.</param>
            <param name="next">The function to run when the task completes.</param>
            <returns>The task that represents the completion of both the task and the function.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Then(System.Threading.Tasks.Task,System.Func{System.Threading.Tasks.Task})">
            <summary>Creates a task that represents the completion of a second task when a first task completes.</summary>
            <param name="task">The first task.</param>
            <param name="next">The function that produces the second task.</param>
            <returns>The task that represents the completion of both the first and second task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Then``1(System.Threading.Tasks.Task{``0},System.Func{``0,System.Threading.Tasks.Task})">
            <summary>Creates a task that represents the completion of a second task when a first task completes.</summary>
            <param name="task">The first task.</param>
            <param name="next">The function that produces the second task based on the result of the first task.</param>
            <returns>The task that represents the completion of both the first and second task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Then``1(System.Threading.Tasks.Task,System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>Creates a task that represents the completion of a second task when a first task completes.</summary>
            <param name="task">The first task.</param>
            <param name="next">The function that produces the second task.</param>
            <returns>The task that represents the completion of both the first and second task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Then``2(System.Threading.Tasks.Task{``0},System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>Creates a task that represents the completion of a second task when a first task completes.</summary>
            <param name="task">The first task.</param>
            <param name="next">The function that produces the second task based on the result of the first.</param>
            <returns>The task that represents the completion of both the first and second task.</returns>
        </member>
        <member name="T:System.ComponentModel.INotifyPropertyChangedExtensions">
            <summary>Класс методов-расширений интерфейса <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></summary>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.RegisterPropertyChangedHandler(System.ComponentModel.INotifyPropertyChanged,System.ComponentModel.PropertyChangedEventHandler,System.String)">
            <summary>Подписка на событие изменения указанного свойства</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="handler">Обработчик события <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> типа <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></param>
            <param name="Name">Имя свойства</param>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.RegisterPropertyChangedHandler_Disposable(System.ComponentModel.INotifyPropertyChanged,System.ComponentModel.PropertyChangedEventHandler,System.String)">
            <summary>Подписка на событие изменения указанного свойства</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="handler">Обработчик события <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> типа <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></param>
            <param name="Name">Имя свойства</param>
            <returns>Объект <see cref="T:System.IDisposable"/>, вызывающий отписку от события в случае своего уничтожения</returns>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.RegisterPropertyChangedHandler(System.ComponentModel.INotifyPropertyChanged,System.ComponentModel.PropertyChangedEventHandler,System.String[])">
            <summary>Подписка на событие изменения указанных свойств</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="handler">Обработчик события <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> типа <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></param>
            <param name="Names">Имена свойств</param>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.RegisterPropertyChangedHandler_Disposable(System.ComponentModel.INotifyPropertyChanged,System.ComponentModel.PropertyChangedEventHandler,System.String[])">
            <summary>Подписка на событие изменения указанных свойств</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="handler">Обработчик события <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> типа <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></param>
            <param name="Names">Имена свойств</param>
            <returns>Объект <see cref="T:System.IDisposable"/>, вызывающий отписку от события в случае своего уничтожения</returns>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.RegisterPropertyChangedHandler(System.ComponentModel.INotifyPropertyChanged,System.ComponentModel.PropertyChangedEventHandler,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Подписка на событие изменения указанных свойств</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="handler">Обработчик события <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> типа <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></param>
            <param name="Names">Имена свойств</param>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.RegisterPropertyChangedHandler_Disposable(System.ComponentModel.INotifyPropertyChanged,System.ComponentModel.PropertyChangedEventHandler,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Подписка на событие изменения указанных свойств</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="handler">Обработчик события <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> типа <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></param>
            <param name="Names">Имена свойств</param>
            <returns>Объект <see cref="T:System.IDisposable"/>, вызывающий отписку от события в случае своего уничтожения</returns>
        </member>
        <member name="T:System.ComponentModel.INotifyPropertyChangedExtensions.DependentPropertyChangedEventArgs">
            <summary>Аргумент события изменения зависимого свойства</summary>
        </member>
        <member name="P:System.ComponentModel.INotifyPropertyChangedExtensions.DependentPropertyChangedEventArgs.FromProperties">
            <summary>Перечень свойств, породивших изменение</summary>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.DependentPropertyChangedEventArgs.#ctor(System.String,System.String[])">
            <summary>Инициализация нового аргумента события изменения зависимого свойства</summary>
            <param name="PropertyName">Имя изменившегося свойства</param>
            <param name="FromProperties">Список свойств, породивших изменение</param>
        </member>
        <member name="F:System.ComponentModel.INotifyPropertyChangedExtensions.__ObjectsSet">
            <summary>Перечень слабых ссылок на отслеживаемые объекты</summary>
        </member>
        <member name="F:System.ComponentModel.INotifyPropertyChangedExtensions.__RegistrationPool">
            <summary>Словарь описаний связей между свойствами типов</summary>
        </member>
        <member name="T:System.ComponentModel.INotifyPropertyChangedExtensions.RegistratorInfo">
            <summary>Информация о связях между свойствами типов</summary>
        </member>
        <member name="F:System.ComponentModel.INotifyPropertyChangedExtensions.RegistratorInfo._Dependencies">
            <summary>Словарь связей имён свойств типа</summary>
        </member>
        <member name="F:System.ComponentModel.INotifyPropertyChangedExtensions.RegistratorInfo._Handler">
            <summary>Обработчик события изменения свойства объекта</summary>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.RegistratorInfo.#ctor(System.Collections.Generic.Dictionary{System.String,System.String[]})">
            <summary>Инициализация нового экземпляра информации и связях между свойствами типа</summary>
            <param name="Dependencies">Словарь имён свойств зависимостей</param>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.RegistratorInfo.Subscribe(System.ComponentModel.INotifyPropertyChanged,System.Action{System.ComponentModel.PropertyChangedEventArgs})">
            <summary>Метод установки обработчика событий обновления свойства объекта, генерирующего вторичные события обновления зависимых свойств</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="OnPropertyChanged">Метод генерации события <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> в объекте <paramref name="obj"/></param>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.RegistratorInfo.UnSubscribe(System.ComponentModel.INotifyPropertyChanged)">
            <summary>Отписка от события обновления свойств объекта</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.OnGarbageCollected(System.Object,System.EventArgs)">
            <summary>Обработка событий сборки мусора в системе</summary>
            <param name="Sender">Источник события - не используется</param>
            <param name="e">Аргумент события - не используется</param>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.PropertyDependencies_Register``1(``0,System.Action{System.ComponentModel.PropertyChangedEventArgs})">
            <summary>Создание связей между свойствами объекта на основе атрибутов <see cref="T:System.AffectsTheAttribute"/> и <see cref="T:System.DependencyOnAttribute"/></summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="OnPropertyChanged">Метод генерации события обновления свойства</param>
            <typeparam name="T">Тип объекта</typeparam>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.PropertyDependencies_Register_Disposable``1(``0,System.Action{System.ComponentModel.PropertyChangedEventArgs})">
            <summary>Создание связей между свойствами объекта на основе атрибутов <see cref="T:System.AffectsTheAttribute"/> и <see cref="T:System.DependencyOnAttribute"/></summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="OnPropertyChanged">Метод генерации события обновления свойства</param>
            <typeparam name="T">Тип объекта</typeparam>
            <returns></returns>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.PropertyDependencies_Unregister``1(``0)">
            <summary>Разрушение связей между свойствами, созданными методом <see cref="M:System.ComponentModel.INotifyPropertyChangedExtensions.PropertyDependencies_Register``1(``0,System.Action{System.ComponentModel.PropertyChangedEventArgs})"/></summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <typeparam name="T">Тип объекта</typeparam>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.GetRegistrator(System.Type)">
            <summary>Метод получения информации о связях между свойствами объекта класса</summary>
            <param name="type">Тип рассматриваемого объекта</param>
            <returns>Информация о связях между свойствами объекта</returns>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.SubscribeTo``1(``0,System.String,System.ComponentModel.PropertyChangedEventHandler)">
            <summary>Подписаться на событие изменения свойства</summary>
            <typeparam name="T">Тип объекта, генерирующего событие</typeparam>
            <param name="obj">Объект, на событие изменения свойств которого производится подписка</param>
            <param name="PropertyName">Имя отслеживаемого свойства</param>
            <param name="Handler">Обработчик события</param>
        </member>
        <member name="M:System.Collections.BitArrayExtensions.IsPartyCorrect(System.Collections.BitArray,System.Boolean)">
            <summary>Проверка корректности чётности</summary>
            <param name="bits">Битовый массив</param>
            <param name="PartyBit">Бит чётности</param>
            <returns>Истина, если сумма бит по модулю 2 и бита чётности равна 0</returns>
        </member>
        <member name="M:System.Collections.BitArrayExtensions.GetBitSumMod2(System.Collections.BitArray)">
            <summary>Сумма бит по модулю 2</summary>
            <param name="bits">Битовый массив</param>
            <returns>Результат сложения бит массива по модулю 2</returns>
        </member>
        <member name="T:System.Collections.Generic.IDictionaryExtensions">
            <summary>Класс методов-расширений для интерфейса <see cref="T:System.Collections.Generic.IDictionary`2"/></summary>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.AddValue``2(System.Collections.Generic.IDictionary{``0,System.Collections.Generic.IList{``1}},``0,``1)">
            <summary>Метод добавления значения в словарь списков значений</summary>
            <param name="dictionary">Словарь списков <see cref="T:System.Collections.Generic.IList`1"/> значений типа <typeparamref name="TValue"/></param>
            <param name="key">Ключ словаря типа <typeparamref name="TKey"/></param>
            <param name="value">Значение списка типа <typeparamref name="TValue"/></param>
            <typeparam name="TKey">Тип ключа словаря <paramref name="key"/></typeparam>
            <typeparam name="TValue">Тип значения списка значений <paramref name="value"/></typeparam>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.AddValue``3(System.Collections.Generic.IDictionary{``0,System.Collections.Generic.IList{``2}},``1,System.Func{``1,``0},System.Func{``1,``2})">
            <summary>Метод добавления значения в словарь списков значений</summary>
            <param name="dictionary">Словарь списков <see cref="T:System.Collections.Generic.IList`1"/> значений типа <typeparamref name="TValue"/></param>
            <param name="obj">Объект-ключ словаря типа <typeparamref name="TObject"/></param>
            <param name="KeySelector">Метод образования ключа типа <typeparamref name="TKey"/> словаря из объекта типа <typeparamref name="TObject"/></param>
            <param name="ValueSelector">Метод образования значения типа <typeparamref name="TValue"/> из объекта типа <typeparamref name="TObject"/></param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TObject">Тип входного объекта</typeparam>
            <typeparam name="TValue">Тип значения списка</typeparam>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.AddValue``2(System.Collections.Generic.IDictionary{``0,System.Collections.Generic.IList{``1}},``1,System.Func{``1,``0})">
            <summary>Метод добавления значения в словарь списков значений</summary>
            <param name="dictionary">Словарь списков <see cref="T:System.Collections.Generic.IList`1"/> значений типа <typeparamref name="TValue"/></param>
            <param name="value">Значение, записываемое в словарь</param>
            <param name="KeySelector">Метод извлечения ключа из указанного значения</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения списка</typeparam>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.AddValues``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{``1},System.Func{``1,``0})">
            <summary>Добавление значений в словарь</summary>
            <param name="dictionary">Словарь в который надо добавить значения</param>
            <param name="collection">Коллекция добавляемых значений</param>
            <param name="converter">Метод определения ключа словаря для каждого из элементов коллекции</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.GetValueOrAddNew``2(System.Collections.Generic.Dictionary{``0,``1},``0,System.Func{``1})">
            <summary>Получить значение из словаря в случае его наличия, или добавить новое</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="key">Ключ значения, которое надо получить</param>
            <param name="creator">Метод получения нового значения, заносимого в словарь при отсутствии в нём указанного ключа</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <returns>Полученное из словаря по указанному ключу значение, либо созданное вновь и помещённое значение указанным методом</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.GetValueOrAddNew``2(System.Collections.Generic.Dictionary{``0,``1},``0,System.Func{``0,``1})">
            <summary>Получить значение из словаря в случае его наличия, или добавить новое</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="key">Ключ значения, которое надо получить</param>
            <param name="creator">Метод получения нового значения по указанному ключу, заносимого в словарь при отсутствии в нём указанного ключа</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <returns>Полученное из словаря по указанному ключу значение, либо созданное вновь и помещённое значение указанным методом</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.GetValueOrAddNew``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``1})">
            <summary>Получить значение из словаря в случае его наличия, или добавить новое</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="key">Ключ значения, которое надо получить</param>
            <param name="creator">Метод получения нового значения, заносимого в словарь при отсутствии в нём указанного ключа</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <returns>Полученное из словаря по указанному ключу значение, либо созданное вновь и помещённое значение указанным методом</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.GetValueOrAddNew``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1})">
            <summary>Получить значение из словаря в случае его наличия, или добавить новое</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="key">Ключ значения, которое надо получить</param>
            <param name="creator">Метод получения нового значения, заносимого в словарь при отсутствии в нём указанного ключа</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <returns>Полученное из словаря по указанному ключу значение, либо созданное вновь и помещённое значение указанным методом</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.GetValue``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
            <summary>Получить значение из словаря в случае его наличия, или добавить новое</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="key">Ключ, значение для которого требуется получить</param>
            <param name="DefaultValue">Значение по-умолчанию, которое будет добавлено в словарь с указанным ключом, если он отсутствует</param>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип значения</typeparam>
            <returns>Значение словаря для указанного ключа, либо указанное значение по-умолчанию</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.GetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>Получить значение из словаря в случае его наличия, или добавить новое</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="key">Ключ, значение для которого требуется получить</param>
            <param name="DefaultValue">Значение по-умолчанию, которое будет добавлено в словарь с указанным ключом, если он отсутствует</param>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип значения</typeparam>
            <returns>Значение словаря для указанного ключа, либо указанное значение по-умолчанию</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.GetValue``1(System.Collections.Generic.Dictionary{System.String,System.Object},System.String)">
            <summary>Получить значение из словаря в случае его наличия, или добавить новое</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="name">Название объекта, значение для которого требуется получить</param>
            <typeparam name="TValue">Тип значения</typeparam>
            <returns>Значение словаря для указанного ключа</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.Initialize``2(System.Collections.Generic.IDictionary{``0,``1},System.Int32,System.Func{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>Инициализация словаря указанным методом для указанного числа значений</summary>
            <param name="dictionary">Инициализируемый словарь</param>
            <param name="count">Количество добавляемых элементов</param>
            <param name="initializer">Метод генерации новых элементов</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <returns>Инициализированный словарь</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.Initialize``3(System.Collections.Generic.IDictionary{``0,``1},System.Int32,``2,System.Func{``2,System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>Инициализация словаря указанным методом для указанного числа значений</summary>
            <param name="dictionary">Инициализируемый словарь</param>
            <param name="count">Количество добавляемых элементов</param>
            <param name="parameter">Параметр инициализации</param>
            <param name="initializer">Метод генерации новых элементов</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <typeparam name="TParameter">Тип параметра</typeparam>
            <returns>Инициализированный словарь</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.Initialize``2(System.Collections.Generic.IDictionary{``0,``1},System.Int32,System.Func{System.Int32,System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>Инициализация словаря указанным методом для указанного числа значений</summary>
            <param name="dictionary">Инициализируемый словарь</param>
            <param name="count">Количество добавляемых элементов</param>
            <param name="initializer">Метод генерации новых элементов</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <returns>Инициализированный словарь</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.Initialize``3(System.Collections.Generic.IDictionary{``0,``1},System.Int32,``2,System.Func{System.Int32,``2,System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>Инициализация словаря указанным методом для указанного числа значений</summary>
            <param name="dictionary">Инициализируемый словарь</param>
            <param name="count">Количество добавляемых элементов</param>
            <param name="parameter">Параметр инициализации</param>
            <param name="initializer">Метод генерации новых элементов</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <typeparam name="TParameter">Тип параметра инициализации</typeparam>
            <returns>Инициализированный словарь</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.Initialize``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>Инициализация словаря указанным методом для указанного числа значений</summary>
            <param name="dictionary">Инициализируемый словарь</param>
            <param name="keys">Коллекция ключей</param>
            <param name="initializer">Метод генерации новых элементов</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <returns>Инициализированный словарь</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.Initialize``3(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{``0},``2,System.Func{``0,``2,``1})">
            <summary>Инициализация словаря указанным методом для указанного числа значений</summary>
            <param name="dictionary">Инициализируемый словарь</param>
            <param name="keys">Коллекция ключей</param>
            <param name="parameter">Параметр инициализации</param>
            <param name="initializer">Метод генерации новых элементов</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <typeparam name="TParameter">Тип параметра инициализации</typeparam>
            <returns>Инициализированный словарь</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.RemoveWhere``2(System.Collections.Generic.IDictionary{``0,``1},System.Func{System.Collections.Generic.KeyValuePair{``0,``1},System.Boolean})">
            <summary>Удаление из словаря элементов, удовлетворяющих предикату</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="selector">Метод отбора элементов</param>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип значения</typeparam>
            <returns>Массив удалённых пар ключ-значение</returns>
        </member>
        <member name="T:System.Collections.Generic.IListExtensions">
            <summary>Методы расширения для интерфейса списка</summary>
        </member>
        <member name="M:System.Collections.Generic.IListExtensions.Initialize``1(System.Collections.Generic.IList{``0},System.Int32,System.Func{System.Int32,``0},System.Boolean)">
            <summary>Метод расширения для инициализации списка</summary>
            <param name="list">Инициализируемый объект</param>
            <param name="Count">Требуемое число элементов</param>
            <param name="Initializator">Метод инициализации</param>
            <param name="ClearBefore">Очищать предварительно (по умолчанию)</param>
            <typeparam name="T">Тип элементов списка</typeparam>
            <returns>Инициализированный список</returns>
        </member>
        <member name="M:System.Collections.Generic.IListExtensions.Initialize``2(System.Collections.Generic.IList{``0},System.Int32,``1,System.Func{System.Int32,``1,``0},System.Boolean)">
            <summary>Метод расширения для инициализации списка</summary>
            <param name="list">Инициализируемый объект</param>
            <param name="Count">Требуемое число элементов</param>
            <param name="parameter">Параметр инициализации</param>
            <param name="Initializator">Метод инициализации</param>
            <param name="ClearBefore">Очищать предварительно (по умолчанию)</param>
            <typeparam name="T">Тип элементов списка</typeparam>
            <typeparam name="TParameter">Тип параметра инициализации</typeparam>
            <returns>Инициализированный список</returns>
        </member>
        <member name="M:System.Collections.Generic.IListExtensions.Mix``1(System.Collections.Generic.IList{``0})">
            <summary>Перемешать список</summary>
            <param name="list">Перемешиваемый список</param>
            <typeparam name="T">Тип элементов списка</typeparam>
            <returns>Перемешанный исходный список</returns>
        </member>
        <member name="T:System.Collections.Generic.QueueExtensions">
            <summary>Методы-расширения для <see cref="T:System.Collections.Generic.Queue`1"/></summary>
        </member>
        <member name="M:System.Collections.Generic.QueueExtensions.Add``1(System.Collections.Generic.Queue{``0},``0)">
            <summary>Добавить элемент в очередь</summary>
            <typeparam name="T">Тип элементов очереди</typeparam>
            <param name="queue">Очередь, в которую надо добавить элемент</param>
            <param name="value">Добавляемый элемент</param>
        </member>
        <member name="M:System.Collections.Generic.QueueExtensions.AddValue``1(System.Collections.Generic.Queue{``0},``0)">
            <summary>Добавить элемент в очередь и вернуть модифицированную очередь в качестве результата</summary>
            <typeparam name="T">Тип элементов очереди</typeparam>
            <param name="queue">Очередь, в которую надо добавить элемент</param>
            <param name="value">Добавляемый элемент</param>
            <returns>Модифицированная очередь</returns>
        </member>
        <member name="M:System.Collections.Generic.QueueExtensions.ToStack``1(System.Collections.Generic.Queue{``0})">
            <summary>Преобразовать очередь в стек</summary>
            <typeparam name="T">Тип элементов очереди</typeparam>
            <param name="queue">Преобразуемая очередь</param>
            <returns>Стек из элементов очереди</returns>
        </member>
        <member name="M:System.Collections.Generic.QueueExtensions.ToStackReverse``1(System.Collections.Generic.Queue{``0})">
            <summary>Преобразовать очередь в стек в обратном порядке</summary>
            <typeparam name="T">Тип элементов очереди</typeparam>
            <param name="queue">Преобразуемая очередь</param>
            <returns>Стек из элементов очереди, взятых в обратном порядке</returns>
        </member>
        <member name="T:System.Collections.Generic.StackExtensions">
            <summary>Методы-расширения для <see cref="T:System.Collections.Generic.Stack`1"/></summary>
        </member>
        <member name="M:System.Collections.Generic.StackExtensions.Add``1(System.Collections.Generic.Stack{``0},``0)">
            <summary>Добавить элемент в стек</summary>
            <typeparam name="T">Тип элементов стека</typeparam>
            <param name="stack">Стек, в который надо добавить элемент</param>
            <param name="value">Добавляемый элемент</param>
        </member>
        <member name="M:System.Collections.Generic.StackExtensions.AddValue``1(System.Collections.Generic.Stack{``0},``0)">
            <summary>Добавить элемент в стек и вернуть модифицированный стек в качестве результата</summary>
            <typeparam name="T">Тип элементов стека</typeparam>
            <param name="stack">Стек, в который надо добавить элемент</param>
            <param name="value">Добавляемый элемент</param>
            <returns>Модифицированный стек</returns>
        </member>
        <member name="M:System.Collections.Generic.StackExtensions.ToQueue``1(System.Collections.Generic.Stack{``0})">
            <summary>Преобразовать стек в очередь</summary>
            <typeparam name="T">Тип элементов стека</typeparam>
            <param name="stack">Преобразуемый стек</param>
            <returns>Очередь из элементов стека</returns>
        </member>
        <member name="M:System.Collections.Generic.StackExtensions.ToQueueReverse``1(System.Collections.Generic.Stack{``0})">
            <summary>Преобразовать стек в инвертированную очередь</summary>
            <typeparam name="T">Тип элементов стека</typeparam>
            <param name="stack">Преобразуемый стек</param>
            <returns>Очередь из элементов стека, взятых в обратном порядке</returns>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.GetEnumerator">
            <summary>
            Возвращает перечислитель, выполняющий перебор элементов в коллекции.
            </summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.IEnumerator`1"/>, который может использоваться для перебора элементов коллекции.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Возвращает перечислитель, который осуществляет перебор элементов коллекции.
            </summary>
            <returns>
            Объект <see cref="T:System.Collections.IEnumerator"/>, который может использоваться для перебора элементов коллекции.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Добавляет элемент в интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <param name="item">Объект, добавляемый в интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения.</exception>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.Clear">
            <summary>
            Удаляет все элементы из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения. </exception>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Определяет, содержит ли интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> указанное значение.
            </summary>
            <returns>
            Значение true, если объект <paramref name="item"/> найден в <see cref="T:System.Collections.Generic.ICollection`1"/>; в противном случае — значение false.
            </returns>
            <param name="item">Объект, который требуется найти в <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Копирует элементы <see cref="T:System.Collections.Generic.ICollection`1"/> в массив <see cref="T:System.Array"/>, начиная с указанного индекса <see cref="T:System.Array"/>.
            </summary>
            <param name="array">Одномерный массив <see cref="T:System.Array"/>, в который копируются элементы из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>. Индексация в массиве <see cref="T:System.Array"/> должна начинаться с нуля.</param><param name="arrayIndex">Значение индекса (с нуля) в массиве <paramref name="array"/>, с которого начинается копирование.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="array"/> имеет значение null.</exception><exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="arrayIndex"/> меньше 0.</exception><exception cref="T:System.ArgumentException">Массив <paramref name="array"/> является многомерным.-или-
                            Значение индекса массива <paramref name="arrayIndex"/> больше или равно длине массива <paramref name="array"/>.-или-Количество элементов в исходном интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/> превышает размер доступного места, начиная с индекса <paramref name="arrayIndex"/> и до конца массива назначения <paramref name="array"/>.-или-Тип <paramref name="T"/> не может быть автоматически приведен к типу массива назначения <paramref name="array"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Удаляет первое вхождение указанного объекта из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            Значение true, если объект <paramref name="item"/> успешно удален из <see cref="T:System.Collections.Generic.ICollection`1"/>, в противном случае — значение false. Этот метод также возвращает значение false, если параметр <paramref name="item"/> не найден в исходном интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            <param name="item">Объект, который необходимо удалить из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения.</exception>
        </member>
        <member name="P:System.Collections.Generic.DictionaryReadOnly`2.Count">
            <summary>
            Получает число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            Число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
        </member>
        <member name="P:System.Collections.Generic.DictionaryReadOnly`2.IsReadOnly">
            <summary>
            Получает значение, указывающее, доступен ли интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> только для чтения.
            </summary>
            <returns>
            Значение true, если интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения, в противном случае — значение false.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.ContainsKey(`0)">
            <summary>
            Определяет, содержится ли элемент с указанным ключом в <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            Значение true, если в <see cref="T:System.Collections.Generic.IDictionary`2"/> содержится элемент с данным ключом; в противном случае — значение false.
            </returns>
            <param name="key">Ключ, который требуется найти в <see cref="T:System.Collections.Generic.IDictionary`2"/>.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="key"/> имеет значение null.</exception>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.Add(`0,`1)">
            <summary>
            Добавляет элемент с указанными ключом и значением в <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <param name="key">Объект, используемый в качестве ключа добавляемого элемента.</param><param name="value">Объект, используемый в качестве значения добавляемого элемента.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="key"/> имеет значение null.</exception><exception cref="T:System.ArgumentException">Элемент с таким ключом уже существует в <see cref="T:System.Collections.Generic.IDictionary`2"/>.</exception><exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.Generic.IDictionary`2"/> доступен только для чтения.</exception>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.Remove(`0)">
            <summary>
            Удаляет элемент с указанным ключом из <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            Значение true, если элемент успешно удален, в противном случае — значение false.  Этот метод также возвращает значение false, если параметр <paramref name="key"/> не найден в исходном объекте <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
            <param name="key">Ключ элемента, который необходимо удалить.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="key"/> имеет значение null.</exception><exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.Generic.IDictionary`2"/> доступен только для чтения.</exception>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.TryGetValue(`0,`1@)">
            <summary>
            Получает значение, связанное с указанным ключом.
            </summary>
            <returns>
            Значение true, если объект, реализующий <see cref="T:System.Collections.Generic.IDictionary`2"/>, содержит элемент с указанным ключом, в противном случае — значение false.
            </returns>
            <param name="key">Ключ, значение которого необходимо получить.</param><param name="value">Этот метод возвращает значение, связанное с указанным ключом, если он найден; в противном случае — значение по умолчанию для данного типа параметра <paramref name="value"/>. Этот параметр передается не инициализированным.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="key"/> имеет значение null.</exception>
        </member>
        <member name="P:System.Collections.Generic.DictionaryReadOnly`2.Item(`0)">
            <summary>
            Получает или задает элемент с указанным ключом.
            </summary>
            <returns>
            Элемент с указанным ключом.
            </returns>
            <param name="key">Ключ элемента, который требуется получить или задать.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="key"/> имеет значение null.</exception><exception cref="T:System.Collections.Generic.KeyNotFoundException">Свойство получено и параметр <paramref name="key"/> не найден.</exception><exception cref="T:System.NotSupportedException">Свойство задано, и объект <see cref="T:System.Collections.Generic.IDictionary`2"/> доступен только для чтения.</exception>
        </member>
        <member name="P:System.Collections.Generic.DictionaryReadOnly`2.Keys">
            <summary>
            Получает интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>, содержащий ключи <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>, содержащий ключи объекта, который реализует <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
        </member>
        <member name="P:System.Collections.Generic.DictionaryReadOnly`2.Values">
            <summary>
            Получает интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>, содержащий значения <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>, содержащий значения объекта, который реализует <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
        </member>
        <member name="T:System.FuncExtensions">
            <summary>Класс методов-расширений для функции</summary>
        </member>
        <member name="M:System.FuncExtensions.InvokeAsync``1(System.Func{``0})">
            <summary>синхронный вызов функции</summary>
            <param name="func">Вызываемая функция</param>
            <typeparam name="TResult">Тип значения функции</typeparam>
            <returns>Задача асинхронного вычисления значения функции</returns>
        </member>
        <member name="M:System.FuncExtensions.InvokeAsync``2(System.Func{``0,``1},``0)">
            <summary>синхронный вызов функции</summary>
            <param name="func">Вызываемая функция</param>
            <param name="value">Значение параметра функции</param>
            <typeparam name="TValue">Тип параметра функции</typeparam>
            <typeparam name="TResult">Тип значения функции</typeparam>
            <returns>Задача асинхронного вычисления значения функции</returns>
        </member>
        <member name="M:System.FuncExtensions.ToEvaluation``1(System.Func{``0},System.String)">
            <summary>Преобразование функции в вычисление</summary>
            <typeparam name="T">Тип возвращаемого функцией результата</typeparam>
            <param name="function">Преобразуемая функция</param>
            <param name="Name">Имя вычисления</param>
            <returns>Вычисление функции</returns>
        </member>
        <member name="M:System.FuncExtensions.GetRoot_NewtonsMethod(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double},System.Double,System.Int32,System.Double)">
            <summary>Поиск нуля функции методом Ньютона</summary>
            <param name="f">Исследуемая функция</param>
            <param name="df">Дифференциал исследуемой функции</param>
            <param name="x0">Начальное приближение</param>
            <param name="MaxIterations">Максимальное количество итераций. <exception cref="T:System.IndexOutOfRangeException"/> при превышении</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.IndexOutOfRangeException">Если корень не найден за указанное число шагов</exception>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtensions.GetRoot_NewtonsMethodAsync(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double},System.Double,System.Int32,System.Double)">
            <summary>Поиск нуля функции методом Ньютона</summary>
            <param name="f">Исследуемая функция</param>
            <param name="df">Дифференциал исследуемой функции</param>
            <param name="x0">Начальное приближение</param>
            <param name="MaxIterations">Максимальное количество итераций. <exception cref="T:System.IndexOutOfRangeException"/> при превышении</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.IndexOutOfRangeException">Если корень не найден за указанное число шагов</exception>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtensions.GetRoot_BisectionMethod(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32,System.Double)">
            <summary> Поиск нуля функции методом бисекции</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="MaxIterations">Максимальное количество итераций. <exception cref="T:System.IndexOutOfRangeException"/> при превышении</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.ArithmeticException"><paramref name="f" /> is equal to <see cref="F:System.Double.NaN" />. </exception>
            <exception cref="T:System.IndexOutOfRangeException">Если корень не найден за указанное число шагов</exception>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtensions.GetRoot_BisectionMethodAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32,System.Double)">
            <summary> Поиск нуля функции методом бисекции</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="MaxIterations">Максимальное количество итераций. <exception cref="T:System.IndexOutOfRangeException"/> при превышении</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.ArithmeticException"><paramref name="f" /> is equal to <see cref="F:System.Double.NaN" />. </exception>
            <exception cref="T:System.IndexOutOfRangeException">Если корень не найден за указанное число шагов</exception>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtensions.GetRoot_GoldenSection(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary> Поиск нуля функции методом Золотого сечения</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtensions.GetRoot_GoldenSectionAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary> Поиск нуля функции методом Золотого сечения</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtensions.GetRoot_TernarySearch(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary> Поиск нуля функции методом Троичного деления</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtensions.GetRoot_TernarySearchAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary> Поиск нуля функции методом Троичного деления</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtensions.GetRoot_FalsePositionMethod(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32,System.Double)">
            <summary>Поиск нуля функции методом False position</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="MaxIterations">Максимальное допустимое число итераций метода</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtensions.GetRoot_FalsePositionMethodAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32,System.Double)">
            <summary>Поиск нуля функции методом False position</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="MaxIterations">Максимальное допустимое число итераций метода</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtensions.GetRoot_MethodOfChords(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary> Поиск нуля функции методом хорд</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtensions.GetRoot_MethodOfChordsAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary> Поиск нуля функции методом хорд</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtensions.Carrying``3(System.Func{``0,``1,``2})">
            <summary>Каррирование функции двух параметров</summary>
            <typeparam name="TArg1">Тип значение первого параметра функции</typeparam>
            <typeparam name="TArg2">Тип значение второго параметра функции</typeparam>
            <typeparam name="TResult">Тип результата функции</typeparam>
            <param name="f">Каррируемая функция</param>
        </member>
        <member name="M:System.FuncExtensions.Add(System.Func{System.Double,System.Double},System.Double)">
            <summary>Сложение функции с числом g(x) = f(x) + a</summary>
            <param name="f">Исходная функция</param>
            <param name="a">Прибавляемое число</param>
            <returns>Новая функция, значения которой равны значениям исходной функции плюс указанному числу</returns>
        </member>
        <member name="M:System.FuncExtensions.Add(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double})">
            <summary>Сложение двух функций g(x) = f1(x) + f2(x)</summary>
            <param name="f1">Функция - первое слагаемое</param>
            <param name="f2">Функция - второе слагаемое</param>
            <returns>Функция, значения которой равны сумме значений двух исходных функций</returns>
        </member>
        <member name="M:System.FuncExtensions.ArgumentReverse(System.Func{System.Double,System.Double})">
            <summary>Изменение знака аргумента функции g(x) = f(-x)</summary>
            <param name="f">Исходная функция</param>
            <returns>Новая функция, значения аргумента которой отрицательны по отношению к аргументу исходной функции g(x) = f(-x)</returns>
        </member>
        <member name="M:System.FuncExtensions.ArgumentShift(System.Func{System.Double,System.Double},System.Double)">
            <summary>Смещение аргумента функции на указанное значение g(x) = f(x-a)</summary>
            <param name="f">Исходная функция</param>
            <param name="x0">Значение смещения аргумента</param>
            <returns>Новая функция со смещённым аргументом</returns>
        </member>
        <member name="M:System.FuncExtensions.ArgumentCompression(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>Сжатие аргумента функции g(x) = f(k * x + b)</summary>
            <param name="f">Исходная функция</param>
            <param name="k">Коэффициент сжатия аргумента</param>
            <param name="b">Коэффициент смещения аргумента</param>
            <returns>Новая функция со сжатым и смещённым аргументом</returns>
        </member>
        <member name="M:System.FuncExtensions.Divide(System.Func{System.Double,System.Double},System.Double)">
            <summary>Деление функции на число g(x) = f(x) / a</summary>
            <param name="f">Делимая функция</param>
            <param name="a">Вещественный делитель</param>
            <returns>
            Функция, значения которой равны значениям исходной функции, делимые на вещественный делитель.
            Если вещественный делитель равен 0, то возвращается функция, значения которой равны +бесконечности если
            аргумент больше нуля, -бесконечности, если аргумент меньше нуля и NaN, если аргумент равен нулю.
            </returns>
        </member>
        <member name="M:System.FuncExtensions.Divide(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double})">
            <summary>Деление функции на функцию g(x) = f1(x) / f2(x)</summary>
            <param name="f1">Функция - делимое</param>
            <param name="f2">Функция - делитель</param>
            <returns>Функция, значения которой равны отношению значений исходных функций</returns>
        </member>
        <member name="M:System.FuncExtensions.Func(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double})">
            <summary>Функция от функции q(f(x))</summary>
            <param name="f">Внутренняя функция</param>
            <param name="q">Внешняя функция</param>
            <returns>Функция q от функции f</returns>
        </member>
        <member name="M:System.FuncExtensions.FuncFrom``2(System.Func{``0,``1},System.Func{System.Func{``0,``1},System.Func{``0,``1}})">
            <summary>Функция от функции - функционал (преобразователь функции)</summary>
            <typeparam name="TIn">Тип аргумента функции</typeparam>
            <typeparam name="TOut">Тип значения функции</typeparam>
            <param name="f">Исходная (преобразуемая) функция</param>
            <param name="q">Метод преобразования исходной функции, тип значения которого соответствует типу исходной функции</param>
            <returns>Новая функция, преобразованная указанным методом на основе исходной функции</returns>
        </member>
        <member name="M:System.FuncExtensions.FuncFor(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double})">
            <summary>Функция от функции f(q(x))</summary>
            <param name="f">Внешняя функция</param>
            <param name="q">Внутренняя функция</param>
            <returns>Функция f от функции q</returns>
        </member>
        <member name="M:System.FuncExtensions.GetAkf(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>Получить автокорреляционную функцию от указанной функции</summary>
            <param name="f">Исходная функция</param>
            <param name="DeltaX">Диапазон корреляции</param>
            <param name="x0">Смещение</param>
            <returns>Автокорреляционная функция</returns>
        </member>
        <member name="M:System.FuncExtensions.GetConvolution(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>Функция корреляции между двумя функциями на указанному интервале корреляции с указанным смещением</summary>
            <param name="f">Первая функция</param>
            <param name="g">Вторая функция</param>
            <param name="DeltaX">Интервал корреляции</param>
            <param name="x0">Смещение</param>
            <returns>Функция корреляции двух исходных функций</returns>
        </member>
        <member name="M:System.FuncExtensions.GetDifferential(System.Func{System.Double,System.Double},System.Double,System.Int32)">
            <summary>Функция численного дифференцирования исходной функции</summary>
            <param name="f">Исходная функция</param>
            <param name="dx">Дифференциальный участок</param>
            <param name="n">Номер метода численного дифференцирования в пределах [0,4]</param>
            <returns>Функция численного дифференциала от исходной функции</returns>
        </member>
        <member name="M:System.FuncExtensions.GetDifferentialValue(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32)">
            <summary>Определение значения численного дифференциала в указанной точке, с указанным шагом дифференцирования и номером метода</summary>
            <param name="f">Дифференцируемая функция</param>
            <param name="x">Точка дифференцирования</param>
            <param name="dx">Шаг дифференцирования</param>
            <param name="n">Номер метода</param>
            <returns>Численное значение дифференциала функции в указанной точке</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegralValue(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>Определённый численный интеграл функции (метод трапеций)</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Начальное значение интервала интегрирования</param>
            <param name="x2">Конечное значение интервала интегрирования</param>
            <param name="f0">Начальное значение функции</param>
            <param name="dx">Шаг интегрирования</param>
            <returns>Значение результата численного интегрирования функции методом трапеций</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegralValueAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>Определённый численный интеграл функции (метод трапеций)</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Начальное значение интервала интегрирования</param>
            <param name="x2">Конечное значение интервала интегрирования</param>
            <param name="f0">Начальное значение функции</param>
            <param name="dx">Шаг интегрирования</param>
            <returns>Значение результата численного интегрирования функции методом трапеций</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegral2Value(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Двойной определённый численный интеграл функции (метод трапеций)</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Начальное значение интервала интегрирования</param>
            <param name="x2">Конечное значение интервала интегрирования</param>
            <param name="f0">Начальное значение функции</param>
            <param name="f1">Начальное значение первой производной</param>
            <param name="dx">Шаг интегрирования</param>
            <returns>Значение результата двойного численного интегрирования функции методом трапеций</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegral2ValueAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Определённый численный интеграл функции (метод трапеций)</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Начальное значение интервала интегрирования</param>
            <param name="x2">Конечное значение интервала интегрирования</param>
            <param name="f0">Начальное значение функции</param>
            <param name="f1">Начальное значение первой производной</param>
            <param name="dx">Шаг интегрирования</param>
            <returns>Значение результата численного интегрирования функции методом трапеций</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegralValue(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>Интегрирование функции с модификацией ядра интеграла</summary>
            <param name="f">Подинтегральная функция f(x)</param>
            <param name="Core">Ядро интегрирования: Core(f(x),x)</param>
            <param name="x1">Начало интервала интегрирования</param>
            <param name="x2">Конец интервала интегрирования</param>
            <param name="f0">Начальное значение функции</param>
            <param name="dx">Шаг интегрирования</param>
            <returns>Значение определённого интеграла от ядра интегрирования методом трапеций</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegralValueAsync(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>Рассчитать интеграл функции асинхронно</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="Core">Ядро интегрирования</param>
            <param name="x1">Начало интервала интегрирования</param>
            <param name="x2">Конец интервала интегрирования</param>
            <param name="f0">Начальное значение функции (задача Коши)</param>
            <param name="dx">Шаг интегрирования</param>
            <returns>Задача расчёта значения интеграла функции</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegral2Value(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double,System.Double},System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Интегрирование функции с модификацией ядра интеграла</summary>
            <param name="f">Подинтегральная функция f(x)</param>
            <param name="Core">Ядро интегрирования: Core(f(x),x)</param>
            <param name="x1">Начало интервала интегрирования</param>
            <param name="x2">Конец интервала интегрирования</param>
            <param name="f0">Начальное значение функции</param>
            <param name="f1">Начальное значение первой производной</param>
            <param name="dx">Шаг интегрирования</param>
            <returns>Значение определённого интеграла от ядра интегрирования методом трапеций</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegral2ValueAsync(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>Асинхронный расчёт двойного интеграла функции</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="Core">Ядро интегрирования</param>
            <param name="x1">Начало интервала интегрирования</param>
            <param name="x2">Конец интервала интегрирования</param>
            <param name="f0">Начальное значение функции (задача Коши)</param>
            <param name="dx">Шаг интегрирования</param>
            <returns>Задача численного расчёта второго интеграла функции</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegralValue_Simpson(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32)">
            <summary>Численный расчёт определённого интеграла методом Симпсона</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Нижний предел интегрирования</param>
            <param name="x2">Верхний предел интегрирования</param>
            <param name="N">Число интервалов интегрирования N > 2</param>
            <returns>Интеграл функции на отрезке методом Симпсона</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegralValue_Simpson(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>Численный расчёт определённого интеграла методом симпсона</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Нижний предел интегрирования</param>
            <param name="x2">Верхний предел интегрирования</param>
            <param name="dx">Шаг интегрирования</param>
            <param name="f0">Начальное значение функции</param>
            <returns>Интеграл функции на отрезке методом Симпсона</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegralValue_SimpsonAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32)">
            <summary>Численный расчёт определённого интеграла методом симпсона</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Нижний предел интегрирования</param>
            <param name="x2">Верхний предел интегрирования</param>
            <param name="N">Число интервалов интегрирования N > 2</param>
            <returns>Интеграл функции на отрезке методом Симпсона</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegralValue_Adaptive(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32,System.Double)">
            <summary>Численный расчёт определённого интеграла методом адаптивного разбиения</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Нижний предел интегрирования</param>
            <param name="x2">Верхний предел интегрирования</param>
            <param name="N">Начальное разбиение отрезка (по умолчанию 2 точки)</param>
            <param name="Eps">Точность вычисления интеграла</param>
            <returns>Адаптивный интеграл функции</returns>
            <remarks>
            Функция рекуррентно на каждом этапе рассчитывает два численных интеграла (методом Симпсона): для указанного числа точек и для удвоенного.
            Если разница между рассчитанными интегралами меньше указанной точности, то возвращается значение интеграла для удвоенного числа точек
            Иначе рекуррентно рассчитывается сумма двух интегралов (адаптивным методом) для правой и левой половины интервала интегрирования с удвоенным
            числом точек для каждого из них. Для каждой половины рекуррентно повторяется проделанная процедура 
            </remarks>
        </member>
        <member name="M:System.FuncExtensions.GetIntegralValue_AdaptiveAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32,System.Double)">
            <summary>Численный расчёт определённого интеграла методом адаптивного разбиения</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Нижний предел интегрирования</param>
            <param name="x2">Верхний предел интегрирования</param>
            <param name="N">Начальное разбиение отрезка</param>
            <param name="Eps">Точность вычисления интеграла</param>
            <returns>Адаптивный интеграл функции</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegralValue_Spline(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32)">
            <summary>Значение интеграла функции методом сплайнов</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Начало отрезка интегрирования</param>
            <param name="x2">Конец отрезка интегрирования</param>
            <param name="N">Разбиение интервала интегрирования</param>
            <returns>Значение интеграла функции</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegralValue_SplineAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32)">
            <summary>Значение интеграла функции методом сплайнов</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Начало отрезка интегрирования</param>
            <param name="x2">Конец отрезка интегрирования</param>
            <param name="N">Разбиение интервала интегрирования</param>
            <returns>Значение интеграла функции</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegral(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Получить функцию-интеграл от функции</summary>
            <param name="f">Подинтегральная функция</param>
            <param name="x0">Начальное положение интегрирования</param>
            <param name="C">Константа интегрирования</param>
            <param name="Eps">Точность интегрирования</param>
            <returns>Функция-интеграл от исходной функции</returns>
        </member>
        <member name="M:System.FuncExtensions.GetPeriodic(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>Создать периодическую функцию на основе исходной</summary>
            <param name="f">Исходная функция</param>
            <param name="T">Период</param>
            <param name="x0">Смещение</param>
            <returns>Периодическая функция</returns>
        </member>
        <member name="M:System.FuncExtensions.GetPower(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>Определить мощность функции</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала</param>
            <param name="x2">Конец интервала</param>
            <returns>Значение интеграла от квадрата функции</returns>
        </member>
        <member name="M:System.FuncExtensions.Sampling``1(System.Func{System.Double,``0},System.Double,System.Double,System.Double)">
            <summary>Дискретизация функции</summary>
            <typeparam name="T">Тип значения функции</typeparam>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="dx">Шаг дискретизации</param>
            <returns>Перечисление дискретных значений функции</returns>
        </member>
        <member name="M:System.FuncExtensions.Sampling``1(System.Func{System.Double,``0},System.Double,System.Double,System.Int32)">
            <summary>Дискретизация функции</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="dx">Шаг изменения аргумента</param>
            <param name="SamplesCount">Число формируемых отсчётов</param>
            <typeparam name="T">Тип значения функции</typeparam>
            <returns>Массив значений функции, полученных в результате дискретизации</returns>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на функцию</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Если указано число отсчётов меньше 0, либо если <paramref name="dx"/> равен 0</exception>
        </member>
        <member name="M:System.FuncExtensions.GetValues``2(System.Func{``0,``1},``0[])">
            <summary>Определение значений функции в дискретном перечне значений аргумента</summary>
            <typeparam name="TArgument">Тип аргумента</typeparam>
            <typeparam name="TResult">Тип значения функции</typeparam>
            <param name="f">Дискретизируемая функция</param>
            <param name="args">Массив аргументов функции</param>
            <returns>Массив значений функции для указанных значений аргументов</returns>
        </member>
        <member name="M:System.FuncExtensions.GetValues``1(System.Func{System.Double,``0},System.Double,System.Double,System.Double)">
            <summary>Получить массив значений функции на указанном интервале с указанным шагом дискретизации</summary>
            <typeparam name="TResult">Тип значений функции</typeparam>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="dx">Шаг дискретизации</param>
            <returns>Массив значений функции</returns>
        </member>
        <member name="M:System.FuncExtensions.Inverse(System.Func{System.Double,System.Double})">
            <summary>Получить функцию, значения которой обратны к значениям исходной функции g(x) = 1 / f(x)</summary>
            <param name="f">Исходная функция</param>
            <returns>Функция, значения которой обратны по отношению исходной функции</returns>
        </member>
        <member name="M:System.FuncExtensions.Multiply(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double})">
            <summary>Произведение двух функций g(x) = f1(x) * f2(x)</summary>
            <param name="f1">Функция - первый сомножитель</param>
            <param name="f2">Функция - второй сомножитель</param>
            <returns>Функция - произведение двух функций</returns>
        </member>
        <member name="M:System.FuncExtensions.Multiply(System.Func{System.Double,System.Double},System.Double)">
            <summary>Произведение функции на число g(x) = f(x) * a</summary>
            <param name="f">Исходная функция</param>
            <param name="a">Число</param>
            <returns>Функция, значения которой равны произведению значений исходной функции на указанное число</returns>
        </member>
        <member name="M:System.FuncExtensions.Power(System.Func{System.Double,System.Double},System.Double)">
            <summary>Возведение функции в вещественную степень</summary>
            <param name="f">Исходная функция</param>
            <param name="a">Вещественная степень</param>
            <returns>Функция, значения которой равны возведению в указанную степень значений исходной функции</returns>
        </member>
        <member name="M:System.FuncExtensions.Reverse(System.Func{System.Double,System.Double})">
            <summary>Получение отрицательной функции</summary>
            <param name="f">Исходная функция</param>
            <returns>Функция, значения которой обратны по знаку к исходной функции</returns>
        </member>
        <member name="M:System.FuncExtensions.SetParameter(System.Func{System.Double,System.Double,System.Double},System.Double,System.Boolean)">
            <summary>Установка значения параметра функции двух переменных</summary>
            <param name="f">Исходная функция двух переменных</param>
            <param name="a">Устанавливаемое значение параметра</param>
            <param name="IsFirst">Параметром является первый аргумент функции? (по умолчанию - нет)</param>
            <returns>Функция одного переменного, полученная на основе исходной функции двух переменных установкой одного в значение указанного параметра</returns>
        </member>
        <member name="M:System.FuncExtensions.Subtract(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double})">
            <summary>Вычитание одной функции из другой g(x) = f1(x) - f2(x)</summary>
            <param name="f1">Функция - уменьшаемое</param>
            <param name="f2">Функция - вычитаемое</param>
            <returns>Функция, значения которой численно равны разности значений двух исходных функций</returns>
        </member>
        <member name="M:System.FuncExtensions.Subtract(System.Func{System.Double,System.Double},System.Double)">
            <summary>Вычитание из функции числа g(x) = f(x) - a</summary>
            <param name="f">Исходная функция</param>
            <param name="a">вычитаемое из функции число</param>
            <returns>Функция, значения которой численно равны разности значений исходной функции и указанного числа</returns>
        </member>
        <member name="M:System.FuncExtensions.GetValuesParallel``2(System.Func{``0,``1},System.Collections.Generic.IEnumerable{``0})">
            <summary>Вычислить значения функции параллельно</summary>
            <param name="f">Вычисляемая функция</param>
            <param name="Arguments">Область определения</param>
            <typeparam name="TArgument">Тип аргумента</typeparam>
            <typeparam name="TResult">Тип значения</typeparam>
            <returns>Массив значений функции</returns>
        </member>
        <member name="T:System.FuncExtensions.Integrator">
            <summary>Интегратор функции</summary>
        </member>
        <member name="F:System.FuncExtensions.Integrator._LockObject">
            <summary>Объект синхронизации потоков при доступе к параметрам интегратора</summary>
        </member>
        <member name="P:System.FuncExtensions.Integrator.C">
            <summary>Константа интегрирования</summary>
        </member>
        <member name="P:System.FuncExtensions.Integrator.x0">
            <summary>Начальное положение интегратора</summary>
        </member>
        <member name="P:System.FuncExtensions.Integrator.f">
            <summary>Интегрируемая функция</summary>
        </member>
        <member name="M:System.FuncExtensions.Integrator.#ctor(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>Инициализация нового интегратора функции</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x0">Начальное положение интегратора</param>
            <param name="C">Константа интегрирования</param>
        </member>
        <member name="M:System.FuncExtensions.Integrator.GetValue(System.Double,System.Double)">
            <summary>Метод расчёта интеграла от предыдущего положения интегратора до указанного</summary>
            <param name="x">Требуемое значение конца интервала интегрирования</param>
            <param name="Eps">Точность процесса интегрирования</param>
            <returns>Значение численного интеграла на интервале от предыдущего положения интегратора до указанного</returns>
        </member>
        <member name="M:System.FuncExtensions.Integrator.GetIntegral(System.Double)">
            <summary>Получить функцию, равную интегралу от интегрируемой функции</summary>
            <param name="Eps">Точность интегрирования</param>
            <returns>Интеграл функции</returns>
        </member>
        <member name="T:System.FuncExtensions.VectorAddDelegate">
            <summary>Делегат функции сложения двух векторов</summary>
            <param name="C">Вектор результата сложения</param>
            <param name="B">Вектор первого слагаемого</param>
            <param name="A">Вектор второго слагаемого</param>
            <param name="length">Длина векторов</param>
        </member>
        <member name="M:System.FuncExtensions.CreateFastFloatSummator">
            <summary>Метод генерации быстрого сумматора двух векторов вещественных чисел</summary>
            <returns>Метод сложения двух векторов вещественных чисел</returns>
        </member>
        <member name="T:System.FuncExtensions.SamplingResult`1">
            <summary>Результат дискретизации функции</summary>
            <typeparam name="TValue">Тип значений функции</typeparam>
        </member>
        <member name="T:System.FuncExtensions.SamplingResult`1.Result">
            <summary>Отсчёт функции</summary>
        </member>
        <member name="F:System.FuncExtensions.SamplingResult`1.Result.Argument">
            <summary>Значение аргумента отсчёта</summary>
        </member>
        <member name="F:System.FuncExtensions.SamplingResult`1.Result.Value">
            <summary>Значение функции</summary>
        </member>
        <member name="M:System.FuncExtensions.SamplingResult`1.Result.#ctor(System.Double,`0)">
            <summary>Инициализация нового отсчёта функции</summary>
            <param name="Argument">Значение аргумента функции</param>
            <param name="Value">Значение функции</param>
        </member>
        <member name="M:System.FuncExtensions.SamplingResult`1.Result.op_Implicit(System.FuncExtensions.SamplingResult{`0}.Result)~System.ValueTuple{System.Double,`0}">
            <summary>Оператор неявного приведения отсчёта функции к кортежу двух элементов - значение отсчёта функции - значение функции</summary>
            <param name="result">Отсчёт функции</param>
        </member>
        <member name="P:System.FuncExtensions.SamplingResult`1.Values">
            <summary>Перечисление отсчётов функции</summary>
        </member>
        <member name="P:System.FuncExtensions.SamplingResult`1.Accuracy">
            <summary>Оценка точности дискретизации</summary>
        </member>
        <member name="M:System.FuncExtensions.SamplingResult`1.#ctor(System.Collections.Generic.IEnumerable{System.FuncExtensions.SamplingResult{`0}.Result},System.Double)">
            <summary>Инициализация нового результата дискретизации функции</summary>
            <param name="Values">Перечисление отсчётов функции</param>
            <param name="Accuracy">Оценка точности дискретизации</param>
        </member>
        <member name="T:System.FuncExtensions.SimpleSamplingResult">
            <summary>Результат дискретизации вещественной функции</summary>
        </member>
        <member name="M:System.FuncExtensions.SimpleSamplingResult.Sampling(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Метод дискретизации</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="dx">Шаг дискретизации</param>
            <returns>Кортеж, содержащий связанный список дискретов функции и оценку точности дискретизации</returns>
        </member>
        <member name="F:System.FuncExtensions.SimpleSamplingResult._F">
            <summary>Дискретизируемая функция</summary>
        </member>
        <member name="F:System.FuncExtensions.SimpleSamplingResult._List">
            <summary>Связанный список отсчётов функции</summary>
        </member>
        <member name="M:System.FuncExtensions.SimpleSamplingResult.#ctor(System.ValueTuple{System.Collections.Generic.LinkedList{System.FuncExtensions.SamplingResult{System.Double}.Result},System.Double})">
            <summary>Инициализация нового результата дискретизации по кортежу дискретов функции и оценки точности дискретизации</summary>
            <param name="SamplingResult">Кортеж дискретов функции и оценки точности дискретизации</param>
        </member>
        <member name="M:System.FuncExtensions.SimpleSamplingResult.#ctor(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Инициализация нового результата дискретизации</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Окончание интервала дискретизации</param>
            <param name="dx">Шаг дискретизации</param>
        </member>
        <member name="M:System.FuncExtensions.SimpleSamplingResult.ClarifySampling(System.Double)">
            <summary>Уточнение результата дискретизации</summary>
            <param name="accuracy">Требуемая точность</param>
            <returns>Истина, если требуемая точность достигнута</returns>
        </member>
        <member name="M:System.FuncExtensions.SimpleSamplingResult.GetValues">
            <summary>Метод получения отсчётов функции</summary>
            <returns>Массив отсчётов функции</returns>
        </member>
        <member name="M:System.FuncExtensions.SimpleSamplingResult.op_Implicit(System.FuncExtensions.SimpleSamplingResult)~System.FuncExtensions.SamplingResult{System.Double}.Result[]">
            <summary>Оператор неявного приведения типа результата дискретизации к типу массива отсчётов функции</summary>
            <param name="result">Результат дискретизации</param>
        </member>
        <member name="M:System.FuncExtensions.SamplingAdaptive(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Адаптивный метод дискретизации вещественной функции</summary>
            <param name="f">Дискретизируемая вещественная функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Окончание интервала дискретизации</param>
            <param name="Eps">Точность дискретизации</param>
            <returns>Результат дискретизации вещественной функции</returns>
        </member>
        <member name="M:System.FuncExtensions.SamplingAdaptive``1(System.Func{System.Double,``0},System.Func{``0,System.Double},System.Double,System.Double,System.Double)">
            <summary>Адаптивный метод дискретизации функции</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="converter">Конвертер преобразования значения функции в вещественное число для оценки точности дискретизации</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Окончание интервала дискретизации</param>
            <param name="Eps">Точность дискретизации</param>
            <returns>Результат дискретизации функции</returns>
        </member>
        <member name="T:System.FuncExtensions.AdaptiveSamplingResult`1">
            <summary>Результат адаптивной дискретизации</summary>
            <typeparam name="T">Тип значения дискретизируемой функции</typeparam>
        </member>
        <member name="M:System.FuncExtensions.AdaptiveSamplingResult`1.Sampling(System.Func{System.Double,`0},System.Func{`0,System.Double},System.Double,System.Double,System.Double)">
            <summary>Метод дискретизации функции</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="converter">Метод преобразования значений функции в вещественное число для оценки точности дискретизации</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="dx">Начальный шаг дискретизации</param>
            <returns>Кортеж со списком значений функции и вещественным число, оценивающим точность дискретизации</returns>
        </member>
        <member name="F:System.FuncExtensions.AdaptiveSamplingResult`1._List">
            <summary>Связанный список с дискретами функции</summary>
        </member>
        <member name="F:System.FuncExtensions.AdaptiveSamplingResult`1._F">
            <summary>Дискретизируемая функция</summary>
        </member>
        <member name="F:System.FuncExtensions.AdaptiveSamplingResult`1._Converter">
            <summary>Метод преобразования значений функции в вещественное число для оценки качества дискретизации</summary>
        </member>
        <member name="M:System.FuncExtensions.AdaptiveSamplingResult`1.#ctor(System.ValueTuple{System.Collections.Generic.LinkedList{System.FuncExtensions.SamplingResult{`0}.Result},System.Double})">
            <summary>Инициализация нового адаптивного дискретизатора</summary>
            <param name="SamplingResult">Список отсчётов дискретизации функции и оценка точности дискретизации</param>
        </member>
        <member name="M:System.FuncExtensions.AdaptiveSamplingResult`1.#ctor(System.Func{System.Double,`0},System.Func{`0,System.Double},System.Double,System.Double,System.Double)">
            <summary>Инициализация нового адаптивного дискретизатора</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="converter">Метод преобразования значений функции в вещественное число для оценки качества дискретизации</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="dx">Начальный шаг дискретизации</param>
        </member>
        <member name="M:System.FuncExtensions.AdaptiveSamplingResult`1.ClarifySampling(System.Double)">
            <summary>Точная дискретизации</summary>
            <param name="accuracy">Требуемая точность</param>
            <returns>Полученная точность дискретизации</returns>
        </member>
        <member name="M:System.FuncExtensions.AdaptiveSamplingResult`1.GetValues">
            <summary>Получить отсчёты функции в виде массива значений</summary>
            <returns>Массив значений функции</returns>
        </member>
        <member name="M:System.FuncExtensions.AdaptiveSamplingResult`1.op_Implicit(System.FuncExtensions.AdaptiveSamplingResult{`0})~System.FuncExtensions.SamplingResult{`0}.Result[]">
            <summary>Оператор неявного преобразования результатов адаптивной дискретизации функции в массив её значений</summary>
            <param name="result">Результаты адаптивной дискретизации функции</param>
        </member>
        <member name="T:System.FuncExtensions.SamplingResultOneWay">
            <summary>Результаты дискретизации функции адаптивным однопроходным методом</summary>
        </member>
        <member name="M:System.FuncExtensions.SamplingResultOneWay.#ctor(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>Инициализация нового результата адаптивной дискретизации однопроходным методом</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="Eps">Требуемая точность дискретизации</param>
            <param name="dx">Начальный шаг дискретизации</param>
        </member>
        <member name="M:System.FuncExtensions.SamplingAdaptive_OneWay(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>Однопроходный адаптивный метод дискретизации функции</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="Eps">Требуемая точность дискретизации</param>
            <param name="dx">Начальный шаг дискретизации</param>
            <returns>Результат дискретизации</returns>
        </member>
        <member name="M:System.FuncExtensions.SamplingAdaptive_OneWay(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Double,System.Action{System.Double})">
            <summary>Метод однопроходной адаптивной дискретизации функции</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="Eps">Требуемая точность дискретизации</param>
            <param name="dx">Начальный шаг дискретизации</param>
            <param name="UpdateAccuracy">Метод обновления значения точности дискретизации в процесс самой дискретизации</param>
            <returns>Перечисление результатов дискретизации</returns>
        </member>
        <member name="T:System.FuncExtensions.SamplingResultOneWayT`1">
            <summary>Результаты адаптивной однопроходной дискретизации функции значений указанного типа</summary>
            <typeparam name="T">Тип значений функции</typeparam>
        </member>
        <member name="M:System.FuncExtensions.SamplingAdaptive_OneWay``1(System.Func{System.Double,``0},System.Func{``0,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>Адаптивная дискретизация функции в один проход</summary>
            <typeparam name="T">Тип значений функции</typeparam>
            <param name="f">Дискретизируемая функция</param>
            <param name="Converter">Метод преобразования значений функции в вещественные числа для оценки качества дискретизации</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="Eps">Требуемая точность дискретизации</param>
            <param name="dx">Начальный шаг дискретизации</param>
            <returns>Результат дискретизации функции</returns>
        </member>
        <member name="M:System.FuncExtensions.SamplingAdaptive_OneWayT``1(System.Func{System.Double,``0},System.Func{``0,System.Double},System.Double,System.Double,System.Double,System.Double,System.Action{System.Double})">
            <summary>Метод последовательной дискретизации функции с адаптивным шагом</summary>
            <typeparam name="T">Тип значений функции</typeparam>
            <param name="f">Дискретизируемая функция</param>
            <param name="Converter">Метод преобразования значений функции в вещественные числа для оценки качества дискретизации</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="Eps">Требуемая точность</param>
            <param name="dx">Начальный шаг дискретизации</param>
            <param name="UpdateAccuracy">Метод обновления значения текущего уровня точности дискретизации</param>
            <returns>Перечисление отсчётов функции</returns>
        </member>
        <member name="T:System.FuncExtensions.SamplingResultHalfDivision">
            <summary>Результат дискретизации методом половинного деления</summary>
        </member>
        <member name="M:System.FuncExtensions.SamplingResultHalfDivision.#ctor(System.ValueTuple{System.FuncExtensions.SamplingResult{System.Double}.Result[],System.Double})">
            <summary>Инициализация нового экземпляра результата дискретизации методом половинного деления</summary>
            <param name="Data">Результаты дискретизации, содержащие массив отсчётов функции и значение точности</param>
        </member>
        <member name="M:System.FuncExtensions.SamplingResultHalfDivision.#ctor(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Инициализация нового экземпляра результата дискретизации функции методом половинного деления</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="Eps">Требуемая точность</param>
        </member>
        <member name="M:System.FuncExtensions.SamplingAdaptive_HalfDivision(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Дискретизация функции методом половинного деления</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Результат дискретизации функции методом половинного деления</returns>
        </member>
        <member name="M:System.FuncExtensions.SamplingAdaptive_HalfDivision_(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Метод дискретизации функции методом половинного деления</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Результаты дискретизации</returns>
        </member>
        <member name="T:System.FuncExtensions.SamplingResultHalfDivisionT`1">
            <summary>Результат дискретизации методом половинного деления</summary>
            <typeparam name="T">Тип значений функции</typeparam>
        </member>
        <member name="M:System.FuncExtensions.SamplingResultHalfDivisionT`1.#ctor(System.ValueTuple{System.FuncExtensions.SamplingResult{`0}.Result[],System.Double})">
            <summary>Инициализация нового экземпляра результата дискретизации методом половинного деления</summary>
            <param name="Data">Результаты дискретизации, содержащие массив отсчётов функции и значение точности</param>
        </member>
        <member name="M:System.FuncExtensions.SamplingResultHalfDivisionT`1.#ctor(System.Func{System.Double,`0},System.Func{`0,System.Double},System.Double,System.Double,System.Double)">
            <summary>Инициализация нового экземпляра результата дискретизации функции методом половинного деления</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="converter">Метод преобразования значений функции в вещественные числа для оценки качества дискретизации</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="Eps">Требуемая точность</param>
        </member>
        <member name="M:System.FuncExtensions.SamplingAdaptive_HalfDivision``1(System.Func{System.Double,``0},System.Func{``0,System.Double},System.Double,System.Double,System.Double)">
            <summary>Дискретизациия функции методом половинного деления</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="converter">Метод преобразования значений функции в вещественные числа для оценки качества дискретизации</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Результат дискретизации функции методом половинного деления</returns>
        </member>
        <member name="M:System.FuncExtensions.SamplingAdaptive_HalfDivision_``1(System.Func{System.Double,``0},System.Func{``0,System.Double},System.Double,System.Double,System.Double)">
            <summary>Метод дискретизации функции методом половинного деления</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="converter">Метод преобразования значений функции в вещественные числа для оценки качества дискретизации</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Результаты дискретизации</returns>
        </member>
        <member name="M:System.EnumExtensions.GetValueAttribute``1(System.Enum)">
            <exception cref="T:System.TypeLoadException">A custom attribute type cannot be loaded. </exception>
            <exception cref="T:System.InvalidOperationException">This member belongs to a type that is loaded into the reflection-only context. See How to: Load Assemblies into the Reflection-Only Context.</exception>
        </member>
        <member name="M:System.EnumExtensions.GetValueDescription(System.Enum)">
            <exception cref="T:System.TypeLoadException">A custom attribute type cannot be loaded. </exception>
        </member>
        <member name="T:System.EventHandlerExtension">
            <summary>Класс методов расширений для обработчиков событий</summary>
        </member>
        <member name="M:System.EventHandlerExtension.Start(System.Collections.Specialized.NotifyCollectionChangedEventHandler,System.Object,System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="M:System.EventHandlerExtension.Start(System.ComponentModel.PropertyChangedEventHandler,System.Object,System.String)">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="PropertyName">Имя изменившегося свойства</param>
        </member>
        <member name="M:System.EventHandlerExtension.Start(System.ComponentModel.PropertyChangedEventHandler,System.Object,System.String[])">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="PropertyName">Имена изменившихся свойств</param>
        </member>
        <member name="M:System.EventHandlerExtension.Start(System.ComponentModel.PropertyChangedEventHandler,System.Object,System.ComponentModel.PropertyChangedEventArgs)">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="M:System.EventHandlerExtension.Start(System.EventHandler,System.Object,System.EventArgs)">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="M:System.EventHandlerExtension.StartAsync(System.EventHandler,System.Object,System.EventArgs,System.AsyncCallback,System.Object)">
            <summary>Потоко-безопасная асинхронная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
            <param name="CallBack">Метод завершения генерации события</param>
            <param name="State">Объект-состояние, передаваемый в метод завершения генерации события</param>
        </member>
        <member name="M:System.EventHandlerExtension.FastStart(System.EventHandler,System.Object)">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
        </member>
        <member name="M:System.EventHandlerExtension.FastStart(System.EventHandler,System.Object,System.EventArgs)">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="M:System.EventHandlerExtension.FastStart``1(System.EventHandler{``0},System.Object,``0)">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <typeparam name="TEventArgs">Тип аргумента события</typeparam>
            <param name="e">Аргументы события</param>
        </member>
        <member name="M:System.EventHandlerExtension.Start``1(System.EventHandler{``0},System.Object,``0)">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <typeparam name="TEventArgs">Тип аргумента события</typeparam>
            <param name="e">Аргументы события</param>
        </member>
        <member name="M:System.EventHandlerExtension.StartAsync``1(System.EventHandler{``0},System.Object,``0,System.AsyncCallback,System.Object)">
            <summary>Потоко-безопасная асинхронная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <typeparam name="TEventArgs">Тип аргумента события</typeparam>
            <param name="e">Аргументы события</param>
            <param name="CallBack">Метод завершения генерации события</param>
            <param name="State">Объект-состояние, передаваемый в метод завершения генерации события</param>
        </member>
        <member name="M:System.EventHandlerExtension.Start``3(System.EventHandler{``0,``1,``2},``1,``2)">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <typeparam name="TArgs">Тип аргумента события</typeparam>
            <param name="Args">Аргументы события</param>
            <typeparam name="TResult">Тип результата обработки события</typeparam>
            <typeparam name="TSender">Тип источника события</typeparam>
            <returns>Массив результатов обработки события</returns>
        </member>
        <member name="T:System.EventHandlerTyped1Extension">
            <summary>Класс методов расширений для обработчиков событий</summary>
        </member>
        <member name="M:System.EventHandlerTyped1Extension.Start``2(System.EventHandler{``0,``1},``0,System.EventArgs{``1})">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="M:System.EventHandlerTyped1Extension.StartAsync``2(System.EventHandler{``0,``1},``0,System.EventArgs{``1},System.AsyncCallback,System.Object)">
            <summary>Потоко-безопасная асинхронная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
            <param name="CallBack">Метод завершения генерации события</param>
            <param name="State">Объект-состояние, передаваемый в метод завершения генерации события</param>
        </member>
        <member name="M:System.EventHandlerTyped1Extension.FastStart``2(System.EventHandler{``0,``1},``0)">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
        </member>
        <member name="M:System.EventHandlerTyped1Extension.FastStart``2(System.EventHandler{``0,``1},``0,System.EventArgs{``1})">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="T:System.EventHandlerTyped2Extension">
            <summary>Класс методов расширений для обработчиков событий</summary>
        </member>
        <member name="M:System.EventHandlerTyped2Extension.Start``3(System.EventHandler{``0,``1,``2},``0,System.EventArgs{``1,``2})">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="M:System.EventHandlerTyped2Extension.StartAsync``3(System.EventHandler{``0,``1,``2},``0,System.EventArgs{``1,``2},System.AsyncCallback,System.Object)">
            <summary>Потоко-безопасная асинхронная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
            <param name="CallBack">Метод завершения генерации события</param>
            <param name="State">Объект-состояние, передаваемый в метод завершения генерации события</param>
        </member>
        <member name="M:System.EventHandlerTyped2Extension.FastStart``3(System.EventHandler{``0,``1,``2},``0)">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
        </member>
        <member name="M:System.EventHandlerTyped2Extension.FastStart``3(System.EventHandler{``0,``1,``2},``0,System.EventArgs{``1,``2})">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="T:System.EventHandlerTyped3Extension">
            <summary>Класс методов расширений для обработчиков событий</summary>
        </member>
        <member name="M:System.EventHandlerTyped3Extension.Start``4(System.EventHandler{``0,``1,``2,``3},``0,System.EventArgs{``1,``2,``3})">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="M:System.EventHandlerTyped3Extension.StartAsync``4(System.EventHandler{``0,``1,``2,``3},``0,System.EventArgs{``1,``2,``3},System.AsyncCallback,System.Object)">
            <summary>Потоко-безопасная асинхронная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
            <param name="CallBack">Метод завершения генерации события</param>
            <param name="State">Объект-состояние, передаваемый в метод завершения генерации события</param>
        </member>
        <member name="M:System.EventHandlerTyped3Extension.FastStart``4(System.EventHandler{``0,``1,``2,``3},``0)">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
        </member>
        <member name="M:System.EventHandlerTyped3Extension.FastStart``4(System.EventHandler{``0,``1,``2,``3},``0,System.EventArgs{``1,``2,``3})">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="T:System.IComparableExtensions">
            <summary>Класс методов-расширений для сравнимых объектов</summary>
        </member>
        <member name="M:System.IComparableExtensions.Search``1(``0[],System.Int32,System.Int32,``0)">
            <summary>Метод поиска элемента в упорядоченной коллекции половинным делением</summary>
            <typeparam name="T">Тип элементов коллекции</typeparam>
            <param name="Collection">Массив элементов, упорядоченный по возрастанию</param>
            <param name="From">Начальный индекс поиска</param>
            <param name="To">Конечный индекс поиска</param>
            <param name="Item">Искомый элемент</param>
            <returns>Индекс элемента в массиве</returns>
        </member>
        <member name="M:System.IO.BinaryReaderExtensions.IsEOF(System.IO.BinaryReader)">
            <summary>Признак конца потока</summary>
            <param name="reader">Объект чтения потока</param>
            <returns>Истина, если поток закончен</returns>
        </member>
        <member name="M:System.IO.BinaryReaderExtensions.GetByteBuffer(System.IO.BinaryReader,System.Int32)">
            <summary>Получить перечисление, содержащее массивы байт заданной длины из потока</summary>
            <param name="reader">Объект чтения потока данных</param>
            <param name="BufferSize">Размер буфера</param>
            <returns>Перечислитель</returns>
        </member>
        <member name="T:System.IO.DirectoryInfoExtensions">
            <summary>Класс методов-расширений для объектов класса System.IO.DirectoryInfo</summary>
        </member>
        <member name="M:System.IO.DirectoryInfoExtensions.GetFilesCount(System.IO.DirectoryInfo)">
            <summary>Определить число всех вложенных файлов</summary>
            <param name="Directory">Исследуемая директория</param>
            <returns>Число файлов во всех вложенных поддиректориях</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExtensions.GetSize(System.IO.DirectoryInfo)">
            <summary>Определить объём всех вложенных файлов включая поддиректории</summary>
            <param name="Directory">Исследуемая директория</param>
            <returns>Число байт всех вложенных файлов</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExtensions.GetSubdirectoriesCount(System.IO.DirectoryInfo)">
            <summary>Определить число поддиректорий</summary>
            <param name="Directory">Исследуемая директория</param>
            <returns>Число элементов в дереве поддиректорий</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExtensions.IsEmpty(System.IO.DirectoryInfo)">
            <summary>Проверить - является ли директория пустой</summary>
            <param name="Directory">Проверяемая директория</param>
            <returns>Истина, если директория пуста</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExtensions.GetWatcher(System.IO.DirectoryInfo,System.String)">
            <summary>Получить объект наблюдения за директорией</summary>
            <param name="directory">Наблюдаемая директория</param>
            <param name="filter">Фильтр файлов</param>
            <returns>Объект наблюдатель</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExtensions.SubDirectoryOrCreate(System.IO.DirectoryInfo,System.String)">
            <summary>Получение поддиректории по заданному пути. Если поддиректория отсутствует, то создать новую</summary>
            <param name="ParentDirectory">Родительская директория</param>
            <param name="SubDirectoryPath">Относительный путь к поддиректории</param>
            <returns>Поддиректория</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExtensions.SubDirectory(System.IO.DirectoryInfo,System.String)">
            <summary>Формирование информации о поддиректории, заданной своим именем, либо относительным путём</summary>
            <param name="Directory">Корневая директория</param><param name="SubDirectoryPath">Путь к поддиректории</param>
            <exception cref="T:System.ArgumentNullException">Если указана пустая ссылка на <paramref name="Directory"/></exception>
            <exception cref="T:System.ArgumentNullException">Если указана пустая ссылка на <paramref name="SubDirectoryPath"/></exception>
            <returns>Информация о поддиректории</returns>
        </member>
        <member name="T:System.IO.FileInfoExtensions">
            <summary>Класс методов расширений для объектов класса System.IO.FileInfo</summary>
        </member>
        <member name="M:System.IO.FileInfoExtensions.CopyTo(System.IO.FileInfo,System.IO.DirectoryInfo)">
            <summary>Скопировать файл в директорию</summary>
            <param name="SourceFile">Файл источник</param>
            <param name="DestinationDirectory">Директория назначения</param>
            <returns>Файл копия</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.CopyTo(System.IO.FileInfo,System.IO.DirectoryInfo,System.Boolean)">
            <summary>Скопировать файл в директорию</summary>
            <param name="SourceFile">Файл источник</param>
            <param name="DestinationDirectory">Директория назначения</param>
            <param name="Overwrite">Перезаписать в случае наличия файла</param>
            <returns>Файл копия</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.CopyTo(System.IO.FileInfo,System.IO.FileInfo)">
            <summary>Скопировать файл</summary>
            <param name="SourceFile">Файл источник</param>
            <param name="DestinationFile">Файл копия</param>
        </member>
        <member name="M:System.IO.FileInfoExtensions.CopyTo(System.IO.FileInfo,System.IO.FileInfo,System.Boolean)">
            <summary>Скопировать файл</summary>
            <param name="SourceFile">Файл источник</param>
            <param name="DestinationFile">Файл копия</param>
            <param name="Overwrite">Перезаписать в случае наличия файла</param>
        </member>
        <member name="M:System.IO.FileInfoExtensions.GetFileNameWithoutExtension(System.IO.FileInfo)">
            <summary>Получить имя файла без расширения</summary>
            <param name="file">Файл</param>
            <returns>Имя файла без расширения</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.GetFullFileNameWithoutExtension(System.IO.FileInfo)">
            <summary>Получить имя файла без расширения</summary>
            <param name="file">Файл</param>
            <returns>Имя файла без расширения</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.GetFullFileNameWithNewExtension(System.IO.FileInfo,System.String)">
            <summary>Получить имя файла c новым расширением</summary>
            <param name="file">Файл</param>
            <param name="NewExt">Новое расширение файла в формате ".exe"</param>
            <returns>Имя файла без расширения</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.WriteAllBytes(System.IO.FileInfo,System.Byte[],System.Boolean)">
            <summary>Записать массив байт в файл</summary>
            <param name="file">Файл данных</param>
            <param name="Data">Данные</param>
            <param name="Append">Если истина, то данные будут добавлены в конец файла</param>
        </member>
        <member name="M:System.IO.FileInfoExtensions.WriteAllBytes(System.IO.FileInfo,System.IO.Stream,System.Int32,System.Boolean,System.Func{System.Int64,System.Byte[],System.Boolean},System.EventHandler{System.EventArgs{System.IO.FileInfo,System.IO.Stream}})">
            <summary>Записать все данные из потока в файл</summary>
            <param name="file">Файл данных</param>
            <param name="DataStream">Поток - источник данных</param>
            <param name="BufferSize">Размер буфера чтения по умолчанию 1024 байта</param>
            <param name="Append">Флаг добавления данных в конец файла</param>
            <param name="CompleteHandler">
            Обработчик текущего положения каретки чтения данных из потока. 
            Вызывается после чтения данных в буфер и до помещения их в файл.
            Должен вернуть истину, что бы данные были переданы в файл и процесс был продолжен.
            </param>
            <param name="OnComplete">Обработчик события завершения процесса записи данных</param>
        </member>
        <member name="M:System.IO.FileInfoExtensions.GetWatcher(System.IO.FileInfo)">
            <summary>Получить объект наблюдения за файлом</summary>
            <param name="file">Наблюдаемый файл</param>
            <returns>Объект наблюдатель</returns>
        </member>
        <member name="M:System.IO.StreamExtensions.GetBufferedStream(System.IO.Stream,System.Int32)">
            <summary>Создать буферизованный поток данных</summary>
            <param name="DataStream">Исходный поток данных</param>
            <param name="BufferSize">Размер буфера (по умолчанию 4096 байта)</param>
            <returns>Буферизованный поток данных</returns>
        </member>
        <member name="T:System.Xml.Serialization.XmlSerializerExtensions">
            <summary>Класс методов-расширений для XML-сериализаторов</summary>
        </member>
        <member name="F:System.Xml.Serialization.XmlSerializerExtensions.__XmlSerializersPool">
            <summary>Словарь типов - сериализаторов</summary>
        </member>
        <member name="M:System.Xml.Serialization.XmlSerializerExtensions.GetXmlSerializer(System.Type)">
            <summary>Получить XML-сериализатор по указанному типу</summary>
            <param name="type">Тип XML-сериализатора</param>
            <returns>XML-сериализатор</returns>
        </member>
        <member name="M:System.Xml.Serialization.XmlSerializerExtensions.GetXmlSerializer``1">
            <summary>Получить XML-сериализатор по указанному типу</summary>
            <param name="type">Тип XML-сериализатора</param>
            <returns>XML-сериализатор</returns>
        </member>
        <member name="T:System.Xml.Serialization.IXmlSerializableAsync">
            <summary>Асинхронно сериализуемый в XML объект</summary>
        </member>
        <member name="M:System.Xml.Serialization.IXmlSerializableAsync.ReadXmlAsync(System.Xml.XmlReader)">
            <summary>Асинхронное чтение данных из XML</summary>
            <param name="reader">Источник данных XML</param>
            <returns>Задача процесса чтения данных</returns>
        </member>
        <member name="M:System.Xml.Serialization.IXmlSerializableAsync.WriteXmlAsync(System.Xml.XmlWriter)">
            <summary>Асинхронная запись данных в XML</summary>
            <param name="writer">Объект записи данных</param>
            <returns>Задача записи данных</returns>
        </member>
        <member name="M:System.Xml.XPath.ChildQuery.GetValue(System.Xml.XPath.XPathReader)">
            <exception cref="T:System.Xml.XPath.XPathReaderException">Can't get the child value</exception>
        </member>
        <member name="M:System.Xml.XPath.DescendantQuery.GetValue(System.Xml.XPath.XPathReader)">
            <exception cref="T:System.Xml.XPath.XPathReaderException">Can't get the decedent nodes value</exception>
        </member>
        <member name="M:System.Xml.XPath.FilterQuery.GetValue(System.Xml.XPath.XPathReader)">
            <exception cref="T:System.Xml.XPath.XPathReaderException">Can't get value</exception>
        </member>
        <member name="M:System.Xml.XPath.QueryBuilder.ProcessAxis(System.Xml.XPath.Axis,System.Xml.XPath.Query)">
            
        </member>
        <member name="T:System.Xml.XPath.XmlCaseOrder">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XPath.XmlCaseOrder.None">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XPath.XmlCaseOrder.UpperFirst">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XPath.XmlCaseOrder.LowerFirst">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.XPath.XmlCharType">
            <internalonly />
            <devdoc>
            </devdoc>
        </member>
        <member name="T:System.Xml.XPath.XmlDataType">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XPath.XmlDataType.Text">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XPath.XmlDataType.Number">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XmlReaderWrapper.Close">
            <inheritdoc />
        </member>
        <member name="M:System.Xml.XPath.XPathCollection.MatchesAny(System.Collections.ArrayList,System.Int32)">
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is <see langword="null" />.</exception>
        </member>
        <member name="M:System.Xml.XPath.XPathParser.ParseXPathExpression(System.String)">
            <exception cref="T:System.Xml.XPath.XPathException"><see cref="P:System.Xml.XPath.XPathScanner.SourceText"/>  has an invalid token</exception>
        </member>
        <member name="M:System.Xml.XPath.XPathParser.ParseXPathPattern(System.String)">
            <exception cref="T:System.Xml.XPath.XPathException"><see cref="P:System.Xml.XPath.XPathScanner.SourceText"/>  has an invalid token</exception>
        </member>
        <member name="P:System.Xml.XPath.XPathQuery.GetXPathQueries">
            use can store this compiled expression to query other documents
        </member>
        <member name="M:System.Xml.XPath.XPathQuery.ToString">
            <inheritdoc />
        </member>
        <member name="M:System.Xml.XPath.XPathQuery.Match">
            <summary>Report if the current query is matched</summary>
            <returns>true if current query is matched</returns>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.NodeType">
            <devdoc>
                <para>
                    Gets the type of the current node.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.Name">
            <devdoc>
                <para>
                    Gets the name of
                    the current node, including the namespace prefix.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.LocalName">
            <devdoc>
                <para>
                    Gets the name of the current node without the namespace prefix.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.NamespaceURI">
            <devdoc>
                <para>
                    Gets the namespace URN (as defined in the W3C Namespace Specification) of the current namespace scope.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.Prefix">
            <devdoc>
                <para>
                    Gets the namespace prefix associated with the current node.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.HasValue">
            <devdoc>
                <para>
                    Gets a value indicating whether
                    <see cref='P:System.Xml.XPath.XPathReader.Value' /> has a value to return.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.Value">
            <devdoc>
                <para>
                    Gets the text value of the current node.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.Depth">
            <devdoc>
                <para>
                    Gets the depth of the
                    current node in the XML element stack.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.BaseURI">
            <devdoc>
                <para>
                    Gets the base URI of the current node.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.IsEmptyElement">
            <devdoc>
                <para>
                    Gets a value indicating whether
                    the current
                    node is an empty element (for example, &lt;MyElement/&gt;).
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.IsDefault">
            <devdoc>
                <para>
                    Gets a value indicating whether the current node is an
                    attribute that was generated from the default value defined
                    in the DTD or schema.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.QuoteChar">
            <devdoc>
                <para>
                    Gets the quotation mark character used to enclose the value of an attribute
                    node.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.XmlSpace">
            <devdoc>
                <para>Gets the current xml:space scope.</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.XmlLang">
            <devdoc>
                <para>Gets the current xml:lang scope.</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.AttributeCount">
            <devdoc>
                <para> The number of attributes on the current node.</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.Item(System.Int32)">
            <devdoc>
                <para>Gets the value of the attribute with the specified index.</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.Item(System.String)">
            <devdoc>
                <para>
                    Gets the value of the attribute with the specified
                    <see cref='P:System.Xml.XPath.XPathReader.Name' /> .
                </para>
            </devdoc>
            <exception cref="T:System.InvalidOperationException">
                An <see cref="T:System.Xml.XmlReader" /> method was called before a
                previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" /> is thrown
                with the message “An asynchronous operation is already in progress.”
            </exception>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.Item(System.String,System.String)">
            <devdoc>
                <para>
                    Gets the value of the attribute with the
                    specified <see cref='P:System.Xml.XPath.XPathReader.LocalName' /> and
                    <see cref='P:System.Xml.XPath.XPathReader.NamespaceURI' /> .
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.EOF">
            <devdoc>
                <para>
                    Gets
                    a value indicating whether XmlReader is positioned at the end of the
                    stream.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.ReadState">
            <devdoc>
                <para>
                    Returns
                    the read state of the stream.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.NameTable">
            <devdoc>
                <para>
                    Gets the XmlNameTable associated with this
                    implementation.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.#ctor(System.Xml.XmlReader,System.Xml.XPath.XPathCollection)">
            <internalonly />
            <devdoc>
                <para>
                    Initializes a new instance of the XPathReader class with the specified XmlNameTable.
                    This constructor is used when creating reader with "new XPathReader(..)"
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.#ctor(System.String,System.String)">
            <internalonly />
            <devdoc>
                <para>
                    Initializes a new instance of the XPathReader class with the specified XmlNameTable.
                    This constructor is used when creating reader with "new XPathReader(..)"
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.#ctor(System.IO.TextReader,System.String)">
            <internalonly />
            <devdoc>
                <para>
                    Initializes a new instance of the XPathReader class with the specified XmlNameTable.
                    This constructor is used when creating reader with "new XPathReader(..)"
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.#ctor(System.String,System.Xml.XPath.XPathCollection)">
            <internalonly />
            <devdoc>
                <para>
                    Initializes a new instance of the XPathReader class with the specified XmlNameTable.
                    This constructor is used when creating reader with "new XPathReader(..)"
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.Match(System.Int32)">
            <internalonly />
            <devdoc>
                <para>
                    Initializes a new instance of the XPathReader class with the specified XmlNameTable.
                    This constructor is used when creating reader with "new XPathReader(..)"
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.Match(System.String)">
            <internalonly />
            <devdoc>
                <para>
                    Initializes a new instance of the XPathReader class with the specified XmlNameTable.
                    This constructor is used when creating reader with "new XPathReader(..)"
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.Match(System.Xml.XPath.XPathQuery)">
            <internalonly />
            <devdoc>
                <para>return true when the </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.MatchesAny(System.Collections.ArrayList)">
            <internalonly />
            <devdoc>
                <para> return true if one of the queries matches with the XmlReader context. </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.ReadUntilMatch">
            <internalonly />
            <devdoc>
                <para> return true if one of the queries matches with the XmlReader context. </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.Read">
            <devdoc>
                <para>
                    Reads the next
                    node from the stream.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.MoveToAttribute(System.String)">
            <devdoc>
                <para>Moves to the attribute with the specified <see cref='P:System.Xml.XPath.XPathReader.Name' /> .</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.MoveToAttribute(System.String,System.String)">
            <devdoc>
                <para>
                    Moves to the attribute with the specified <see cref='P:System.Xml.XPath.XPathReader.LocalName' />
                    and <see cref='P:System.Xml.XPath.XPathReader.NamespaceURI' /> .
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.MoveToAttribute(System.Int32)">
            <devdoc>
                <para>Moves to the attribute with the specified index.</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.MoveToFirstAttribute">
            <devdoc>
                <para>
                    Moves to the first attribute.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.MoveToNextAttribute">
            <devdoc>
                <para>
                    Moves to the next attribute.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.MoveToElement">
            <devdoc>
                <para>
                    Moves to the element that contains the current attribute node.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.GetAttribute(System.String)">
            <devdoc>
                <para>
                    Gets the value of the attribute with the specified
                    <see cref='P:System.Xml.XPath.XPathReader.Name' /> .
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.GetAttribute(System.String,System.String)">
            <devdoc>
                <para>
                    Gets the value of the attribute with the
                    specified <see cref='P:System.Xml.XPath.XPathReader.LocalName' /> and
                    <see cref='P:System.Xml.XPath.XPathReader.NamespaceURI' /> .
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.GetAttribute(System.Int32)">
            <devdoc>
                <para>Gets the value of the attribute with the specified index.</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.Close">
            <devdoc>
                <para>
                    Closes the stream, changes the <see cref='P:System.Xml.XPath.XPathReader.ReadState' />
                    to Closed, and sets all the properties back to zero.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.ReadString">
            <devdoc>
                <para>Reads the contents of an element as a string.</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.LookupNamespace(System.String)">
            <devdoc>
                <para>
                    Resolves a namespace prefix in the current element's scope.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.ResolveEntity">
            <devdoc>
                <para>Resolves the entity reference for nodes of NodeType EntityReference.</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.ReadAttributeValue">
            <devdoc>
                <para>
                    Parses the attribute value into one or more Text and/or EntityReference node
                    types.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.ReadInnerXml">
            <devdoc>
                <para>Reads all the content (including markup) as a string.</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.ReadOuterXml">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.XPath.XPathReaderException">
            <devdoc>
                <para>
                    Represents the exception that is thrown when there is error processing an
                    XPath expression.
                </para>
            </devdoc>
        </member>
        <member name="M:System.ByteExtensions.IsPowerOf2(System.Byte)">
            <summary>Является ли число степенью двойки?</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число - степень двойки 1,2,4...1024,2048...2^n</returns>
        </member>
        <member name="M:System.ByteExtensions.BitCount(System.Byte)">
            <summary>Число бит числа</summary>
            <param name="x">Значащее число</param>
            <returns>Число бит числа</returns>
        </member>
        <member name="M:System.ByteExtensions.BitReversing(System.Byte,System.Int32)">
            <summary>Реверсирование бит числа</summary>
            <param name="x">исходное число</param>
            <param name="N">Число резервируемых бит [ = 16 ]</param>
            <returns>Инверсированное число</returns>
        </member>
        <member name="M:System.ByteExtensions.IsOdd(System.Byte)">
            <summary>Является ли число нечётным</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число нечётное</returns>
        </member>
        <member name="M:System.ByteExtensions.IsEven(System.Byte)">
            <summary>Является ли число чётным</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число чётное</returns>
        </member>
        <member name="T:System.DecimalExtensions">
            <summary>Расширения для чисел двойной точности</summary>
        </member>
        <member name="M:System.DecimalExtensions.Sqrt(System.Decimal,System.Decimal)">
            <summary>Вычисление квадратного корня указанной точности последовательными приближениями</summary>
            <param name="x">Число, квадратный корень которого требуется вычислить</param>
            <param name="epsilon">Требуемая точность</param>
            <returns>Квадратный корень числа</returns>
        </member>
        <member name="M:System.DecimalExtensions.IsInt(System.Decimal)">
            <summary>Является ли число целым?</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число целое</returns>
        </member>
        <member name="M:System.DecimalExtensions.GetInverse(System.Decimal)">
            <summary>Получить обратное число</summary>
            <param name="x">Инвертируемое число</param>
            <returns>Число, обратное к исходном</returns>
        </member>
        <member name="T:System.DoubleArrayExtensions">
            <summary>Методы-расширения для массивов вещественных чисел</summary>
        </member>
        <member name="M:System.DoubleArrayExtensions.Add(System.Double[],System.Double)">
            <summary>Прибавить значение ко всем элементам массива</summary>
            <param name="array">Массив вещественных чисел</param>
            <param name="value">Прибавляемое ко всем элементам значение</param>
        </member>
        <member name="M:System.DoubleArrayExtensions.Add(System.Double[],System.Double[])">
            <summary>Поэлементно сложить два массива (для минимального числа совпадающих элементов)</summary>
            <param name="array">Массив - первое слагаемое</param>
            <param name="values">Массив - второе слагаемое</param>
        </member>
        <member name="M:System.DoubleArrayExtensions.Average(System.Double[][])">
            <summary>Усреднить значения всех массивов</summary>
            <param name="array">Усредняемые массивы</param>
            <returns>Массив средних значений</returns>
        </member>
        <member name="M:System.DoubleArrayExtensions.Dispersion(System.Double[])">
            <summary>Рассчитать дисперсию массива как M{X^2} - M{X}^2</summary>
            <param name="array">Массив, дисперсию элементов которого требуется рассчитать</param>
            <returns>Если длина 0, то NaN, если длина 1, то 0, иначе - дисперсия элементов массива</returns>
        </member>
        <member name="T:System.DoubleExtensions">
            <summary>Расширения для чисел двойной точности</summary>
        </member>
        <member name="M:System.DoubleExtensions.Sqrt(System.Double)">
            <summary>Квадратный корень</summary>
            <param name="x">Число из которого извлекается квадратный корень</param>
            <returns>Квадратный корень числа</returns>
        </member>
        <member name="M:System.DoubleExtensions.IsInt(System.Double)">
            <summary>Является ли число целым?</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число целое</returns>
        </member>
        <member name="M:System.DoubleExtensions.IsNaN(System.Double)">
            <summary>Является ли значение "не числом"?</summary>
            <param name="x">Проверяемое значение</param>
            <returns>Истина, если значение - не число</returns>
        </member>
        <member name="M:System.DoubleExtensions.Round(System.Double,System.Int32)">
            <summary>Округление числа до указанного количества знаков после запятой </summary>
            <param name="x">Округляемое число</param>
            <param name="n">Количество знаков после запятой при n >= 0 и до запятой при n меньше 0</param>
            <returns>Число, округлённое до указанной точности</returns>
        </member>
        <member name="M:System.DoubleExtensions.RoundAdaptive(System.Double,System.Int32)">
            <summary>Адаптивное округление</summary>
            <param name="x">Округляемая величина</param>
            <param name="n">Количество значащих разрядов</param>
            <returns>Число с указанным количеством значащих разрядов</returns>
        </member>
        <member name="M:System.DoubleExtensions.GetInverse(System.Double)">
            <summary>Получить обратное число</summary>
            <param name="x">Инвертируемое число</param>
            <returns>Число, обратное к исходном</returns>
        </member>
        <member name="M:System.DoubleExtensions.GetAbsMod(System.Double,System.Double)">
            <summary>Число по модулю</summary>
            <param name="x">Исходное число</param>
            <param name="mod">Модуль</param>
            <returns>Число по модулю</returns>
        </member>
        <member name="M:System.DoubleExtensions.GetAbs(System.Double)">
            <summary>Модуль числа</summary>
            <param name="x">Действительное вещественное число</param>
            <returns>Модуль числа</returns>
        </member>
        <member name="M:System.DoubleExtensions.Power(System.Double,System.Int32)">
            <summary>Возведение в целую степень</summary>
            <param name="x">Действительное число</param>
            <param name="n">Целочисленный показатель степени</param>
            <returns>x^n</returns>
        </member>
        <member name="M:System.DoubleExtensions.Power(System.Double,System.Double)">
            <summary>Возведение числа в действительную степень</summary>
            <param name="x">Основание</param><param name="y">Действительный показатель степени</param>
            <returns>Действительное число x возведённое в степень y: x^y</returns>
        </member>
        <member name="M:System.DoubleExtensions.Power(System.Double,MathCore.Complex)">
            <summary>Возведение числа в комплексную степень</summary>
            <param name="x">Основание</param><param name="z">Комплексный показатель степень</param>
            <returns>Значение x^z, где x - действительное, z - комплексное</returns>
        </member>
        <member name="M:System.DoubleExtensions.In_dB(System.Double)">
            <summary>Преобразование в децибелы по амплитуде</summary>
            <param name="x">Амплитудное значение 20*lg(x)</param>
            <returns>Значение в децибелах</returns>
        </member>
        <member name="M:System.DoubleExtensions.In_dB_byPower(System.Double)">
            <summary>Преобразование в децибелы по мощности</summary>
            <param name="x">Значение мощности 10*lg(x)</param>
            <returns>Значение в децибелах</returns>
        </member>
        <member name="M:System.DoubleExtensions.From_dB(System.Double)">
            <summary>Преобразование из децибелов в разы по значению (амплитуде)</summary>
            <param name="db">Значение в децибелах 10^(x/20)</param>
            <returns>Значение в разах по амплитуде</returns>
        </member>
        <member name="M:System.DoubleExtensions.From_dB_byPower(System.Double)">
            <summary>Преобразование из децибелов в разы по мощности</summary>
            <param name="db">Значение в децибелах 10^(x/10)</param>
            <returns>Значение в разах по мощности</returns>
        </member>
        <member name="M:System.DoubleExtensions.ToRad(System.Double)">
            <summary>Преобразование значения в радианы</summary>
            <param name="deg">Значение в градусах</param>
            <returns>Значение в радианах</returns>
        </member>
        <member name="M:System.DoubleExtensions.ToDeg(System.Double)">
            <summary>Преобразование значения в градусы</summary>
            <param name="rad">Значение в радианах</param>
            <returns>Значение в градусах</returns>
        </member>
        <member name="T:System.IntExtensions">
            <summary>Класс методов-расширений для класса целых 4-х-байтовых чисел со знаком</summary>
        </member>
        <member name="M:System.IntExtensions.Power(System.Int32,System.Int32)">
            <summary>Возведение целого числа в целую степень</summary>
            <param name="x">Целое основание</param>
            <param name="N">Целый показатель степени</param>
            <returns>Результат возведения целого основания в целую степень</returns>
        </member>
        <member name="M:System.IntExtensions.Power(System.Int32,System.Double)">
            <summary>Возведение целого числа в вещественную степень</summary>
            <param name="x">Целое основание</param>
            <param name="q">Вещественный показатель степени</param>
            <returns>Результат возведения целого основания в вещественную степень</returns>
        </member>
        <member name="M:System.IntExtensions.Power(System.Int32,MathCore.Complex)">
            <summary>Возведение целого числа в комплексную степень</summary>
            <param name="x">Целое основание</param>
            <param name="z">Комплексный показатель степени</param>
            <returns>Результат возведения целого основания в комплексную степень</returns>
        </member>
        <member name="M:System.IntExtensions.FactorizationEnum(System.Int32)">
            <summary>Факторизация целого числа</summary>
            <param name="n">Раскладываемое число</param>
            <returns>Последовательность простых чисел составляющих раскладываемое число</returns>
        </member>
        <member name="M:System.IntExtensions.FactorizationList(System.Int32)">
            <summary>Разложение числа на простые множители</summary>
            <param name="n">Раскладываемое число</param>
            <returns>Массив простых множителей</returns>
        </member>
        <member name="M:System.IntExtensions.Factorization(System.Int32)">
            <summary>Разложение числа на простые множители</summary>
            <param name="n">Раскладываемое число</param>
            <returns>Словарь с делителями числа - значение элементов словаря - кратность делителя</returns>
        </member>
        <member name="M:System.IntExtensions.IsPrime(System.Int32)">
            <summary>Проверка - является ли число простым?</summary>
            <param name="n">Проверяемое число</param>
            <returns>Истина, если число простое</returns>
        </member>
        <member name="M:System.IntExtensions.IsPowerOf2(System.Int32)">
            <summary>Является ли число степенью двойки?</summary>
            <param name="n">Проверяемое число</param>
            <returns>Истина, если число - степень двойки 1,2,4...1024,2048...2^n</returns>
        </member>
        <member name="M:System.IntExtensions.BitCount(System.Int32)">
            <summary>Число бит числа</summary>
            <param name="n">Значащее число</param>
            <returns>Число бит числа</returns>
        </member>
        <member name="M:System.IntExtensions.GetNumberOfDigits(System.Int32,System.Int32)">
            <summary>Получить число разрядов в указанной системе счисления</summary>
            <param name="n">Рассматриваемое число</param>
            <param name="Base">Основание системы счисления. По умолчанию = 10</param>
            <returns>Количество разрядов в указанной системе счисления</returns>
        </member>
        <member name="M:System.IntExtensions.GetBitArray(System.Int32,System.Int32)">
            <summary>Получить битовый массив из числа</summary>
            <param name="Value">Преобразуемое число</param>
            <param name="Length">Длина результирующего массива бит. По умолчанию = 32 битам</param>
            <returns>Битовый массив числа</returns>
        </member>
        <member name="M:System.IntExtensions.BitReversing(System.Int32,System.Int32)">
            <summary>Реверсирование бит числа</summary>
            <param name="x">исходное число</param>
            <param name="N">Число реверсируемых бит</param>
            <returns>Реверсированное число</returns>
        </member>
        <member name="M:System.IntExtensions.BitReversing(System.Int32)">
            <summary>Реверсирование всех 32 бит числа</summary>
            <param name="x">исходное число</param>
            <returns>Реверсированное число</returns>
        </member>
        <member name="M:System.IntExtensions.IsDeviatedTo(System.Int32,System.Int32)">
            <summary>Проверка делимости числа на делитель</summary>
            <param name="x">Делимое</param>
            <param name="y">Делитель</param>
            <returns>Истина, если остаток от целочисленного деления равен 0</returns>
        </member>
        <member name="M:System.IntExtensions.GetAbsMod(System.Int32,System.Int32)">
            <summary>Положительный остаток от деления</summary>
            <param name="x">Делимое</param>
            <param name="mod">Модуль</param>
            <returns>Остаток от деления</returns>
        </member>
        <member name="M:System.IntExtensions.GetAbs(System.Int32)">
            <summary>Получить абсолютное значение числа</summary>
            <param name="x">Вещественное число</param>
            <returns>Модуль числа</returns>
        </member>
        <member name="M:System.IntExtensions.GetNOD(System.Int32,System.Int32)">
            <summary>Наибольший общий делитель</summary>
            <param name="Y">Первое число</param>
            <param name="X">Второе число</param>
            <returns>Наибольший общий делитель</returns>
        </member>
        <member name="M:System.IntExtensions.IsOdd(System.Int32)">
            <summary>Является ли число нечётным</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число нечётное</returns>
        </member>
        <member name="M:System.IntExtensions.IsEven(System.Int32)">
            <summary>Является ли число чётным</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число чётное</returns>
        </member>
        <member name="M:System.IntExtensions.Factorial(System.Int32)">
            <summary>Факториал целого числа >= 0 и значение Г-функции для отрицательных значений</summary>
            <param name="n">Исходное число</param>
            <returns>Факториал числа</returns>
        </member>
        <member name="M:System.IntExtensions.FactorialBigInt(System.Int32)">
            <summary>Факториал целого числа >= 0 и значение Г-функции для отрицательных значений</summary>
            <param name="n">Исходное число</param>
            <returns>Факториал числа</returns>
        </member>
        <member name="M:System.IntExtensions.ToOctBase(System.Int32)">
            <summary>Приведение целого числа в 10 системе счисления к виду системы счисления по основанию 8</summary>
            <param name="n">Число в 10-ой системе счисления</param>
            <returns>Представление числа в 8-ричной системе счисления</returns>
        </member>
        <member name="M:System.IntExtensions.FromOctalBase(System.Int32)">
            <summary>Приведение целого числа в 8 системе счисления к виду системы счисления по основанию 10</summary>
            <param name="x">Число в 8-ой системе счисления</param>
            <returns>Представление числа в 10-ричной системе счисления</returns>
        </member>
        <member name="M:System.LongExtensions.IsPowerOf2(System.Int64)">
            <summary>Является ли число степенью двойки?</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число - степень двойки 1,2,4...1024,2048...2^n</returns>
        </member>
        <member name="M:System.LongExtensions.BitCount(System.Int64)">
            <summary>Число бит числа</summary>
            <param name="x">Значащее число</param>
            <returns>Число бит числа</returns>
        </member>
        <member name="M:System.LongExtensions.BitReversing(System.Int64,System.Int32)">
            <summary>Реверсирование бит числа</summary>
            <param name="x">исходное число</param>
            <param name="N">Число реверсируемых бит</param>
            <returns>Реверсированное число</returns>
        </member>
        <member name="M:System.LongExtensions.BitReversing(System.Int64)">
            <summary>Реверсирование всех 64 бит числа</summary>
            <param name="x">исходное число</param>
            <returns>Реверсированное число</returns>
        </member>
        <member name="M:System.LongExtensions.IsOdd(System.Int64)">
            <summary>Является ли число нечётным</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число нечётное</returns>
        </member>
        <member name="M:System.LongExtensions.IsEven(System.Int64)">
            <summary>Является ли число чётным</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число чётное</returns>
        </member>
        <member name="M:System.ShortExtensions.IsPowerOf2(System.Int16)">
            <summary>Является ли число степенью двойки?</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число - степень двойки 1,2,4...1024,2048...2^n</returns>
        </member>
        <member name="M:System.ShortExtensions.BitCount(System.Int16)">
            <summary>Число бит числа</summary>
            <param name="x">Значащее число</param>
            <returns>Число бит числа</returns>
        </member>
        <member name="M:System.ShortExtensions.BitReversing(System.Int16,System.Int32)">
            <summary>Реверсирование бит числа</summary>
            <param name="x">исходное число</param>
            <param name="N">Число реверсируемых бит</param>
            <returns>Реверсированное число</returns>
        </member>
        <member name="M:System.ShortExtensions.BitReversing(System.Int16)">
            <summary>Реверсирование всех 16 бит числа</summary>
            <param name="x">исходное число</param>
            <returns>Реверсированное число</returns>
        </member>
        <member name="M:System.ShortExtensions.IsOdd(System.Int16)">
            <summary>Является ли число нечётным</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число нечётное</returns>
        </member>
        <member name="M:System.ShortExtensions.IsEven(System.Int16)">
            <summary>Является ли число чётным</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число чётное</returns>
        </member>
        <member name="T:System.ObjectExtensions">
            <summary>Класс методов-расширений для объекта</summary>
        </member>
        <member name="M:System.ObjectExtensions.AsEnumerable``1(``0,System.Func{``0,``0},System.Boolean)">
            <summary>Преобразование объекта в бесконечное перечисление</summary>
            <typeparam name="T">Тип элементов генерируемого перечисления</typeparam>
            <param name="obj">Объект, на основе которого создаётся перечисление</param>
            <param name="NextObject">Метод, генерирующий новый объект последовательности</param>
            <param name="TakeFirst">Выдать в последовательность исходный элемент</param>
            <returns>Бесконечная последовательность элементов, генерируемая указанным методом</returns>
        </member>
        <member name="T:System.ObjectExtensions.ObjectSelector`2">
            <summary>Селектор элементов</summary>
            <typeparam name="TSource">Тип объекта-источника</typeparam>
            <typeparam name="TResult">Тип объекта-значения</typeparam>
        </member>
        <member name="P:System.ObjectExtensions.ObjectSelector`2.Continue">
            <summary>Продолжать выборку?</summary>
        </member>
        <member name="P:System.ObjectExtensions.ObjectSelector`2.Object">
            <summary>Объект-источник</summary>
        </member>
        <member name="P:System.ObjectExtensions.ObjectSelector`2.Result">
            <summary>Объект-значение</summary>
        </member>
        <member name="P:System.ObjectExtensions.ObjectSelector`2.Iteration">
            <summary>Номер итерации</summary>
        </member>
        <member name="M:System.ObjectExtensions.ObjectSelector`2.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.ObjectExtensions.ObjectSelector`2"/></summary>
        </member>
        <member name="M:System.ObjectExtensions.ObjectSelector`2.Next(`1,System.Boolean)">
            <summary>Переход к следующей итерации</summary>
            <param name="result">Результат итерации</param>
            <param name="CanContinue">Продолжать выборку</param>
        </member>
        <member name="M:System.ObjectExtensions.SelectObj``2(``0,System.Action{System.ObjectExtensions.ObjectSelector{``0,``1}})">
            <summary>Генерация последовательности значений на основе алгоритма выборки</summary>
            <typeparam name="TSource">Тип объекта-источника</typeparam>
            <typeparam name="TResult">Тип объекта-значения последовательности</typeparam>
            <param name="source">Источник последовательности</param>
            <param name="Selector">Метод выборки элементов из источника</param>
            <returns>Последовательность объектов, генерируемых на основе объекта-источника</returns>
        </member>
        <member name="M:System.ObjectExtensions.SelectObject``2(``0,System.Func{``0,``1})">
            <summary>Метод преобразования объекта</summary>
            <typeparam name="TSource">Тип источника объекта</typeparam>
            <typeparam name="TResult">Тип результата</typeparam>
            <param name="source">Объект-источник</param>
            <param name="Selector">Метод генерации значения</param>
            <returns>Значение, определяемое на основе объекта-источника указанным методом</returns>
        </member>
        <member name="M:System.ObjectExtensions.ToFormattedString(System.Object,System.String)">
            <summary>Преобразование объекта в форматированную строку</summary>
            <param name="obj">Преобразуемый объект</param>
            <param name="Format">Строка форматирования</param>
            <returns>Форматированная строка текстового представления объекта</returns>
        </member>
        <member name="M:System.ObjectExtensions.ToFormattedString(System.Object,System.String,System.Object[])">
            <summary>Преобразование объекта в форматированную строку</summary>
            <param name="obj">Преобразуемый объект (идущий нулевым аргументом)</param>
            <param name="Format">Строка форматирования</param>
            <param name="args">Массив аргументов, добавляемых к объекту для создание форматированной строки</param>
            <returns>Форматированная строка текстового представления объекта</returns>
        </member>
        <member name="M:System.ObjectExtensions.ToString``1(``0,System.Func{``0,System.String})">
            <summary>Метод преобразования объекта в строку</summary>
            <typeparam name="T">Тип исходного объекта</typeparam>
            <param name="t">Преобразуемый объект</param>
            <param name="converter">Метод преобразования объекта в строку</param>
            <returns>Сгенерированная строка указанным методом на основе указанного объекта</returns>
        </member>
        <member name="M:System.ObjectExtensions.GetHashCode(System.Object[])">
            <summary>Расчёт хеш-кода массива объектов</summary>
            <param name="Objects">Массив объектов, хеш-код которых надо рассчитать</param>
            <returns>Хеш-код массива объектов</returns>
        </member>
        <member name="M:System.ObjectExtensions.GetComplexHashCode(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>Расчёт хеш-кода перечисления объектов</summary>
            <param name="Objects">Перечисление объектов, хеш-код которых надо рассчитать</param>
            <returns>Хеш-код перечисления объектов</returns>
        </member>
        <member name="M:System.ObjectExtensions.GetObjectAttribute``1(System.Object,System.Boolean)">
            <summary>Извлечение атрибута метаданных объекта</summary>
            <typeparam name="TAttribute">Тип извлекаемого атрибута</typeparam>
            <param name="o">Объект, атрибут которого требуется получить</param>
            <param name="Inherited">Искать в цепочке наследования</param>
            <returns>Искомый атрибут в случае его наличия, либо null, если атрибут не определён</returns>
        </member>
        <member name="M:System.ObjectExtensions.GetObjectAttributes``1(System.Object,System.Boolean)">
            <summary>Извлечение всех атрибутов указанного типа для объекта</summary>
            <typeparam name="TAttribute">Тип извлекаемого атрибута</typeparam>
            <param name="o">Объект, атрибуты которого требуется получить</param>
            <param name="Inherited">Искать в цепочке наследования</param>
            <returns>Массив атрибутов указанного типа, определённых для объекта</returns>
        </member>
        <member name="M:System.ObjectExtensions.IsNotNull(System.Object)">
            <summary>Ссылка на объект не равна null</summary>
            <param name="o">Проверяемый объект</param>
            <returns>Истина, если проверяемый объект не null</returns>
        </member>
        <member name="M:System.ObjectExtensions.IsNull(System.Object)">
            <summary>Ссылка на объект равна null</summary>
            <param name="o">Проверяемый объект</param>
            <returns>Истина, если проверяемый объект null</returns>
        </member>
        <member name="M:System.ObjectExtensions.NotNull``1(``0,System.String)">
            <summary>Проверка на пустую ссылку</summary>
            <typeparam name="T">Тип проверяемого объекта</typeparam>
            <param name="obj">Проверяемое значение</param>
            <param name="Message">Сообщение ошибки</param>
            <returns>Значение, точно не являющееся пустой ссылкой</returns>
            <exception cref="T:System.InvalidOperationException">В случае если переданное значение <paramref name="obj"/> == null</exception>
        </member>
        <member name="M:System.ObjectExtensions.ParamNotNull``1(``0,System.String,System.String)">
            <summary>Проверка параметра на <see langword="null"/></summary>
            <typeparam name="T">Тип параметра <paramref name="obj"/></typeparam>
            <param name="obj">Проверяемый на <see langword="null"/> объект</param>
            <param name="ParameterName">Имя параметра для указания его в исключении</param>
            <param name="Message">Сообщение ошибки</param>
            <returns>Объект, гарантированно не <see langword="null"/></returns>
            <exception cref="T:System.ArgumentException">Если параметр <paramref name="obj"/> == <see langword="null"/>.</exception>
        </member>
        <member name="M:System.ObjectExtensions.GetAttributes``2(``1,System.Boolean)">
            <summary>Получение списка атрибутов указанного типа для типа переданного объекта</summary>
            <typeparam name="TAttribute">Тип извлекаемого атрибута</typeparam>
            <typeparam name="TObject">Тип исходного объекта</typeparam>
            <param name="o">Объект, атрибуты которого требуется получить</param>
            <param name="Inherited">Искать в цепочке наследования</param>
            <returns>Массив атрибутов указанного типа, определённых для типа объекта</returns>
        </member>
        <member name="M:System.ObjectExtensions.InitializeObject``1(``0,System.Action{``0})">
            <summary>Инициализировать объект ссылочного типа</summary>
            <typeparam name="T">Тип объекта</typeparam>
            <param name="obj">Инициализируемый объект</param>
            <param name="Initializer">Действие инициализации</param>
            <returns>Инициализированный объект</returns>
        </member>
        <member name="M:System.ObjectExtensions.InitializeObject``2(``0,``1,System.Action{``0,``1})">
            <summary>Инициализировать объект ссылочного типа</summary>
            <typeparam name="T">Тип объекта</typeparam>
            <typeparam name="TP">Тип параметра инициализации</typeparam>
            <param name="obj">Инициализируемый объект</param>
            <param name="parameter">Параметр инициализации</param>
            <param name="Initializer">Действие инициализации</param>
            <returns>Инициализированный объект</returns>
        </member>
        <member name="M:System.ObjectExtensions.InitializeObject``3(``0,``1,``2,System.Action{``0,``1,``2})">
            <summary>Инициализировать объект ссылочного типа</summary>
            <typeparam name="T">Тип объекта</typeparam>
            <typeparam name="TP1">Тип параметра 1 инициализации</typeparam>
            <typeparam name="TP2">Тип параметра 2 инициализации</typeparam>
            <param name="obj">Инициализируемый объект</param>
            <param name="parameter1">Параметр 1 инициализации</param>
            <param name="parameter2">Параметр 2 инициализации</param>
            <param name="Initializer">Действие инициализации</param>
            <returns>Инициализированный объект</returns>
        </member>
        <member name="M:System.ObjectExtensions.InitializeObject``4(``0,``1,``2,``3,System.Action{``0,``1,``2,``3})">
            <summary>Инициализировать объект ссылочного типа</summary>
            <typeparam name="T">Тип объекта</typeparam>
            <typeparam name="TP1">Тип параметра 1 инициализации</typeparam>
            <typeparam name="TP2">Тип параметра 2 инициализации</typeparam>
            <typeparam name="TP3">Тип параметра 3 инициализации</typeparam>
            <param name="obj">Инициализируемый объект</param>
            <param name="parameter1">Параметр инициализации</param>
            <param name="parameter2">Параметр инициализации</param>
            <param name="parameter3">Параметр инициализации</param>
            <param name="Initializer">Действие инициализации</param>
            <returns>Инициализированный объект</returns>
        </member>
        <member name="M:System.ObjectExtensions.InitializeObject``1(``0,System.Func{``0,``0})">
            <summary>Инициализировать объект ссылочного типа</summary>
            <typeparam name="T">Тип объекта</typeparam>
            <param name="obj">Инициализируемый объект</param>
            <param name="Initializer">Функция инициализации, определяющая значение конечного объекта</param>
            <returns>Объект, возвращённый функцией инициализации</returns>
        </member>
        <member name="M:System.ObjectExtensions.InitializeObject``2(``0,``1,System.Func{``0,``1,``0})">
            <summary>Инициализировать объект ссылочного типа</summary>
            <typeparam name="T">Тип объекта</typeparam>
            <typeparam name="TP">Тип параметра инициализации</typeparam>
            <param name="obj">Инициализируемый объект</param>
            <param name="parameter">Параметр инициализации</param>
            <param name="Initializer">Функция инициализации, определяющая значение конечного объекта</param>
            <returns>Объект, возвращённый функцией инициализации</returns>
        </member>
        <member name="M:System.ObjectExtensions.InitializeObject``4(``0,``1,``2,``3,System.Func{``0,``1,``2,``3,``0})">
            <summary>Инициализировать объект ссылочного типа</summary>
            <typeparam name="T">Тип объекта</typeparam>
            <typeparam name="TP1">Тип параметра 1 инициализации</typeparam>
            <typeparam name="TP2">Тип параметра 2 инициализации</typeparam>
            <typeparam name="TP3">Тип параметра 3 инициализации</typeparam>
            <param name="obj">Инициализируемый объект</param>
            <param name="parameter1">Параметр 1 инициализации</param>
            <param name="parameter2">Параметр 2 инициализации</param>
            <param name="parameter3">Параметр 3 инициализации</param>
            <param name="Initializer">Функция инициализации, определяющая значение конечного объекта</param>
            <returns>Объект, возвращённый функцией инициализации</returns>
        </member>
        <member name="M:System.ObjectExtensions.InitializeObject``3(``0,``1,``2,System.Func{``0,``1,``2,``0})">
            <summary>Инициализировать объект ссылочного типа</summary>
            <typeparam name="T">Тип объекта</typeparam>
            <typeparam name="TP1">Тип параметра 1 инициализации</typeparam>
            <typeparam name="TP2">Тип параметра 2 инициализации</typeparam>
            <param name="obj">Инициализируемый объект</param>
            <param name="parameter1">Параметр 1 инициализации</param>
            <param name="parameter2">Параметр 2 инициализации</param>
            <param name="Initializer">Функция инициализации, определяющая значение конечного объекта</param>
            <returns>Объект, возвращённый функцией инициализации</returns>
        </member>
        <member name="M:System.ObjectExtensions.ToConsole``1(``0)">
            <summary>Печать объекта на консоли без переноса строки в конце</summary>
            <typeparam name="T">Тип печатаемого объекта</typeparam>
            <param name="Obj">Печатаемый объект</param>
        </member>
        <member name="M:System.ObjectExtensions.ToConsole``1(``0,System.String,System.Object[])">
            <summary>Печать объекта на консоли в указанному формате без переноса строки в конце</summary>
            <typeparam name="TObject">Тип печатаемого объекта</typeparam>
            <param name="Obj">Печатаемый объект</param>
            <param name="Format">Строка форматирования результата</param>
            <param name="args">Дополнительные аргументы строки форматирования</param>
        </member>
        <member name="M:System.ObjectExtensions.ToConsoleLN``1(``0)">
            <summary>Печать объекта на консоли с переносом строки в конце</summary>
            <typeparam name="T">Тип печатаемого объекта</typeparam>
            <param name="Obj">Печатаемый объект</param>
        </member>
        <member name="M:System.ObjectExtensions.ToConsoleLN``1(``0,System.String,System.Object[])">
            <summary>Печать объекта на консоли в указанному формате с переносом строки в конце</summary>
            <typeparam name="TObject">Тип печатаемого объекта</typeparam>
            <param name="Obj">Печатаемый объект</param>
            <param name="Format">Строка форматирования результата</param>
            <param name="args">Дополнительные аргументы строки форматирования</param>
        </member>
        <member name="M:System.ObjectExtensions.ToDubugOut``1(``0)">
            <summary>Печать объекта в отладочной информации без переноса строки в конце</summary>
            <typeparam name="T">Тип печатаемого объекта</typeparam>
            <param name="Obj">Печатаемый объект</param>
        </member>
        <member name="M:System.ObjectExtensions.ToDubugOut``1(``0,System.Boolean)">
            <summary>Печать объекта в отладочной информации без переноса строки в конце</summary>
            <typeparam name="T">Тип печатаемого объекта</typeparam>
            <param name="Obj">Печатаемый объект</param>
            <param name="Condition">Условие (если истина, то объект печатается в отладочный вывод)</param>
        </member>
        <member name="M:System.ObjectExtensions.ToDebugOutLN``1(``0)">
            <summary>Печать объекта в отладочной информации с переносом строки в конце</summary>
            <typeparam name="T">Тип печатаемого объекта</typeparam>
            <param name="Obj">Печатаемый объект</param>
        </member>
        <member name="M:System.ObjectExtensions.ToDebugOutLN``1(``0,System.Boolean)">
            <summary>Печать объекта в отладочной информации с переносом строки в конце</summary>
            <typeparam name="T">Тип печатаемого объекта</typeparam>
            <param name="Obj">Печатаемый объект</param>
            <param name="Condition">Условие (если истина, то объект печатается в отладочный вывод)</param>
        </member>
        <member name="M:System.ObjectExtensions.ToByteArray``1(``0)">
            <summary>Преобразование структуры в массив байт</summary>
            <typeparam name="T">Тип преобразуемой структуры</typeparam>
            <param name="value">Значение преобразуемой структуры</param>
            <returns>Массив байт, представляющий указанную структуру</returns>
        </member>
        <member name="M:System.ObjectExtensions.ToStructure``1(System.Byte[],System.Int32)">
            <summary>Преобразование массива байт в структуру</summary>
            <typeparam name="T">Тип структуры</typeparam>
            <param name="data">Массив байт</param>
            <param name="offset">Смещение в массиве байт</param>
        </member>
        <member name="M:System.ObjectExtensions.Switch(System.Object,System.Actions,System.Action{System.Object})">
            <summary>Выбор действия для объекта</summary>
            <param name="obj">Объект, на котором выполняется выбор действия</param>
            <param name="actions">Словарь возможных действий над объектом</param>
            <param name="Default">Действие по умолчанию</param>
        </member>
        <member name="M:System.ObjectExtensions.ToEvaluation``1(``0)">
            <summary>Преобразование объекта в вычисление</summary>
            <typeparam name="T">Тип исходного элемента</typeparam>
            <param name="obj">Оборачиваемый объект</param>
            <returns>Вычисление, возвращающее указанный объект</returns>
        </member>
        <member name="M:System.ObjectExtensions.ToEvaluation``1(``0,System.String)">
            <summary>Преобразование объекта в именованное вычисление</summary>
            <typeparam name="T">Тип исходного элемента</typeparam>
            <param name="obj">Оборачиваемый объект</param>
            <param name="Name">Имя вычисления</param>
            <returns>Вычисление, возвращающее указанный объект</returns>
        </member>
        <member name="M:System.ObjectExtensions.ToExpression(System.Object)">
            <summary>Преобразование объекта в выражение-константу</summary>
            <param name="obj">Преобразуемый объект</param>
            <returns>Выражение-константа</returns>
        </member>
        <member name="M:System.ObjectExtensions.GetCallExpression(System.Object,System.Delegate,System.Linq.Expressions.Expression[])">
            <summary>Получить выражение вызова метода объекта</summary>
            <param name="obj">Объект, метод которого надо вызвать</param>
            <param name="d">Делегат метода</param>
            <param name="p">Параметры метода</param>
            <returns>Выражение вызова метода</returns>
        </member>
        <member name="M:System.ObjectExtensions.GetCallExpression(System.Object,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
            <summary>Получить выражение вызова метода объекта</summary>
            <param name="obj">Объект, метод которого надо вызвать</param>
            <param name="d">Описание метода</param>
            <param name="p">Параметры метода</param>
            <returns>Выражение вызова метода</returns>
        </member>
        <member name="M:System.ObjectExtensions.GetCallExpression(System.Object,System.String,System.Linq.Expressions.Expression[])">
            <summary>Получить выражение вызова метода объекта</summary>
            <param name="obj">Объект, метод которого надо вызвать</param>
            <param name="MethodName">Имя метода</param>
            <param name="p">Параметры метода</param>
            <returns>Выражение вызова метода</returns>
        </member>
        <member name="T:System.Actions">
            <summary>Словарь действий</summary>
        </member>
        <member name="T:System.Tags.TagExtensions">
            <summary>Класс методов-расширений для реализации функциональности добавления объектов, которые могут быть приложены к другим объектам</summary>
        </member>
        <member name="M:System.Tags.TagExtensions.GetTag``1(System.Object)">
            <summary>Получить объект-метку указанного типа из целевого объекта</summary>
            <typeparam name="TTag">Тип объекта-метки</typeparam>
            <param name="o">Целевой объект</param>
            <returns>Объект метка, если он существует в указанном объекте</returns>
        </member>
        <member name="M:System.Tags.TagExtensions.SetTag``1(System.Object,``0)">
            <summary>Установить объект-метку для указанного объекта</summary>
            <typeparam name="TTag">Тип объекта-метки</typeparam>
            <param name="o">Целевой объект</param>
            <param name="Tag">Объект-метка, прикладываемый к целевому объекту</param>
        </member>
        <member name="T:System.Tags.TagExtensions.TagPool">
            <summary>Пул меток</summary>
        </member>
        <member name="F:System.Tags.TagExtensions.TagPool.__Lock">
            <summary>Объект межпотоковой синхронизации</summary>
        </member>
        <member name="F:System.Tags.TagExtensions.TagPool.__Tags">
            <summary>Словарь меток</summary>
        </member>
        <member name="M:System.Tags.TagExtensions.TagPool.SetTag(System.Object,System.Object)">
            <summary>Установить метку указанному объекту</summary>
            <param name="o">Целевой объект</param>
            <param name="Tag">Добавляемая метка</param>
        </member>
        <member name="M:System.Tags.TagExtensions.TagPool.Tag``1(System.Object)">
            <summary>Получить метку указанного типа для указанного объекта</summary>
            <typeparam name="TTagType">Тип объекта-метки</typeparam>
            <param name="o">Целевой объект</param>
            <returns>Объект-метка</returns>
        </member>
        <member name="T:System.PredicateExtensions">
            <summary>Методы-расширения для функций-предикатов</summary>
        </member>
        <member name="M:System.PredicateExtensions.Invert``1(System.Predicate{``0})">
            <summary>Создать предикат, значение которого отрицает значение исходного предиката</summary>
            <param name="p">Предикат, значение которого необходимо инвертировать</param>
            <typeparam name="T">Тип параметра предиката</typeparam>
            <returns>Предикат, значение которого обратно значению исходного предиката</returns>
        </member>
        <member name="M:System.PredicateExtensions.And``1(System.Predicate{``0},System.Predicate{``0})">
            <summary>Вычисление логического "И" для двух предикатов</summary>
            <typeparam name="T">Тип параметра предиката</typeparam>
            <returns>Предикат, значение которого является результатом вычисления логического "И" для двух исходных предикатов</returns>
        </member>
        <member name="M:System.PredicateExtensions.AndLazy``1(System.Predicate{``0},System.Predicate{``0})">
            <summary>Вычисление логического "ленивого И" для двух предикатов</summary>
            <typeparam name="T">Тип параметра предиката</typeparam>
            <returns>Предикат, значение которого является результатом вычисления логического "ленивого И" для двух исходных предикатов</returns>
        </member>
        <member name="M:System.PredicateExtensions.Or``1(System.Predicate{``0},System.Predicate{``0})">
            <summary>Вычисление логического "ИЛИ" для двух предикатов</summary>
            <typeparam name="T">Тип параметра предиката</typeparam>
            <returns>Предикат, значение которого является результатом вычисления логического "ИЛИ" для двух исходных предикатов</returns>
        </member>
        <member name="M:System.PredicateExtensions.OrLazy``1(System.Predicate{``0},System.Predicate{``0})">
            <summary>Вычисление логического "ленивого ИЛИ" для двух предикатов</summary>
            <typeparam name="T">Тип параметра предиката</typeparam>
            <returns>Предикат, значение которого является результатом вычисления логического "ленивого ИЛИ" для двух исходных предикатов</returns>
        </member>
        <member name="M:System.PredicateExtensions.XOr``1(System.Predicate{``0},System.Predicate{``0})">
            <summary>Вычисление логического "ленивого исключающего ИЛИ" для двух предикатов</summary>
            <typeparam name="T">Тип параметра предиката</typeparam>
            <returns>Предикат, значение которого является результатом вычисления логического "ленивого исключающего ИЛИ" для двух исходных предикатов</returns>
        </member>
        <member name="T:System.RandomExtensions">
            <summary>Методы-расширения для генератора случайных чисел</summary>
        </member>
        <member name="M:System.RandomExtensions.NextUniform(System.Random,System.Int32,System.Double,System.Double)">
            <summary>Массив случайных чисел с равномерным распределением</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Count">Размер массива</param>
            <param name="D">Дисперсия</param>
            <param name="M">Математическое ожидание</param>
            <returns>Массив случайных чисел с равномерным распределением</returns>
        </member>
        <member name="M:System.RandomExtensions.NextUniformEnum(System.Random,System.Int32,System.Double,System.Double)">
            <summary>Перечисление случайных чисел с равномерным распределением</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Count">Размер перечисления (если меньше 0, то бесконечное)</param>
            <param name="D">Дисперсия</param>
            <param name="M">Математическое ожидание</param>
            <returns>Перечисление случайных чисел с равномерным распределением</returns>
        </member>
        <member name="M:System.RandomExtensions.NextUniform(System.Random,System.Int32,MathCore.Interval)">
            <summary>Массив случайных чисел с равномерным распределением</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Count">Размер массива</param>
            <param name="Interval">Интервал</param>
            <returns>Массив случайных чисел с равномерным распределением</returns>
        </member>
        <member name="M:System.RandomExtensions.NextUniformEnum(System.Random,System.Int32,MathCore.Interval)">
            <summary>Перечисление случайных чисел с равномерным распределением</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Count">Размер перечисления (если меньше 0, то бесконечное)</param>
            <param name="Interval">Интервал</param>
            <returns>Перечисление случайных чисел с равномерным распределением</returns>
        </member>
        <member name="M:System.RandomExtensions.NextUniform(System.Random,MathCore.Interval[])">
            <summary>Массив случайных чисел с равномерным распределением</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Intervals">Интервал</param>
            <returns>Массив случайных чисел с равномерным распределением</returns>
        </member>
        <member name="M:System.RandomExtensions.NextUniformInterval(System.Random,System.Int32,System.Double,System.Double)">
            <summary>Массив случайных чисел с равномерным распределением</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Count">Размер массива</param>
            <param name="Min">Минимум</param>
            <param name="Max">Максимум</param>
            <returns>Массив случайных чисел с равномерным распределением</returns>
        </member>
        <member name="M:System.RandomExtensions.NextUniformIntervalEnum(System.Random,System.Int32,System.Double,System.Double)">
            <summary>Перечисление случайных чисел с равномерным распределением</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Count">Размер перечисления (если меньше 0, то бесконечное)</param>
            <param name="Min">Минимум</param>
            <param name="Max">Максимум</param>
            <returns>Перечисление случайных чисел с равномерным распределением</returns>
        </member>
        <member name="M:System.RandomExtensions.NextValues(System.Random,System.Int32)">
            <summary>Массив целых неотрицательных случайных чисел</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Count">Размер массива</param>
            <returns>Массив целых неотрицательных случайных чисел</returns>
        </member>
        <member name="M:System.RandomExtensions.NextValuesEnum(System.Random,System.Int32)">
            <summary>Перечисление целых неотрицательных случайных чисел</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Count">Размер перечисления (если меньше 0, то бесконечное)</param>
            <returns>перечисление целых неотрицательных случайных чисел</returns>
        </member>
        <member name="M:System.RandomExtensions.NextValues(System.Random,System.Int32,System.Int32)">
            <summary>Массив целых неотрицательных случайных чисел ограниченный сверху (верхний предел не входит)</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Count">Размер массива</param>
            <param name="Max">Максимум (не входит)</param>
            <returns>Массив целых неотрицательных случайных чисел (верхний предел не входит)</returns>
        </member>
        <member name="M:System.RandomExtensions.NextValuesEnum(System.Random,System.Int32,System.Int32)">
            <summary>Перечисление целых неотрицательных случайных чисел ограниченный сверху (верхний предел не входит)</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Count">Размер перечисления (если меньше 0, то бесконечное)</param>
            <param name="Max">Максимум (не входит)</param>
            <returns>Перечисление целых неотрицательных случайных чисел (верхний предел не входит)</returns>
        </member>
        <member name="M:System.RandomExtensions.NextValues(System.Random,System.Int32,System.Int32,System.Int32)">
            <summary>Массив целых неотрицательных случайных чисел в заданном интервале (верхний предел не входит)</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Count">Размер массива</param>
            <param name="Min">Минимум</param>
            <param name="Max">Максимум (не входит)</param>
            <returns>Массив целых неотрицательных случайных чисел в заданном интервале (верхний предел не входит)</returns>
        </member>
        <member name="M:System.RandomExtensions.NextValuesEnum(System.Random,System.Int32,System.Int32,System.Int32)">
            <summary>Перечисление целых неотрицательных случайных чисел в заданном интервале (верхний предел не входит)</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Count">Размер перечисления (если меньше 0, то бесконечное)</param>
            <param name="Min">Минимум</param>
            <param name="Max">Максимум (не входит)</param>
            <returns>Перечисление целых неотрицательных случайных чисел в заданном интервале (верхний предел не входит)</returns>
        </member>
        <member name="M:System.RandomExtensions.NextNormal(System.Random,System.Int32,System.Double,System.Double)">
            <summary>Массив случайных чисел с нормальным распределением</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Count">Размер массива</param>
            <param name="D">Дисперсия</param>
            <param name="M">Математическое ожидание</param>
            <returns>Массив случайных чисел с нормальным распределением</returns>
        </member>
        <member name="M:System.RandomExtensions.NextNormalEnum(System.Random,System.Int32,System.Double,System.Double)">
            <summary>Перечисление случайных чисел с нормальным распределением</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Count">Размер массива</param>
            <param name="D">Дисперсия</param>
            <param name="M">Математическое ожидание</param>
            <returns>Перечисление случайных чисел с нормальным распределением</returns>
        </member>
        <member name="M:System.RandomExtensions.NextNormal(System.Random,System.Double,System.Double)">
            <summary>Случайное число с нормальным распределением</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="sigma">Среднеквадратичное отклонение</param>
            <param name="mu">Математическое ожидание</param>
            <returns>Случайное число с нормальным распределением</returns>
        </member>
        <member name="M:System.RandomExtensions.NextUniform(System.Random,System.Double,System.Double)">
            <summary>Случайное число с равномерным распределением</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="D">Дисперсия</param>
            <param name="M">Математическое ожидание</param>
            <returns>Случайное число в равномерным распределением</returns>
        </member>
        <member name="M:System.RandomExtensions.NextTriangular(System.Random,System.Double,System.Double,System.Double)">
            <summary>Случайное число с треугольным распределением</summary>
            <remarks>http://en.wikipedia.org/wiki/Triangular_distribution</remarks>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="min">Минимум</param>
            <param name="max">Максимум</param>
            <param name="mode">Медиана</param>
            <returns>Случайное число с треугольным распределением</returns>
        </member>
        <member name="M:System.RandomExtensions.FillUniform(System.Random,System.Double[])">
            <summary>Заполнить массив случайными числами с равномерным распределением в интервале [0, 1)</summary>
            <param name="rnd">Генератор случайных чисел</param>
            <param name="Array">Заполняемый массив</param>
        </member>
        <member name="M:System.RandomExtensions.FillUniform(System.Random,System.Double[],System.Double)">
            <summary>Заполнить массив случайными числами с равномерным распределением в интервале [-D/2, D/2)</summary>
            <param name="rnd">Генератор случайных чисел</param>
            <param name="Array">Заполняемый массив</param>
            <param name="D">Дисперсия значений</param>
        </member>
        <member name="M:System.RandomExtensions.FillUniform(System.Random,System.Double[],System.Double,System.Double)">
            <summary>Заполнить массив случайными числами с равномерным распределением в интервале [-D/2 + M, D/2 + M)</summary>
            <param name="rnd">Генератор случайных чисел</param>
            <param name="Array">Заполняемый массив</param>
            <param name="D">Дисперсия значений</param>
            <param name="M">Математическое ожидание</param>
        </member>
        <member name="M:System.RandomExtensions.NextBoolean(System.Random)">
            <summary>Случайное значение <see langword="true"/>/<see langword="false"/></summary>
            <param name="rnd">Генератор случайных чисел</param>
        </member>
        <member name="M:System.RandomExtensions.NextDouble(System.Random,System.Double)">
            <summary>Случайное число с равномерным распределением в интервале [-D/2, D/2)</summary>
            <param name="rnd">Генератор случайных чисел</param>
            <param name="D">Дисперсия значений</param>
            <returns>Случайное число в интервале  [-D/2, D/2)</returns>
        </member>
        <member name="M:System.RandomExtensions.NextDouble(System.Random,System.Double,System.Double)">
            <summary>Случайное число с равномерным распределением в интервале [-D/2 + M, D/2 + M)</summary>
            <param name="rnd">Генератор случайных чисел</param>
            <param name="D">Дисперсия значений</param>
            <param name="M">Математическое ожидание</param>
            <returns>Случайное число в интервале  [-D/2 + M, D/2 + M)</returns>
        </member>
        <member name="M:System.RandomExtensions.Mix(System.Random,System.Collections.IList)">
            <summary>Shuffles a list in O(n) time by using the Fisher-Yates/Knuth algorithm</summary>
            <param name="rnd"></param>
            <param name = "list"></param>
        </member>
        <member name="M:System.RandomExtensions.Permutation(System.Random,System.Int32,System.Int32)">
            <summary>
            Returns n unique random numbers in the range [1, n], inclusive. 
            This is equivalent to getting the first n numbers of some random permutation of the sequential numbers from 1 to max. 
            Runs in O(k^2) time.
            </summary>
            <param name="rnd"></param>
            <param name="n">Maximum number possible.</param>
            <param name="k">How many numbers to return.</param>
            <returns></returns>
        </member>
        <member name="M:System.RandomExtensions.Next``1(System.Random,System.Int32,``0[])">
            <summary>Случайных элемент из перечисленных вариантов</summary>
            <typeparam name="T">Тип вариантов выбора</typeparam>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="count">Количество результатов выбора</param>
            <param name="variants">Перечисление вариантов выбора</param>
            <returns>Последовательность случайных вариантов</returns>
        </member>
        <member name="M:System.RandomExtensions.SequenceInt(System.Random,System.Int32,System.Int32,System.Int32)">
            <summary>Последовательность случайных целых чисел в указанном интервале</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="min">Нижняя граница интервала (входит)</param>
            <param name="max">Верхняя граница интервала (не входит)</param>
            <param name="count">Размер выборки (если меньше 0), то бесконечная последовательность</param>
            <returns>Последовательность случайных целых чисел в указанном интервале</returns>
        </member>
        <member name="M:System.RandomExtensions.SequenceDouble(System.Random,System.Int32)">
            <summary>Последовательность случайных вещественных чисел с равномерным распределением в интервале (0,1)</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="count">Размер выборки (если меньше 0), то бесконечная последовательность</param>
            <returns>Последовательность случайных вещественных чисел в интервале (0,1)</returns>
        </member>
        <member name="M:System.RandomExtensions.SequenceNormal(System.Random,System.Double,System.Double,System.Int32)">
            <summary>Последовательность случайных вещественных чисел с нормальным распределением</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="M">Математическое ожидание</param>
            <param name="D">Дисперсия</param>
            <param name="count">Размер выборки (если меньше 0), то бесконечная последовательность</param>
            <returns>Последовательность случайных вещественных чисел</returns>
        </member>
        <member name="T:System.StringExtensions">
            <summary>Методы-расширения класса <see cref="T:System.String">строк</see></summary>
        </member>
        <member name="M:System.StringExtensions.Compress(System.String)">
            <summary>Сжать строку в последовательность байт</summary>
            <param name="str">Сжимаемая строка</param>
            <returns>Сжатая строка в виде последовательности байт</returns>
        </member>
        <member name="M:System.StringExtensions.DecompressAsString(System.Byte[])">
            <summary>Разархивировать последовательность байт в строку</summary>
            <param name="bytes">Сжатая последовательность бай, содержащая строку</param>
            <returns>Распакованная последовательность байт в строковом представлении</returns>
        </member>
        <member name="M:System.StringExtensions.FindBlock(System.String,System.String)">
            <summary>Перечисление подстрок, разделяемых указанным строковым шаблоном</summary>
            <param name="Str">Разбиваемая строка</param>
            <param name="EndPattern">Строковый шаблон разбиения</param>
            <returns>Перечисление подстрок</returns>
        </member>
        <member name="M:System.StringExtensions.GetBracketText(System.String,System.Int32@,System.String,System.String)">
            <summary>Выделение подстроки, ограниченной шаблоном начала и шаблоном окончания строки начиная с указанного смещения</summary>
            <param name="Str">Входная строка</param>
            <param name="Offset">Смещение во входной строке начала поиска - в конце работы метода соответствует месту окончания поиска</param>
            <param name="Open">Шаблон начала подстроки</param>
            <param name="Close">Шаблон окончания подстроки</param>
            <returns>Подстрока, заключённая между указанными шаблонами начала и окончания</returns>
            <exception cref="T:System.FormatException">
            Если шаблон завершения строки на найден, либо если количество шаблонов начала строки превышает 
            количество шаблонов окончания во входной строке
            </exception>
        </member>
        <member name="M:System.StringExtensions.IsNullOrEmpty(System.String)">
            <summary>Проверка строки на пустоту, либо нулевую ссылку</summary>
            <param name="Str">Проверяемая строка</param>
            <returns>Истина, если строка пуста, либо если передана нулевая ссылка</returns>
        </member>
        <member name="M:System.StringExtensions.IsNotNullOrEmpty(System.String)">
            <summary>Строка присутствует и не пуста</summary>
            <param name="Str">Проверяемая строка</param>
            <returns>Истина, если строка не  пуста, и если передана ненулевая ссылка</returns>
        </member>
        <member name="M:System.StringExtensions.ClearSymbolsAtBegin(System.String,System.Char[])">
            <summary>Удаление символов в начале строки</summary>
            <param name="str">Обрабатываемая строка</param>
            <param name="symbols">Перечень удаляемых символов</param>
            <returns>Новая строка с удалёнными символами в начале</returns>
        </member>
        <member name="M:System.StringExtensions.ClearSymbolsAtEnd(System.String,System.Char[])">
            <summary>Удаление символов в конце строки</summary>
            <param name="str">Обрабатываемая строка</param>
            <param name="symbols">Перечень удаляемых символов</param>
            <returns>Новая строка с удалёнными символами в конце</returns>
        </member>
        <member name="M:System.StringExtensions.ClearSymbolsAtBeginAndEnd(System.String,System.Char[])">
            <summary>Удаление символов в начале и конце строки</summary>
            <param name="str">Обрабатываемая строка</param>
            <param name="symbols">Перечень удаляемых символов</param>
            <returns>Новая строка с удалёнными символами в начале и конце</returns>
        </member>
        <member name="M:System.StringExtensions.ClearSystemSymbolsAtBeginAndEnd(System.String)">
            <summary>Удаление служебных символов в начале и конце строки</summary>
            <param name="str">Обрабатываемая строка</param>
            <returns>Новая строка с удалёнными служебными символами в начали и конце</returns>
        </member>
        <member name="M:System.StringExtensions.NotEmpty(System.String,System.String,System.String)">
            <summary>Проверка на пустоту строки</summary>
            <param name="str">Проверяемая строка</param>
            <param name="ParameterName">Имя параметра, добавляемое в исключение в случае его генерации</param>
            <param name="Message">Сообщение, добавляемое в исключение в случае его генерации</param>
            <exception cref="T:System.ArgumentNullException">Если переданная пустая ссылка на строку <paramref name="str"/></exception>
            <exception cref="T:System.ArgumentException">Если переданная строка <paramref name="str"/> является пустой</exception>
            <returns>Строка, гарантированно не являющаяся пустой</returns>
        </member>
        <member name="T:System.StringExtensionsTrim">
            <summary>Ограничение длины строки с удалением центральной её части</summary>
        </member>
        <member name="M:System.StringExtensionsTrim.TrimByLength(System.String,System.Int32,System.String)">
            <summary>Ограничение длины строки с удалением центральной её части</summary>
            <param name="Str">Обрезаемая строка</param>
            <param name="Length">Требуемая длина</param>
            <param name="ReplacementPattern">Шаблон замены</param>
            <returns>Строка с удалённой внутренней частью</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.RegExExtensions.OrDefault(System.Text.RegularExpressions.Match,System.String)">
            <summary>Метод получения значения из результатов совпадения поиска</summary>
            <param name="match">Результат совпадения поиска</param>
            <param name="DefaultString">Значение по умолчанию</param>
            <returns>Результат поиска, либо значение по умолчанию</returns>
        </member>
        <member name="M:System.TypeExtensions.GetTypeConverter(System.Type)">
            <summary>Получить конвертер значений для указанного типа данных</summary>
            <param name="type">Тип, для которого требуется получить конвертер</param>
            <returns>Конвертер указанного типа данных</returns>
        </member>
        <member name="M:System.TypeExtensions.GetType(System.String)">
            <summary>Получить тип по его имени из всех загруженных сборок</summary>
            <param name="TypeName">Имя типа</param>
            <returns>Тип</returns>
        </member>
        <member name="M:System.TypeExtensions.GetCustomAttributes``1(System.Type)">
            <summary>Получить все атрибуты типа указанного типа</summary>
            <typeparam name="TAttribute">Тип требуемых атрибутов</typeparam>
            <param name="T">Тип, атрибуты которого требуется получить</param>
            <returns>Массив атрибутов типа указанного типа</returns>
        </member>
        <member name="T:System.IInitializable">
            <summary>Объект, поддерживающий инициализацию</summary>
        </member>
        <member name="M:System.IInitializable.Initialize">
            <summary>Инициализация</summary>
        </member>
        <member name="T:System.IInitializable`1">
            <summary>Объект, поддерживающий инициализацию с параметром</summary>
            <typeparam name="T">Тип параметра инициализации</typeparam>
        </member>
        <member name="M:System.IInitializable`1.Initialize(`0)">
            <summary>Инициализация</summary>
            <param name="t">Параметр</param>
        </member>
        <member name="T:System.IInitializable`2">
            <summary>Объект, поддерживающий инициализацию с двумя параметрами</summary>
            <typeparam name="T1">Тип первого параметра</typeparam>
            <typeparam name="T2">Тип второго параметра</typeparam>
        </member>
        <member name="M:System.IInitializable`2.Initialize(`0,`1)">
            <summary>Инициализация</summary>
            <param name="t1">Первый параметр</param>
            <param name="t2">Второй параметр</param>
        </member>
        <member name="T:System.IInitializable`3">
            <summary>Объект, поддерживающий инициализацию с тремя параметрами</summary>
            <typeparam name="T1">Тип первого параметра</typeparam>
            <typeparam name="T2">Тип второго параметра</typeparam>
            <typeparam name="T3">Тип третьего параметра</typeparam>
        </member>
        <member name="M:System.IInitializable`3.Initialize(`0,`1,`2)">
            <summary>Инициализация</summary>
            <param name="t1">Первый параметр</param>
            <param name="t2">Второй параметр</param>
            <param name="t3">Третий параметр</param>
        </member>
        <member name="T:System.IInitializable`4">
            <summary>Объект, поддерживающий инициализацию с четырьмя параметрами</summary>
            <typeparam name="T1">Тип первого параметра</typeparam>
            <typeparam name="T2">Тип второго параметра</typeparam>
            <typeparam name="T3">Тип третьего параметра</typeparam>
            <typeparam name="T4">Тип четвёртого параметра</typeparam>
        </member>
        <member name="M:System.IInitializable`4.Initialize(`0,`1,`2,`3)">
            <summary>Инициализация</summary>
            <param name="t1">Первый параметр</param>
            <param name="t2">Второй параметр</param>
            <param name="t3">Третий параметр</param>
            <param name="t4">Четвёртый параметр</param>
        </member>
        <member name="T:System.IInitializable`5">
            <summary>Объект, поддерживающий инициализацию с пятью параметрами</summary>
            <typeparam name="T1">Тип первого параметра</typeparam>
            <typeparam name="T2">Тип второго параметра</typeparam>
            <typeparam name="T3">Тип третьего параметра</typeparam>
            <typeparam name="T4">Тип четвёртого параметра</typeparam>
            <typeparam name="T5">Тип пятого параметра</typeparam>
        </member>
        <member name="M:System.IInitializable`5.Initialize(`0,`1,`2,`3,`4)">
            <summary>Инициализация</summary>
            <param name="t1">Первый параметр</param>
            <param name="t2">Второй параметр</param>
            <param name="t3">Третий параметр</param>
            <param name="t4">Четвёртый параметр</param>
            <param name="t5">Пятый параметр</param>
        </member>
        <member name="T:System.LambdaDisposable">
            <summary>Объект, выполняющий указанное действие при сборке мусора</summary>
        </member>
        <member name="M:System.LambdaDisposable.OnDisposed(System.Action)">
            <summary>При освобождении выполнить указанное действие</summary>
            <param name="OnDispose">Действие, выполняемое при освобождении</param>
            <returns>Объект <see cref="T:System.LambdaDisposable"/></returns>
        </member>
        <member name="F:System.LambdaDisposable._DisposableAction">
            <summary>Действие, выполняемое при разрушении объекта</summary>
        </member>
        <member name="M:System.LambdaDisposable.#ctor(System.Action)">
            <summary>Инициализация нового уничтожаемого объекта с указанием действия при уничтожении</summary>
            <param name="DisposableAction">Действие, выполняемое при уничтожении объекта</param>
        </member>
        <member name="M:System.LambdaDisposable.Dispose">
            <summary>Метод уничтожения объекта, вызывающий указанное действие</summary>
        </member>
        <member name="M:System.LambdaDisposable.Dispose(System.Boolean)">
            <summary>Метод уничтожения объекта, вызывающий указанное действие</summary>
            <param name="Disposing">Если истина, то освободить управляемые ресурсы</param>
        </member>
        <member name="M:System.LambdaDisposableObject`1.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:System.LambdaProcessor.MainAction">
            <summary>Основной метод действия процессора, вызываемое в цикле. Должно быть переопределено в классах-наследниках</summary>
        </member>
        <member name="T:System.Processor">
            <summary>Класс объектов, выполняющих некоторое циклическое действие в отдельном фоновом потоке</summary>
        </member>
        <member name="F:System.Processor.__AsyncException">
            <summary>Объект-исключение, передаваемое в качестве параметра события ошибки при рассинхронизации потока процессора</summary>
        </member>
        <member name="P:System.Processor.Now">
            <summary>Текущее время системы</summary>
        </member>
        <member name="E:System.Processor.System#ComponentModel#INotifyPropertyChanged#PropertyChanged">
            <summary>Событие изменения свойства объекта</summary>
        </member>
        <member name="M:System.Processor.OnPropertyChanged(System.ComponentModel.PropertyChangedEventArgs)">
            <summary>Вызов события изменения свойства объекта</summary>
             <param name="e">Параметры события изменения свойства объекта, содержащие имя свойства</param>
        </member>
        <member name="M:System.Processor.OnPropertyChanged(System.String)">
            <summary>Вызов события изменения свойства объекта с указанием имени свойства</summary>
            <param name="PropertyName">Имя изменившегося свойства</param>
        </member>
        <member name="E:System.Processor.EnableChanged">
            <summary>Событие изменения свойства активности процессора</summary>
        </member>
        <member name="M:System.Processor.OnEnableChanged(System.EventArgs)">
            <summary>Источник события изменения свойства активности процессора</summary><param name="e">Параметры события</param>
        </member>
        <member name="E:System.Processor.ProcessStarted">
            <summary>Событие запуска процессора</summary>
        </member>
        <member name="M:System.Processor.OnProcessStarted(System.EventArgs)">
            <summary>Источник события запуска процессора</summary><param name="e">Параметры события</param>
        </member>
        <member name="E:System.Processor.ProcessCompleted">
            <summary>Событие завершения работы процессора</summary>
        </member>
        <member name="M:System.Processor.OnProcessCompleted(System.EventArgs)">
            <summary>Источник события завершения работы процессора</summary><param name="e">Параметры события</param>
        </member>
        <member name="E:System.Processor.Error">
            <summary>Событие, возникающие при возникновении исключений в процессе работы процессора</summary>
        </member>
        <member name="M:System.Processor.OnError(System.ExceptionEventHandlerArgs{System.Exception})">
            <summary>Источник события возникновения исключительной ситуации в процессе работы процессора</summary>
            <param name="e">Аргумент события ошибки, содержащий объект исключения</param>
        </member>
        <member name="F:System.Processor._JoinThreadTimeout">
            <summary>
            Таймаут времени ожидания синхронизации потока обработки при его завершении, 
            после которого поток прерывается методом Abort()
            По умолчанию 100 мс.
            </summary>
        </member>
        <member name="F:System.Processor._Enabled">
            <summary>Флаг активности потока обработки. Пока значение флага "истина" - поток выполняется</summary>
        </member>
        <member name="F:System.Processor._StartStopSectionLocker">
            <summary>Объект синхронизации запуска/остановки процессора - только для чтения</summary>
        </member>
        <member name="F:System.Processor._MainWorkThread">
            <summary>Основной поток работы процессора</summary>
        </member>
        <member name="F:System.Processor._StartTime">
            <summary>Время запуска</summary>
        </member>
        <member name="F:System.Processor._StopTime">
            <summary>Время остановки</summary>
        </member>
        <member name="F:System.Processor._Monitor">
            <summary>Объект-наблюдатель за состоянием процессора</summary>
        </member>
        <member name="F:System.Processor._Priority">
            <summary>Базовый приоритет потока процессора</summary>
        </member>
        <member name="F:System.Processor._ActionTimeout">
            <summary>Таймаут выполнения между циклами процессора </summary>
        </member>
        <member name="F:System.Processor._SetTimeout">
            <summary>Метод установки времени таймаута для работающего потока процессора</summary>
        </member>
        <member name="F:System.Processor._IsSynchronous">
            <summary>Признак синхронной работы</summary>
        </member>
        <member name="F:System.Processor._ErrorIfAsync">
            <summary>Флаг, разрешающий вызов события ошибки в случае рассинхронизации потока</summary>
        </member>
        <member name="F:System.Processor._CyclesCount">
            <summary>Количество выполненных циклов обработки</summary>
        </member>
        <member name="F:System.Processor._NameForeNewMainThread">
            <summary>Имя для генерируемой потока выполнения процессора</summary>
        </member>
        <member name="F:System.Processor._GetLastDeltaTime">
            <summary>Метод извлечения времени выполнения одного цикла основного метода процессора</summary>
        </member>
        <member name="F:System.Processor._StartWaitHandle">
            <summary>Объект синхронизации потоков по запуску процессора</summary>
        </member>
        <member name="F:System.Processor._StopWaitHandle">
            <summary>Объект синхронизации потоков по остановке процессора</summary>
        </member>
        <member name="P:System.Processor.Priority">
            <summary>Приоритет выполнения метода наблюдения</summary>
        </member>
        <member name="P:System.Processor.Enable">
            <summary>Признак активности процессора</summary>
        </member>
        <member name="P:System.Processor.MainThread">
            <summary>Основной поток работы процессора</summary>
        </member>
        <member name="P:System.Processor.JoinThreadTimeout">
            <summary>Таймаут времени синхронизации основного потока процессора с потоком, завершившим его работу.</summary>
        </member>
        <member name="P:System.Processor.StartTime">
            <summary>Время запуска</summary>
        </member>
        <member name="P:System.Processor.StopTime">
            <summary>Время остановки</summary>
        </member>
        <member name="P:System.Processor.ElapsedTime">
            <summary>Время, прошедшее после запуска</summary>
        </member>
        <member name="P:System.Processor.Monitor">
            <summary>Объект-наблюдатель за состоянием процессора</summary>
        </member>
        <member name="P:System.Processor.ActionTimeout">
            <summary>Таймаут основной циклической операции в миллисекундах</summary>
        </member>
        <member name="P:System.Processor.IsSynchronous">
            <summary>Признак синхронной работы</summary>
        </member>
        <member name="P:System.Processor.ErrorIfAsync">
            <summary>Генерировать ошибку в случае рассинхронизации?</summary>
        </member>
        <member name="P:System.Processor.CyclesCount">
            <summary>Количество пройденных циклов</summary>
        </member>
        <member name="M:System.Processor.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.Processor"/></summary>
        </member>
        <member name="M:System.Processor.Restart">
            <summary>Перезапуск</summary>
        </member>
        <member name="M:System.Processor.Start">
            <summary>Запуск обработки</summary>
        </member>
        <member name="M:System.Processor.Stop">
            <summary>Остановка обработки</summary>
        </member>
        <member name="M:System.Processor.WaitToStart(System.Nullable{System.TimeSpan})">
            <summary>Блокировать поток до запуска процессора</summary>
        </member>
        <member name="M:System.Processor.WaitToStop(System.Nullable{System.TimeSpan})">
            <summary>Блокировать поток до остановки процессора</summary>
        </member>
        <member name="M:System.Processor.ThreadMethod">
            <summary>Основной метод процессора, выполняемый в отдельном потоке </summary>
        </member>
        <member name="M:System.Processor.MainAction">
            <summary>Основной метод действия процессора, вызываемое в цикле. Должно быть переопределено в классах-наследниках</summary>
        </member>
        <member name="M:System.Processor.InitializeAction">
            <summary>Инициализация процесса</summary>
        </member>
        <member name="M:System.Processor.Initializer">
            <summary>
            Метод инициализации. Вызывается после запуска обработки перед началом основного цикла.
            По умолчанию вызывает генерацию события запуска процессора
            </summary>
        </member>
        <member name="M:System.Processor.Finalizer">
            <summary>
            Метод, завершающий процесс обработки. Вызывается после выхода процессора из основного цикла.
            По умолчанию вызывает генерацию события завершения работы процессора
            </summary>
        </member>
        <member name="M:System.Processor.FinalizeAction">
            <summary>Завершающее действие процесса</summary>
        </member>
        <member name="M:System.Processor.Dispose">
            <inheritdoc />
        </member>
        <member name="M:System.Processor.Dispose(System.Boolean)">
            <summary>Освобождение ресурсов</summary>
            <param name="disposing">Признак того, что требуется выполнить освобождение управляемых ресурсов</param>
        </member>
        <member name="T:System.Reflection.Constructor`1">
            <summary>Управление конструктором класса</summary>
            <typeparam name="T">Тип объектов, порождаемых конструктором</typeparam>
        </member>
        <member name="F:System.Reflection.Constructor`1._Info">
            <summary>Информация о конструкторе</summary>
        </member>
        <member name="F:System.Reflection.Constructor`1._ObjectType">
            <summary>Тип объекта, конструктор которого требуется контролировать</summary>
        </member>
        <member name="F:System.Reflection.Constructor`1._Private">
            <summary>Искать приватный конструктор?</summary>
        </member>
        <member name="F:System.Reflection.Constructor`1._ArgumentTypes">
            <summary>Массив типов параметров конструктора</summary>
        </member>
        <member name="P:System.Reflection.Constructor`1.IsExist">
            <summary>Конструктор найден</summary>
        </member>
        <member name="P:System.Reflection.Constructor`1.ObjectType">
            <summary>Тип объекта, конструктор которого требуется контролировать</summary>
        </member>
        <member name="P:System.Reflection.Constructor`1.Private">
            <summary>Искать приватный конструктор?</summary>
        </member>
        <member name="P:System.Reflection.Constructor`1.ArgumentTypes">
            <summary>Массив типов параметров конструктора</summary>
        </member>
        <member name="M:System.Reflection.Constructor`1.#ctor(`0,System.Boolean,System.Type[])">
            <summary>Инициализация нового экземпляра <see cref="T:System.Reflection.Constructor`1"/></summary>
            <param name="o">Объект, Конструктор которого используется</param>
            <param name="Private">Искать приватный конструктор?</param>
            <param name="ArgumentTypes">Массив типов параметров конструктора</param>
        </member>
        <member name="M:System.Reflection.Constructor`1.#ctor(System.Type,System.Boolean,System.Type[])">
            <summary>Инициализация нового экземпляра <see cref="T:System.Reflection.Constructor`1"/></summary>
            <param name="type">Тип, из которого извлекается конструктор</param>
            <param name="Private">Искать приватный конструктор?</param>
            <param name="ArgumentTypes">Массив типов параметров конструктора</param>
        </member>
        <member name="M:System.Reflection.Constructor`1.Initialize(System.Type,System.Type[],System.Boolean)">
            <summary>Инициализация контроля конструктора</summary>
            <param name="Type">Тип из которого извлекается конструктор</param>
            <param name="Types">Массив типов аргументов конструктора</param>
            <param name="IsPrivate">Искать приватный конструктор?</param>
        </member>
        <member name="M:System.Reflection.Constructor`1.Create">
            <inheritdoc />
        </member>
        <member name="M:System.Reflection.Constructor`1.Create(System.Object[])">
            <inheritdoc />
        </member>
        <member name="T:System.Reflection.ConstructorExtensions">
            <summary>Класс методов-расширений для взаимодействия с конструкторами классов по средствам рефлексии</summary>
        </member>
        <member name="M:System.Reflection.ConstructorExtensions.GetObjectConstructor``1(``0,System.Boolean,System.Type[])">
            <summary>Получить конструктор для объекта</summary>
            <param name="o">Объект, конструктор класса которого требуется получить</param>
            <param name="Private">Искать приватный конструктор?</param>
            <param name="ArgumentTypes">Перечисление типов параметров искомого конструктора</param>
            <typeparam name="TObject">Тип объекта, для которого извлекается конструктор</typeparam>
            <returns>Объект, управляющий конструктором класса объекта</returns>
        </member>
        <member name="M:System.Reflection.ConstructorExtensions.GetTypeConstructor``1(System.Type,System.Boolean,System.Type[])">
            <summary>Получить конструктор для объекта</summary>
            <param name="type">Тип, из которого требуется извлечь конструктор</param>
            <param name="Private">Искать приватный конструктор?</param>
            <param name="ArgumentTypes">Перечисление типов параметров искомого конструктора</param>
            <typeparam name="TObject">Тип объекта, для которого извлекается конструктор</typeparam>
            <returns>Объект, управляющий конструктором класса объекта</returns>
        </member>
        <member name="T:System.Reflection.Event`2">
            <summary>Событие</summary>
            <typeparam name="TObject">Тип объекта-источника события</typeparam>
            <typeparam name="TEventArgs">Тип аргумента события</typeparam>
        </member>
        <member name="E:System.Reflection.Event`2.EventHandler">
            <summary>Событие</summary>
        </member>
        <member name="F:System.Reflection.Event`2._EventInfo">
            <summary>Описание события</summary>
        </member>
        <member name="F:System.Reflection.Event`2._Object">
            <summary>Объект-источник</summary>
        </member>
        <member name="M:System.Reflection.Event`2.#ctor(`0,System.String,System.Boolean)">
            <summary>Событие</summary>
            <param name="o">Объект-источник события</param>
            <param name="Name">Название события</param>
            <param name="Private">Приватность описания события в классе объекта</param>
        </member>
        <member name="T:System.Reflection.Field`2">
            <summary>Объект управления полем</summary>
            <typeparam name="TObject">Тип объекта, в котором определено управляемое полек</typeparam>
            <typeparam name="TValue">Тип поля</typeparam>
        </member>
        <member name="F:System.Reflection.Field`2._FieldInfo">
            <summary>Информация о поле</summary>
        </member>
        <member name="F:System.Reflection.Field`2._Name">
            <summary>Имя поля</summary>
        </member>
        <member name="F:System.Reflection.Field`2._Object">
            <summary>Объект, в котором определено поле</summary>
        </member>
        <member name="F:System.Reflection.Field`2._Private">
            <summary>Поле является приватным?</summary>
        </member>
        <member name="P:System.Reflection.Field`2.IsExist">
            <summary>Поле найдено и может быть управляемо</summary>
        </member>
        <member name="P:System.Reflection.Field`2.Name">
            <summary>Имя поля</summary>
        </member>
        <member name="P:System.Reflection.Field`2.Object">
            <summary>Объект, в котором определено поле</summary>
        </member>
        <member name="P:System.Reflection.Field`2.Private">
            <summary>Поле является приватным?</summary>
        </member>
        <member name="P:System.Reflection.Field`2.Value">
            <summary>Значение поля</summary>
        </member>
        <member name="M:System.Reflection.Field`2.#ctor(`0,System.String,System.Boolean)">
            <summary>Инициализация нового экземпляра <see cref="T:System.Reflection.Field`2"/></summary>
            <param name="o">Объект, в котором определено поле</param>
            <param name="Name">Имя поля</param>
            <param name="Private">Поле является приватным?</param>
        </member>
        <member name="M:System.Reflection.Field`2.Initialize(`0,System.String,System.Boolean)">
            <summary> Инициализация состояния <see cref="T:System.Reflection.Field`2"/></summary>
            <param name="o">Объект, в котором определено поле</param>
            <param name="FieldName">Имя поля</param>
            <param name="IsPrivate">Поле является приватным?</param>
        </member>
        <member name="T:System.Reflection.FieldExtensions">
            <summary>Класс методов-расширений для полей класса</summary>
        </member>
        <member name="M:System.Reflection.FieldExtensions.GetField``2(``0,System.String,System.Boolean)">
            <summary>Получить объект контроля поля объекта</summary>
            <typeparam name="TObject">Тип объекта, поле которого требуется контролировать</typeparam>
            <typeparam name="TValue">Тип значения поля</typeparam>
            <param name="o">Объект, поле которого требуется контролировать</param>
            <param name="Name">Имя контролируемого поля</param>
            <param name="Private">Искать приватное поле?</param>
            <returns>Объект, осуществляющий контроль поля</returns>
        </member>
        <member name="T:System.Reflection.Method`2">
            <summary>Объект, осуществляющий контроль метода объекта <typeparamref name="TObject"/></summary>
            <typeparam name="TObject">Тип объекта, метод которого требуется контролировать</typeparam>
            <typeparam name="TResult">Тип значения метода</typeparam>
        </member>
        <member name="F:System.Reflection.Method`2._MethodInfo">
            <summary>Информация о контролируемом методе</summary>
        </member>
        <member name="F:System.Reflection.Method`2._Name">
            <summary>Имя метод</summary>
        </member>
        <member name="F:System.Reflection.Method`2._Object">
            <summary>Объект, метод которого контролируется</summary>
        </member>
        <member name="F:System.Reflection.Method`2._Private">
            <summary>Метод не является публичным?</summary>
        </member>
        <member name="F:System.Reflection.Method`2._Method">
            <summary>Функция, вычисляющая результат вызова метода</summary>
        </member>
        <member name="P:System.Reflection.Method`2.Name">
            <summary>Имя контролируемого метода</summary>
        </member>
        <member name="P:System.Reflection.Method`2.Object">
            <summary>Объект, метод которого контролируется</summary>
        </member>
        <member name="P:System.Reflection.Method`2.Private">
            <summary>Метод не является публичным?</summary>
        </member>
        <member name="M:System.Reflection.Method`2.#ctor(`0,System.String,System.Boolean)">
            <summary>Инициализация нового экземпляра <see cref="T:System.Reflection.Method`2"/></summary>
            <param name="o">Объект, метод которого контролируется</param>
            <param name="Name">Имя контролируемого метода</param>
            <param name="Private">Метод не является публичным?</param>
        </member>
        <member name="M:System.Reflection.Method`2.Initialize(`0,System.String,System.Boolean)">
            <summary>Инициализация <see cref="T:System.Reflection.Method`2"/></summary>
            <param name="obj">Объект, метод которого контролируется</param>
            <param name="MethodName">Имя контролируемого метода</param>
            <param name="IsPrivate">Метод не является публичным?</param>
        </member>
        <member name="M:System.Reflection.Method`2.Invoke(System.Object[])">
            <summary>Вызвать метод</summary>
            <param name="Args">Набор параметров, передаваемый методу</param>
            <returns>Результат вызова метода</returns>
        </member>
        <member name="M:System.Reflection.Method`2.PrivateInvoke(System.Object[])">
            <summary>Внутренний метод, осуществляющий вызов метода</summary>
            <param name="Args">Параметры вызова метода</param>
            <returns>Результат вызова метода</returns>
        </member>
        <member name="T:System.Reflection.MethodExtensions">
            <summary>Класс методов-расширения для <see cref="T:System.Object"/>, осуществляющих доступ к методам</summary>
        </member>
        <member name="M:System.Reflection.MethodExtensions.GetMethod``2(``0,System.String,System.Boolean)">
            <summary>Получить объект контроля метода</summary>
            <param name="o">Объект, Метод которого требуется контролировать</param>
            <param name="Name">Имя метода, контроль над которым требуется получить</param>
            <param name="Private">Метод является непубличным?</param>
            <typeparam name="TObject">Тип объекта</typeparam>
            <typeparam name="TValue">Тип значения метода</typeparam>
            <returns>Объект контроля метода</returns>
        </member>
        <member name="T:System.Reflection.Property`2">
            <summary>"Свойство" позднего связывания</summary>
            <typeparam name="TObject">Тип объекта, для которого определяется свойство</typeparam>
            <typeparam name="TValue">Тип значения свойства</typeparam>
        </member>
        <member name="E:System.Reflection.Property`2.ValueChanged">
            <summary>Событие возникает если свойство <see cref="P:System.Reflection.Property`2.Value"/> изменило своё значение</summary>
        </member>
        <member name="M:System.Reflection.Property`2.OnValueChanged(System.EventArgs)">
            <summary>Генерация события <see cref="E:System.Reflection.Property`2.ValueChanged"/></summary>
            <param name="E">Аргумент события</param>
        </member>
        <member name="F:System.Reflection.Property`2._PropertyInfo">
            <summary>Информация о свойстве</summary>
        </member>
        <member name="F:System.Reflection.Property`2._Name">
            <summary>Имя свойства</summary>
        </member>
        <member name="F:System.Reflection.Property`2._Object">
            <summary>Объект, которому принадлежит свойство</summary>
        </member>
        <member name="F:System.Reflection.Property`2._Private">
            <summary>Флаг приватности свойства</summary>
        </member>
        <member name="F:System.Reflection.Property`2._SetMethod">
            <summary>Действие, осуществляющее установку значения свойства</summary>
        </member>
        <member name="F:System.Reflection.Property`2._GetMethod">
            <summary>Функция, вычисляющая значение свойства</summary>
        </member>
        <member name="F:System.Reflection.Property`2._Descriptor">
            <summary>Описание свойства</summary>
        </member>
        <member name="P:System.Reflection.Property`2.PropertyType">
            <summary>Тип значения свойства</summary>
        </member>
        <member name="P:System.Reflection.Property`2.Name">
            <summary>Имя свойства</summary>
        </member>
        <member name="P:System.Reflection.Property`2.Object">
            <summary>Объект, определяющий свойство</summary>
        </member>
        <member name="P:System.Reflection.Property`2.Private">
            <summary>Признак - является ли свойство приватным</summary>
        </member>
        <member name="P:System.Reflection.Property`2.IsExist">
            <summary>Признак </summary>
        </member>
        <member name="P:System.Reflection.Property`2.Value">
            <summary>Значение свойства</summary>
        </member>
        <member name="P:System.Reflection.Property`2.CanRead">
            <summary>Признак возможности читать значение</summary>
        </member>
        <member name="P:System.Reflection.Property`2.CanWrite">
            <summary>Признак возможности устанавливать значение</summary>
        </member>
        <member name="P:System.Reflection.Property`2.SupportsChangeEvents">
            <summary>Поддерживает генерацию событий изменения значения</summary>
        </member>
        <member name="P:System.Reflection.Property`2.Attributes">
            <summary>Атрибуты свойства</summary>
        </member>
        <member name="P:System.Reflection.Property`2.Descriptor">
            <summary>Дескриптор свойства объекта</summary>
        </member>
        <member name="P:System.Reflection.Property`2.DisplayName">
            <summary>Значение <see cref="P:System.ComponentModel.DisplayNameAttribute.DisplayName"/></summary>
        </member>
        <member name="P:System.Reflection.Property`2.Description">
            <summary>Значение <see cref="P:System.ComponentModel.DescriptionAttribute.Description"/></summary>
        </member>
        <member name="M:System.Reflection.Property`2.#ctor(System.String,System.Boolean)">
            <summary>Новый объект "Свойство" для позднего связывания</summary>
            <param name="Name">Имя свойства</param>
            <param name="Private">Является ли свойство скрытым</param>
        </member>
        <member name="M:System.Reflection.Property`2.#ctor(`0,System.String,System.Boolean)">
            <summary>Новый объект "Свойство" для позднего связывания</summary>
            <param name="o">Объект, для которого определяется свойство</param>
            <param name="Name">Имя свойства</param>
            <param name="Private">Является ли свойство скрытым</param>
        </member>
        <member name="M:System.Reflection.Property`2.Initialize(`0,System.String,System.Boolean)">
            <summary>Инициализация данных о свойстве</summary>
            <param name="o">Объект, свойство которого требуется контролировать</param>
            <param name="PropertyName">Имя запрашиваемого свойства</param>
            <param name="IsPrivate">Искать непубличные свойства</param>
        </member>
        <member name="M:System.Reflection.Property`2.PropertyValueChanged(System.Object,System.EventArgs)">
            <summary>Обработчик события изменения значения свойства</summary>
            <param name="Sender">Источник события - объект, свойство которого контролируется</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="M:System.Reflection.Property`2.SetValue(`1)">
            <summary>Метод, позволяющий установить значение свойства</summary>
            <param name="value">Устанавливаемое значение свойства</param>
        </member>
        <member name="M:System.Reflection.Property`2.GetValue">
            <summary>Метод, позволяющий получить значение свойства</summary>
            <returns>Значение свойства</returns>
        </member>
        <member name="M:System.Reflection.Property`2.ToString">
            <inheritdoc />
        </member>
        <member name="T:System.Reflection.PropertyExtensions">
            <summary>Класс методов-расширений для <see cref="T:System.Object"/>, обеспечивающих взаимодействие с его свойствами</summary>
        </member>
        <member name="M:System.Reflection.PropertyExtensions.GetProperty``2(``0,System.String,System.Boolean)">
            <summary>Получить объект управления и доступа к информации указанного свойства</summary>
            <param name="o">Объект, свойство которого требуется контролировать</param>
            <param name="Name">Имя контролируемого свойства</param>
            <param name="Private">Осуществить доступ к непубличным свойствам</param>
            <typeparam name="TObject">Тип объекта, свойство которого запрашивается</typeparam>
            <typeparam name="TValue">Тип значения свойства</typeparam>
            <returns>Объект контроля свойства объекта</returns>
        </member>
        <member name="T:System.StreamingObjectReader`1">
            <summary>Класс поточного чтения объектов из потока данных</summary>
            <typeparam name="T">Тип читаемых объектов</typeparam>
        </member>
        <member name="E:System.StreamingObjectReader`1.Readed">
            <summary>Событие чтения нового объекта из потока данных</summary>
        </member>
        <member name="M:System.StreamingObjectReader`1.OnReaded(System.EventArgs{`0})">
            <summary>Источник события чтения объекта из потока данных</summary>
            <param name="e">Аргумент события, содержащий прочитанный объект</param>
        </member>
        <member name="M:System.StreamingObjectReader`1.OnReaded(`0)">
            <summary>Источник события чтения объекта из потока данных</summary>
            <param name="obj">Прочитанный объект</param>
        </member>
        <member name="F:System.StreamingObjectReader`1._DataStream">
            <summary>Потока данных</summary>
        </member>
        <member name="P:System.StreamingObjectReader`1.DataStream">
            <summary>Потока данных</summary>
        </member>
        <member name="P:System.StreamingObjectReader`1.Completed">
            <summary>Процент готовности</summary>
        </member>
        <member name="P:System.StreamingObjectReader`1.Speed">
            <summary>Скорость обработки данных</summary>
        </member>
        <member name="P:System.StreamingObjectReader`1.RemainingTime">
            <summary>Оставшееся время до окончания обработки</summary>
        </member>
        <member name="M:System.StreamingObjectReader`1.#ctor(System.IO.Stream)">
            <summary>Инициализация нового экземпляра <see cref="T:System.StreamingObjectReader`1"/></summary>
            <param name="DataStream">Поток байт из которого требуется читать объекты</param>
        </member>
        <member name="M:System.StreamingObjectReader`1.Initializer">
            <inheritdoc />
        </member>
        <member name="M:System.StreamingObjectReader`1.MainAction">
            <inheritdoc />
        </member>
        <member name="M:System.StreamingObjectReader`1.Subscribe(System.IObserver{`0})">
            <inheritdoc />
        </member>
        <member name="T:System.StreamWrapper">
            <summary>Объект с интерфейсом потока байт данных, обеспечивающий слежение за процессами чтения/записи данных</summary>
        </member>
        <member name="T:System.StreamWrapper.SeekArgs">
            <summary>Аргумент события <see cref="E:System.StreamWrapper.OnSeek"/></summary>
        </member>
        <member name="P:System.StreamWrapper.SeekArgs.Offset">
            <summary>Величина заданного смещения в потоке</summary>
        </member>
        <member name="P:System.StreamWrapper.SeekArgs.Origin">
            <summary>Направление смещения в потоке</summary>
        </member>
        <member name="P:System.StreamWrapper.SeekArgs.Result">
            <summary>Результат выполнения смещения в потоке</summary>
        </member>
        <member name="M:System.StreamWrapper.SeekArgs.#ctor(System.Int64,System.IO.SeekOrigin,System.Int64)">
            <summary>Инициализация нового экземпляра <see cref="T:System.StreamWrapper.SeekArgs"/></summary>
            <param name="Offset">Величина заданного смещения в потоке</param>
            <param name="Origin">Направление смещения в потоке</param>
            <param name="Result">Результат выполнения смещения в потоке</param>
        </member>
        <member name="T:System.StreamWrapper.SetLengthArgs">
            <summary>Аргумент события <see cref="E:System.StreamWrapper.OnSetLength"/></summary>
        </member>
        <member name="P:System.StreamWrapper.SetLengthArgs.OldLength">
            <summary>Предыдущая длина потока</summary>
        </member>
        <member name="P:System.StreamWrapper.SetLengthArgs.Length">
            <summary>Установленная длина потока</summary>
        </member>
        <member name="M:System.StreamWrapper.SetLengthArgs.#ctor(System.Int64,System.Int64)">
            <summary>Инициализация нового экземпляра <see cref="T:System.StreamWrapper.SetLengthArgs"/></summary>
            <param name="OldLength">Предыдущая длина потока</param>
            <param name="Length">Установленная длина потока</param>
        </member>
        <member name="T:System.StreamWrapper.ReadArgs">
            <summary>Аргумент события <see cref="E:System.StreamWrapper.OnRead"/></summary>
        </member>
        <member name="P:System.StreamWrapper.ReadArgs.Buffer">
            <summary>Прочитанный массив байт</summary>
        </member>
        <member name="P:System.StreamWrapper.ReadArgs.Offset">
            <summary>Смещение в массиве</summary>
        </member>
        <member name="P:System.StreamWrapper.ReadArgs.Count">
            <summary>Число читаемых байт</summary>
        </member>
        <member name="P:System.StreamWrapper.ReadArgs.Result">
            <summary>Число прочитанных байт</summary>
        </member>
        <member name="M:System.StreamWrapper.ReadArgs.#ctor(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>Инициализация нового экземпляра <see cref="T:System.StreamWrapper.ReadArgs"/></summary>
            <param name="Buffer">Прочитанный массив байт</param>
            <param name="Offset">Смещение в массиве</param>
            <param name="Count">Число читаемых байт</param>
            <param name="Result">Число прочитанных байт</param>
        </member>
        <member name="T:System.StreamWrapper.WriteArgs">
            <summary>Аргумент события <see cref="E:System.StreamWrapper.OnWrite"/></summary>
        </member>
        <member name="P:System.StreamWrapper.WriteArgs.Buffer">
            <summary>Записываемый массив байт</summary>
        </member>
        <member name="P:System.StreamWrapper.WriteArgs.Offset">
            <summary>Смещение в массиве</summary>
        </member>
        <member name="P:System.StreamWrapper.WriteArgs.Count">
            <summary>Число записываемых байт</summary>
        </member>
        <member name="M:System.StreamWrapper.WriteArgs.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>Инициализация нового экземпляра <see cref="T:System.StreamWrapper.WriteArgs"/></summary>
            <param name="Buffer">Записываемый массив байт</param>
            <param name="Offset">Смещение в массиве</param>
            <param name="Count">Число записываемых байт</param>
        </member>
        <member name="T:System.StreamWrapper.PositionChangedArgs">
            <summary>Аргумент события <see cref="E:System.StreamWrapper.OnPositionChanged"/></summary>
        </member>
        <member name="P:System.StreamWrapper.PositionChangedArgs.OldPosition">
            <summary>Предыдущее положение в потоке данных</summary>
        </member>
        <member name="P:System.StreamWrapper.PositionChangedArgs.NewPosition">
            <summary>Новое положение в потоке данных</summary>
        </member>
        <member name="M:System.StreamWrapper.PositionChangedArgs.#ctor(System.Int64,System.Int64)">
            <summary>Инициализация нового экземпляра <see cref="T:System.StreamWrapper.PositionChangedArgs"/></summary>
            <param name="OldPosition">Предыдущее положение в потоке данных</param>
            <param name="NewPosition">Новое положение в потоке данных</param>
        </member>
        <member name="E:System.StreamWrapper.OnFlush">
            <summary>Событие возникает при вызове метода <see cref="M:System.StreamWrapper.Flush"/></summary>
        </member>
        <member name="E:System.StreamWrapper.OnSeek">
            <summary>Событие возникает при изменении положения считывания/записи</summary>
        </member>
        <member name="E:System.StreamWrapper.OnSetLength">
            <summary>Событие возникает при изменении длины потока</summary>
        </member>
        <member name="E:System.StreamWrapper.OnRead">
            <summary>Событие возникает при чтении данных из потока</summary>
        </member>
        <member name="E:System.StreamWrapper.OnWrite">
            <summary>Событие возникает при записи данных в поток</summary>
        </member>
        <member name="E:System.StreamWrapper.OnPositionChanged">
            <summary>Событие возникает в момент, когда положение чтение/записи в потоке смещается</summary>
        </member>
        <member name="E:System.StreamWrapper.OnEndOfStream">
            <summary>Событие, возникающее когда положение чтение/записи выходит на конец потока</summary>
        </member>
        <member name="M:System.StreamWrapper.#ctor(System.IO.Stream)">
            <summary>Инициализация нового экземпляра <see cref="T:System.StreamWrapper"/></summary>
            <param name="Source">Поток, доступ к которому требуется контролировать</param>
        </member>
        <member name="M:System.StreamWrapper.Flush">
            <inheritdoc />
        </member>
        <member name="M:System.StreamWrapper.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc />
        </member>
        <member name="M:System.StreamWrapper.SetLength(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:System.StreamWrapper.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:System.StreamWrapper.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:System.StreamWrapper.CanRead">
            <summary>Можно ли осуществлять чтение данных из потока (определяется внутренним потоком)</summary>
        </member>
        <member name="P:System.StreamWrapper.CanSeek">
            <summary>Можно ли осуществлять перемещение позиции чтения/записи в потоке (определяется внутренним потоком)</summary>
        </member>
        <member name="P:System.StreamWrapper.CanWrite">
            <summary>Можно ли осуществлять запись данных в поток (определяется внутренним потоком)</summary>
        </member>
        <member name="P:System.StreamWrapper.Length">
            <summary>Длина потока</summary>
        </member>
        <member name="P:System.StreamWrapper.Position">
            <summary>Текущее положение в потоке (при установке значения осуществляется проверка на предмет конца потока)</summary>
        </member>
        <member name="P:System.StreamWrapper.EndOfStream">
            <summary>Признак конца потока</summary>
        </member>
        <member name="P:System.StreamWrapper.Progress">
            <summary>Прогресс</summary>
        </member>
        <member name="M:System.StreamWrapper.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
    </members>
</doc>
